# 正则表达式

## *简介*

正则表达式是正则语言，使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文本编辑器里，正则表达式都被用来检索、替换或者说**模糊匹配**那些符合某个模式 pattern 的文本。在Linux中，grep、sed、awk等文本处理工具都支持通过正则表达式来进行模式匹配

正则语言不仅限于某种特定编程语言，它在许多编程语言中都有支持，包括但不限于Perl、Python、Java、C++、JavaScript等

注意：**正则表达式的修饰符在不同编程语言和正则表达式引擎中可能会有些许不同**，因此在使用时，请查看相应的文档以了解支持和行为的详细信息。修饰符可以根据需要进行组合，以满足特定的匹配需求，从而提高正则表达式的灵活性和功能

## *元字符*

正则语言的元字符是一组特殊字符，它们具有特殊的含义，**用于在正则表达式中表示模式和匹配规则**。这些元字符通常不表示字面字符，而是表示一些特定的文本模式或操作

常规匹配就是一串**不包含**任何特殊字符的正则表达式匹配它自己

### 常用特殊字符用于模糊匹配

* `^` 匹配一行的开头，`^a` 以a开头的行
* `$` 匹配一行的结束，`t$` 以t为结尾的行。`^$` 匹配空行
* `.` **除换行符 `\n` 之外**的任意单个字符，比如 `r..t` 可以匹配任意以r开头，以t结尾的4字单词
* `*` wildcard 匹配前面一个字符零次或多次（任意多次），比如 `ro*t` 可以是rt、rot、root ... 。`.*` 可以匹配任意字符串，比如想要匹配任意以a开头，以bash结尾的字符串 `^a.*bash$`
* `+` 匹配前面一个字符一次或多次（至少一次）
* `?` 匹配前面一个字符零次或一次（至多一次）。例如，`ab?`匹配 "a" 或 "ab"
* `[]` 字符类集合：用于匹配单个字符中的一个字符。例如，`[aeiou]`匹配任何一个元音字母。下面是一些常用的字符类集合
  * `[0-9]` 匹配一个0到9的数字
  * `[0-9]*` 匹配任意长度的数字字符串
  * `[a-z]` 匹配一个a-z的字符
  * `[a-z]*` 匹配任意长度的字符字符串
  * `[A-Za-z0-9]` 匹配A-Z或者a-z或者0-9之间的任意字符
* `[^]`：在字符类内使用脱字符表示匹配除指定字符之外的任何字符。例如，`[^0-9]`匹配任何非数字字符
* `|`（管道符）：用于分隔多个模式，表示“或”关系。例如，`cat|dog`匹配 "cat" 或 "dog"
* `()`（捕获组 capturing group）：用于创建一个捕获组，可以在匹配中提取和操作捕获的子字符串。标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用
* `{}` 用于确定匹配的次数
  * `{n}`：要求字符出现n次
  * `{n,}`：要求字符出现n到多次
  * `{n,m}`：要求字符出现n到m次

* `/` **通常不是正则表达式模式的一部分，而是用于包围正则表达式模式的定界符 delimiter**。在许多编程语言和环境中，正则表达式通常需要包含在斜杠之间，以指示这是一个正则表达式。这种方式有助于解释器或编译器识别正则表达式的开始和结束

### `\` 转义

`\` 表示转义，并不会单独使用。由于所有特殊字符都有其特定的匹配模式，当我们想要匹配某一特殊字符本身时，比如说想要找出所有包含 `$` 的行，就会发生问题，所以此时可以用 `\` 来消除特殊字符的特殊意义

注意：C++中使用时所有带有 `\` 的转义符都要写成 `\\` 转义

* `\A`：匹配输入字符串的开头，与 `^` 不同，它只匹配整个字符串的开始，不受多行模式的影响。
* `\Z`：匹配输入字符串的结尾，与 `$` 不同，它只匹配整个字符串的结尾，不受多行模式的影响。
* `\b`：匹配一个单词边界，用于确保匹配的单词或字符序列处于单词的开头或结尾。例如， `'er\b'` 可以匹配"never" 中的 `'er'`，但不能匹配 `"verb"` 中的 `'er'`
* `\B`：匹配非单词边界，与 `\b` 相反，用于匹配不处于单词边界的位置。`'er\B'` 能匹配 "verb" 中的 `'er'`，但不能匹配 "never" 中的 `'er'`
* `\w`：匹配任何字母、数字或下划线字符，相当于`[a-zA-Z0-9_]`
* `\W`：匹配任何非单词字符，与 `\w` 相反
* `\d`：匹配任何数字字符，相当于`[0-9]`
* `\D`：匹配任何非数字字符，与 `\d` 相反
* `\s`：匹配任何空白字符，包括空格、制表符、换行符等
* `\S`：匹配任何非空白字符，与 `\s` 相反
* `\t`：匹配制表符字符
* `\n`：匹配换行符字符
* `\r`：匹配回车符字符

### `?=`、`?<=`、`?!`、`?<!` 断言

正则表达式中的 `?=`、`?<=`、`?!`、`?<!` 是一些特殊的构造，用于进行正则表达式的先行断言 lookahead 和后行断言 lookbehind。它们允许在匹配模式中添加条件，以便只匹配满足特定条件的文本。以下是它们的作用和用法：

* 正向先行断言 Positive Lookahead
  * 语法：`exp1(?=exp2)`
  * 作用：查找 exp2 前面的 exp1。在当前位置匹配满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之后的文本
  * 示例：`/foo(?=bar)/` 匹配 "foo"，但只有在后面紧跟着 "bar" 的情况下才匹配成功
* 正向后行断言 Positive Lookbehind
  * 语法：`(?<=exp2)exp1`
  * 作用：查找 exp2 后面的 exp1。在当前位置之前匹配满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之前的文本
  * 示例：/(?<=foo)bar/ 匹配 "bar"，但只有在前面紧跟着 "foo" 的情况下才匹配成功
* 负向先行断言 Negative Lookahead
  * 语法：`exp1(?!exp2)`
  * 作用：查找后面不是 exp2 的 exp1。在当前位置匹配不满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之后的文本
  * 示例：/foo(?!bar)/ 匹配 "foo"，但只有在后面不紧跟着 "bar" 的情况下才匹配成功
* 负向后行断言 Negative Lookbehind
  * 语法：`(?<!exp2)exp1`
  * 作用：查找前面不是 exp2 的 exp1。在当前位置之前匹配不满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之前的文本
  * 示例：`/(?<!foo)bar/` 匹配 "bar"，但只有在前面不紧跟着 "foo" 的情况下才匹配成功

这些断言允许在匹配模式中添加条件，以限制匹配的范围，或者确保某些文本前后都满足特定条件。它们在处理复杂文本匹配问题时非常有用，但也需要谨慎使用，因为它们可能导致正则表达式变得复杂难懂

### 修饰符

正则表达式中的修饰符是一些可选标志，它们可以附加到正则表达式模式的末尾，以改变匹配行为。这些修饰符通常是单个字母，例如在大多数编程语言中都是单个字符

以下是一些常见的正则表达式修饰符：

* **/i**（不区分大小写）：通常用于匹配时不区分字母大小写。例如，`/abc/i` 可以匹配 "abc"、"AbC"、"aBC" 等。
* **/g**（全局匹配）：通常用于找到所有匹配项，而不仅仅是第一个匹配项。例如，`/abc/g` 可以找到输入字符串中的所有 "abc"
* **/m**（多行匹配）：通常用于处理多行文本，修改 `^` 和 `$` 的行为，使它们匹配每一行的开头和结尾。例如，`/pattern/m` 可以匹配多行文本中的 "pattern"
* **/s**（单行匹配）：通常用于处理单行文本，使 `.` 匹配**包括换行符在内**的任何字符。例如，`/a.b/s` 可以匹配 "a\nb"
* **/x**（扩展模式）：通常用于允许在模式中添加注释和空白字符，以提高可读性。例如，`/a b c/x` 可以匹配 "abc"
* **/u**（Unicode模式）：通常用于处理Unicode字符。它启用了Unicode字符的特殊处理，以便正确匹配Unicode字符。例如，`/\w/u` 可以匹配任何Unicode字母、数字和下划线

## *运算符优先级*

1. `\` 转义符
2. `(), (?:), (?=), []` 圆括号和方括号
3. `*, +, ?, {n}, {n,}, {n,m}` 限定符
4. `^, $, \任何元字符、任何字符` 定位点和序列（即：位置和顺序）
5. `|` 替换，"或"操作。字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"

## *常用正则表达式*

[正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)

### 校验数字的表达式

* 数字：`^[0-9]*$`
* n位的数字：`^\d{n}$`
* 至少n位的数字：`^\d{n,}$`
* m-n位的数字：`^\d{m,n}$`
* 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
* 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(\.[0-9]{1,2})?$`
* 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})$`
* 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
* 有两位小数的正实数：`^[0-9]+(\.[0-9]{2})?$`
* 有1~3位小数的正实数：`^[0-9]+(\.[0-9]{1,3})?$`
* 非零的正整数：`^[1-9]\d*$` 或 `^([1-9][0-9]*){1,3}$` 或 `^\+?[1-9][0-9]*$`
* 非零的负整数：`^\-[1-9][]0-9"*$` 或 `^-[1-9]\d*$`
* 非负整数：`^\d+$` 或 `^[1-9]\d*|0$`
* 非正整数：`^-[1-9]\d*|0$` 或 `^((-\d+)|(0+))$`
* 非负浮点数：`^\d+(\.\d+)?$` 或 `^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
* 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$` 或 `^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
* 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$` 或 `^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
* 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$` 或 `^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
* 浮点数：`^(-?\d+)(\.\d+)?$` 或 `^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

### 校验字符的表达式

* 汉字：`^[\u4e00-\u9fa5]{0,}$`
* 英文和数字：`^[A-Za-z0-9]+$` 或 `^[A-Za-z0-9]{4,40}$`
* 长度为3-20的所有字符：`^.{3,20}$`
* 由26个英文字母组成的字符串：`^[A-Za-z]+$`
* 由26个大写英文字母组成的字符串：`^[A-Z]+$`
* 由26个小写英文字母组成的字符串：`^[a-z]+$`
* 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
* 由数字、26个英文字母或者下划线组成的字符串：`^\w+$` 或 `^\w{3,20}$`
* 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
* 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$` 或 `^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
* 可以输入含有 `^%&',;=?$\"` 等字符：`[^%&',;=?$\x22]+`
* 禁止输入含有 `~` 的字符：`[^~]+`

### 特殊需求表达式

* Email地址：`^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$`
* 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?`
* Internet URL：`[a-zA-z]+://[^\s]\*` 或 `^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]\*)?$`
* 手机号码：`^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$`
* 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：`^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$`
* 国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`
* 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: `((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)`
* 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：`(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)`
* 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$
* 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`
* 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：`^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z])[a-zA-Z0-9]{8,10}$`
* 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：`^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).{8,10}$`
* 日期格式：`^\d{4}-\d{1,2}-\d{1,2}`
* 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`
* 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
* 钱的输入格式：
  1. 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：`^[1-9][0-9]\*$`
  2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]\*)$`
  3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]\*)$`
  4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
  5. 必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：`^[0-9]+(.[0-9]{2})?$`
  6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：`^[0-9]+(.[0-9]{1,2})?$`
  7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：`^[0-9]{1,3}(,[0-9]{3})\*(.[0-9]{1,2})?$`
  8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})\*)(.[0-9]{1,2})?$`
  9. 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
* xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$`
* 中文字符的正则表达式：`[\u4e00-\u9fa5]`
* 双字节字符：`[^\x00-\xff]` (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
* 空白行的正则表达式：`\n\s\*\r` (可以用来删除空白行)
* HTML标记的正则表达式：`<(\S\*?)[^>]\*>.\*?|<.\*? />` ( 首尾空白字符的正则表达式：`^\s\*|\s\*$` 或 `(^\s\*)|(\s\*$)` (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
* 腾讯QQ号：`[1-9][0-9]{4,}` (腾讯QQ号从10000开始)
* 中国邮政编码：`[1-9]\d{5}(?!\d)` (中国邮政编码为6位数字)
* IPv4地址：`((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}`



## *文本处理工具*

在Linux中，grep、sed、awk等文本处理工具都支持通过正则表达式来进行模式匹配

### cut

`cut`命令用于在文本文件中剪切和提取字段的命令行工具。它通常用于从文本行中选择特定的列或字符，然后将结果输出到标准输出或文件中。`cut`命令的基本语法如下：

* `d`选项：指定字段分隔符，默认为制表符（Tab `\t`）

  ```shell
  $ cut -d',' -f2 file.txt  # 使用逗号作为分隔符提取第二个字段
  ```

* `-f`选项：指定要提取的字段或字段范围

  ```shell
  $ cut -f1,3 file.txt    # 提取第一个和第三个字段
  $ cut -f2-4 file.txt    # 提取第二到第四个字段
  ```

* `-c`选项：指定在每行中要提取的字符位置或范围

  ```shell
  $ cut -cchars <file-name>
  $ cut -c1-5 file.txt    # 提取第1到第5个字符
  $ cut -c2,4,6 file.txt  # 提取第2、4和6个字符
  ```

* `-s`选项：禁止输出不包含分隔符的行

  ```shell
  $ cut -s -d',' -f2 file.txt  # 只输出包含逗号分隔符的行的第二个字段
  ```

* `--complement`选项：输出除指定字段之外的字段

  ```shell
  $ cut -d',' --complement -f2 file.txt  # 输出除第二个字段之外的所有字段
  ```

### paste

paste 命令的效果和 cut 相反：它不是拆分行，而是合并行

* `-d`或`--delimiter`：用于指定分隔符，它允许在合并后的行之间插入一个自定义的分隔符。例如，`-d ','`将使用逗号作为分隔符
* `-s`或`--serial`：默认情况下，`paste`命令将文件按行并列合并。如果使用了`-s`选项，它将从第一个文件开始，合并每个文件的所有行，然后再合并下一个文件的所有行，以此类推

### ed

`ed`是一个文本编辑器，它可以用于在命令行中编辑文本文件。它是Unix系统最早的文本编辑器之一，在每一个Unix系统中都默认有。通常用于批量编辑文本文件或在纯文本终端环境中进行编辑

`ed`的使用方式是在终端中启动`ed`程序，然后输入一系列命令来编辑文本。`ed`不提供图形用户界面，因此在使用时需要学习一些命令语法。例如，可以使用`ed`来插入、删除、替换文本行，以及移动光标等

```shell
$ ed filename.txt
ed> 1i            # 在第一行之前插入文本
This is a test.
.
ed> 2d            # 删除第二行
ed> 3s/old/new/   # 将第三行中的 "old" 替换为 "new"
ed> w             # 保存更改
ed> q             # 退出编辑器
```

### sed

Sed（stream editor）可以用来在管道或命令序列中编辑数据。和ed不同，sed不是交互式程序，sed会将指令的命令应用到输入的每一行上，并将结果写入到标准输出

```shell
$ sed [选项] '脚本' [文件]
```

* `[选项]`：可以是一些控制`sed`行为的可选选项
* `'脚本'`：是`sed`命令的操作序列，通常包含一个或多个`sed`命令，用于指定文本的处理方式
* `[文件]`：是要处理的输入文件的名称。如果未提供文件名，`sed`将默认从标准输入读取数据

下面介绍sed的选项

* `-n` ：默认情况下sed将输入的每一行都写入到标准输出中，`-n` 则告诉sed默认不打印任何行。与之搭配使用的是 p 命令,p 命令可以打印出符合指定范围或模式的所有行

  ```shell
  $ sed -n '1,2p' input.txt # 只打印前两行
  ```

  下面这个命令用来查看一些特殊的符号，比如说制表符 `\t` 之类的很好用

  ```shell
  $ sed -n l file
  ```

* `-e`：多个操作，可以将多个`sed`命令组合在一起，以依次对文本进行多次处理

  ```shell
  $ sed -e 's/old/new/g' -e '/pattern/d' input.txt
  ```

### tr

`tr`命令用于在文本流中进行字符转换和删除操作。它通常用于处理文本数据的字符级别操作，例如字符替换、删除和转换。以下是`tr`命令的基本用法和一些常见选项：

```shell
$ tr [选项] 字符集1 字符集2
```

* `[选项]`：可以是一些控制`tr`行为的可选选项
* `字符集1`：要被替换或删除的字符集
* `字符集2`：用于替换或转换的字符集

`tr`的一些常用选项和用法包括：

1. **替换字符**：最常见的用法是替换一个字符集中的字符为另一个字符集中的字符。例如，将所有小写字母转换为大写字母：

   ```shell
   $ echo "hello" | tr 'a-z' 'A-Z'
   ```

   输出结果为："HELLO"

2. **删除字符**：可以使用`-d`选项来删除指定字符集中的字符。例如，删除文本中的所有空格：

   ```shell
   $ echo "Hello, World!" | tr -d ' '
   ```

   输出结果为："Hello,World!"

3. **字符集补集**：可以使用`-c`选项来指定字符集的补集，即除了指定字符集以外的所有字符。例如，删除除了数字以外的所有字符：

   ```shell
   $ echo "abc123" | tr -c '0-9' '\n'
   ```

   输出结果为："123"

4. **字符转义**：使用`-s`选项可以将多个连续重复的字符替换为一个字符。这在压缩连续的空格或其他字符时非常有用。

   ```shell
   $ echo "Too      many       spaces." | tr -s ' '
   ```

   输出结果为："Too many spaces."

5. **删除换行符**：可以使用`-d`选项删除换行符，将文本压缩成一行。

   ```shell
   $ cat file.txt | tr -d '\n'
   ```

6. **将字符映射为其他字符**：通过提供字符映射表，可以将一个字符集中的字符映射为另一个字符集中的字符。例如，将数字0-9映射为字母a-j：

   ```shell
   $ echo "0123456789" | tr '0-9' 'a-j'
   ```

   输出结果为："abcdefghij"

### sort

`sort`命令用于对文本文件中的行进行排序的。它默认按照字母顺序（升序）对文本行进行排序，但也可以根据需要进行不同类型的排序。特殊字符会根据其内部编码来排序，另外一些外语字符、标点符号和其他特殊字符的排序可能会出现一些意料之外的情况

以下是`sort`命令的基本用法和一些常见选项：

* `-u`：去重，只保留唯一的行。等价于 `sort | uniq`
* `-r`：进行逆序（降序）排序，将结果从大到小排列
* `-n`：按数字顺序排序，这将确保数字按数值大小而不是字符顺序进行排序

### uniq

```shell
$ uniq <input_file> [output_file]
```

uniq 命令可用于查找或删除文件中的重复行

uniq 将 input_file 复制为 output_file，同时删除所有重复的行。uniq 将重复的行定义为内容一模一样的连续行。若没有指定 output_file,则结果会写入标准输出。若 input_file 也没有指定，那么 uniq 可以作为过滤器，即从标准输入中读取输入

* uniq 的-c 选项可以统计出现的次数，在脚本中极为有用

### tee

`tee` 用于从标准输入中读取数据，并将数据同时输出到标准输出和一个或多个文件。它的名字"tee"来自于水管系统中的T型接头，表示数据从一个管道分流到多个管道的操作。`tee`通常用于将命令的输出保存到文件同时在终端上显示输出，或者将**输出传递给多个不同的处理管道。以下是`tee`的基本用法和一些常见选项：

```
bashCopy code
command | tee [选项] 文件...
```

* `command`：是生成输出的命令或命令序列
* `[选项]`：可以是一些控制`tee`行为的可选选项
* `文件...`：是要写入数据的文件的列表

`tee`的一些常用选项和用法包括：

* 保存输出到文件：最简单的用法是将命令的**输出保存到一个或多个**文件中。例如，将命令的输出保存到`output1.txt`和`output2.txt`文件：

   ```shell
   $ command | tee output.txt output2.txt 
   ```

   `tee`**默认会将命令的输出显示在终端上**，即使将其写入文件。这对于查看实时输出非常有用

* 忽略标准输出：使用`-`（单破折号）选项可以忽略标准输出，只将数据写入文件

   ```shell
   $ command | tee - output.txt
   ```

* 追加到文件：使用`-a`选项可以将输出追加到文件而不是覆盖文件内容。例如，将命令的输出追加到`output.txt`文件：

   ```shell
   $ command | tee -a output.txt
   ```

### grep

`grep`是一个强大的命令行工具，用于在文本文件中搜索指定的模式（正则表达式或字符串），并将匹配的行打印到标准输出。它的名字"grep"是"Global Regular Expression Print"的缩写，强调了其在全局范围内搜索和打印匹配文本的功能。以下是`grep`的基本用法和一些常见选项：

```shell
$ grep [选项] 模式 [文件]
```

* `[选项]`：可以是一些控制`grep`行为的可选选项。
* `模式`：要搜索的文本模式，可以是普通字符串或正则表达式。
* `[文件]`：是要搜索的输入文件的名称。如果未提供文件名，则`grep`将默认从标准输入读取数据。

`grep`的一些常用选项和用法包括：

* 基本搜索：默认情况下，`grep`搜索并打印包含指定模式的行。例如，搜索文件`input.txt`中包含字符串"pattern"的行：

   ```shell
   $ grep "pattern" input.txt
   ```

* 正则表达式搜索：`grep`支持正则表达式搜索。使用`-E`选项或`--extended-regexp`选项来启用扩展正则表达式，以进行更复杂的匹配。

   ```shell
   $ grep -E "regex_pattern" input.txt
   ```

* 逆向搜索：使用`-v`选项可以进行逆向搜索，打印**不包含指定模式**的行

* 统计匹配行数：使用`-c`选项可以仅显示匹配的行数，而不是匹配的行本身

* 忽略大小写：使用`-i`选项可以忽略大小写进行搜索

* 递归搜索：使用`-r`选项可以递归地搜索目录下的所有文件

   ```shell
   $ grep -r "pattern" /path/to/directory
   ```

* 查找模式匹配的文件名：`-l` 选项

* 打印行号：`-n`

### awk

awk命令实际上是一种脚本语言

# 脚本 & 变量

## *helloworld*

```sh
#! /bin/bash
echo "hello, world"
```

脚本以 `#!/bin/bash` 开头来制定解析器 parser

### 执行方式

* 调用子bash或子sh来执行 `bash helloworld.sh`，嵌套执行可能会影响环境变量
* 用绝对路径或相对路径来执行脚本文件
* 用 `source`（csh实现）或 `.`（bash实现） 命令来执行脚本文件。source调用并加载新的配置到子bash

## *变量*

### 分类

* 环境变量和自定义变量
* 全局和局部
  * 全局对所有bash有效，局部只对当前bash有效
  * 用户自定义的默认都是局部变量，可以通过 `export` 来导出为全局变量。但是特别的是对于子shell中更改了全局变量，不会对父shell造成影响

使用一个定义过的变量，只要在变量名前面加 `$` 符号，然后 `{}` 括起来即可

### 变量定义的规则

* 变量名称可以由字母、数字和下划线组成，但是不能以数字开头，环境变量名建议大写

* **等号两侧不能有空格（（

* 变量的值如果有空格，需要使用双引号或单引号括起来

* 在bash中，**变量默认类型都是字符串类型**，无法直接进行数值运算。需要使用下面会介绍的算术扩展机制



### 变量定义基本句法

* 定义变量：变量名=变量值，注意不能有空格，否则会被
* 解释为两条语句
* 撤销变量：unset变量名
* 声明静态/只读变量：readonly变量 `readonly b=5`

### 特殊变量

* `$n`：n是数字，`$0` 代表该脚本名称， `$1-$9` 代表第1-9个参数，10 以上的参数要用花括号括起来 `${10}`

  ```shell
  #! /bin/bash
  echo "Hello, "
  echo $0
  echo $1
  echo $2
  ```

* `$#`：参数个数统计，获取所有输入参数的数量。常用于循环，判断参数的个数是否正确以及增强脚本的健壮性

* `$?`：最后一次执行的命令的返回状态，若为0则上次命令正确指令，非0则执行不正确

* `$*`：代表命令行中所有的参数，`$*` 把所有的参数看成一个整体

* `$@`：也代表命令中所有的参数，但是 `$@` 把每个参数区分对待，即形成一个集合或者数字


## *环境变量*

## *算术扩展*

所有的现代 UNIX 以及 Linux 发行版，（包括 Mac OSX 的命令 Shell）中所包含的 POSIX 标准 Shell 提供了算术扩展 arithmetic expansion 机制，能够用于执行 Shell 变量的整数运算。不过有些比较旧的 Shell 并不支持该特性

算术扩展的格式为:  `$((expression))`

### 支持的运算符

要进行数值运算要用运算符 operator 表达

```shell
a=$((1+5)) # (()) 里面可以用<=这种数学表达式
a=$[5+9]
```

Unix/Linux shell支持

* 常见的算术运算符：加减乘除、取模 `%`
* 比较运算符：`==`、`!=`、`>`、`<`、`>=`、`<=` 等

### 算术扩展命令

或者用比较麻烦的 `expr` 算术扩展命令： `expr 1 + 2` 的时候中间要有空格，而且 `*` 要转义，即 `\*`

### 命令替换

将一个命令运行的结果赋值给变量

```shell
a=$(expr 5 \* 3) # or
a=`expor 5 \* 3`
```

# shell处理引号

## *引号*

### 单引号

单引号甚至可以跨行作用，因为此时Shell也会保留回车并作为命令参数的一部分

```shell
$ echo 'Hello, 
> World' 
Hello, 
World
$
```

解析完第一行之后，Shell 发现引号并没有配对上，因此提会示用户（弹出 `>` 符号）输入结尾的引号。 `>` 叫做辅助提示符  secondary prompt character，Shell 会在等待用户完成多行命令的输入时显示该提示符

### 双引号

## *反斜线*

## *命令替换*

# 函数

## *函数*

### 系统函数

* `basename [string/pathname][suffix]` 取路径里的文件名称，会去掉所有前缀（包括最后一个/），默认保留suffix，若指定了suffix，就会把文件的suffix后缀去掉
* `dirname`：截取绝对路径名称

### 自定义函数

```shell
[ function ] funname[()]
{
	Action;
	[return int;]
}
```

shell脚本是逐行运行，不会编译。所以必须在调用函数的地方之前，先声明函数

函数返回值，只能通过 `$?` 系统变量获得。若不加return，将以最后一条命令的运行结果作为返回值。return后跟数值n（0-255）

# 控制流

## *条件判断*

### 基本语法

* `test condition`

* `[ condition ]` 注意condition前后的空格不可少

  ``` shell
  a=hello
  [ $a = hello ] # 注意condition的空格也不能少，$a=hello 会被理解为一个整体，一个整体是非空的，从而输出0
  [ ] #echo $? 空输出1
  ```

和高级语言相反，shell script用0表示真，非0表示假，因为用的是返回状态作为判断条件

### 常用判断条件

* 两个整数之间比较：-eq 等于 -ne 不等于 -lt 小于 -le 小于等于 -gt 大于 -ge 大于等于

  ```shell
  [ 2 -lt 8 ] #echo $? 输出0 
  ```

* 两个字符串之间的比较：用等号=判断相当，用 != 判断不等

* 按照文件权限进行判断：-r -w -x 是否有读、写、执行的权限

* 按照文件类型进行判断：-e -f -d 文件是否存在 existence、存在并且是一个常规文件 file 、存并且是一个目录 directory

* 多条件判断：`&&` 表示前一条指令执行成功时，才执行后一条命令；`||` 表示上一条命令执行失败后，才执行下一条命令

  ```shell
  a=15
  [ $a -lt 20 ] && echo "$a < 20" || echo "$a >= 20" # 若判断成功则执行中间的，判断失败则执行后面的
  # 和三目运算符一样
  ```

## *流程控制*

### if语句

```shell
if [ condition ]
then
	程序
elif [ condition ]
then
	程序
else
	程序
fi
```

一个小优化保证判断条件不为空，""是进行字符串拼接（用单引号''就不会翻译$1了）

```shell
if [ "$1"x  = "zhang3"x ]; then echo "welcome, zhang3"; fi
```

若是多个判断条件有两种表示方法

```shell
if [ $a -gt 18 ] && [ $a -lt 35 ]; then echo OK; fi
if [ $a -gt 18 -a $a -lt 35 ]; then echo OK; fi # -a -r 表示逻辑与、或
```

### case语句

case就是switch语句

```shell
case $变量名 in
"value 1")
	# 程序1
;; # break
"value 2")
	# 程序2
;;
*)
	# 这里是default
;;
esac
```

## *循环*

### for循环

for循环有两种书写方式

```shell
# 书写方式1
for (( initialization;control;increment )) #(())里的循环变量不用在外面定义
do
	#程序
done

# 书写方式2
for 变量 in value 1 value 2 value 3 # 也可以表示成 for 变量 in (value 1 ... value n)
do
	#程序
done
```

一个例子

```shell
for (( i=1; i <= $1; i++ )) # (()) 里面可以用<=这种数学表达式
do
	sum=$[ $sum + $i ]
done
```

### while循环

```shell
while [ condition ] #[]里的循环变量要在外面定义
do
	程序
done
```

### read读取控制台输入

`read -p -t` -p指定读取值时的提示符；-t指定读取时等待的时间，若不加-t则一直等待
