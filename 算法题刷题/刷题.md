# 单向链表

## *链表重构*

### 什么时候应该加哨兵位头节点？

哨兵位主要是方便了头插、头删的时候找头，以及方便调整头指针等

此外若给了一个空链表，那么首先我们需要判断是否链表为空

个人的经验是：**当涉及到链表的遍历、重构时，构思时不论怎样先把头节点加上，看看是否可以简化边界情况的处理，如果感觉不需要的话再去掉**

### 遍历

各种数据结构的遍历+访问有两种形式：线性的和非线性的。线性的就是用for/while来迭代 iteration，非线形的就是递归 recursion

```cpp
void traverse(vector<int>& nums) {
    for (int i = 0; i < nums.size(); i++) {
        // 迭代访问 arr[i]
    }
}

// 递归遍历数组
void traverse(vector<int>& arr, int i) {
    if (i == arr.size()) {     // base case
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}
```

而链表的遍历则既有线性的也有非线性的

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */

void traverse(ListNode* head) {
    while (head->next) {
        // 迭代访问 p->val
        head = head->next;
    }
}

void traverse(ListNode* head) {
    // 递归访问 head->val
    // 前序位置
    traverse(head -> next);
    // 后序位置
}
```

[二叉树的遍历](#二叉树的遍历)也是既有线性的也有非线性的

同时也可以利用[链表和数组的前序和后序遍历](#链表和数组的前序和后序遍历)来做一些逆序的题目

### 设计链表

* [707. 设计链表](https://leetcode.cn/problems/design-linked-list/)
* 思路：自己定义链表节点Node、使用 `dummyhead_` 简化操作、定义 `size_` 记录链表长度
* 注意点
  * 如果是在Leetcode中主要不要把链表节点命名为ListNode，会发生重定义冲突
  * 找节点的时候从 `dummyhead_` 开始找，而不是从 `dummyhead_->next` 开始找

### <span id="合并两个有序链表">合并两个有序链表</span>

* [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

* 思路1：双指针，比较结点数据大小。令一个为dest，另一个为src，进行尾插。这种方式虽然很清晰，但边界条件很不好控制

* 思路2：双指针归并，从头开始比较，取小的尾插到新链表。归并操作，指的是将两个顺序序列合并成一个顺序序列的方法

  <img src="合并两个有序列表.gif" width="70%">

### <span id="分隔列表">分隔列表</span>

* 题目

  * [86. 分隔链表](https://leetcode.cn/problems/partition-list/)
  * <https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&&tqId=11004&rp=2&ru=/activity/oj&qru=/ta/cracking-the-coding-interview/question-ranking>

* 思路：三指针，一个 `currNewGreater` 跟踪大数值链表，一个 `currNewLess` 跟踪小数值链表，另外一个 `currOld` 跟踪原链表中走到了哪里。`currOld` 走完之后，再把新的两个链表连接起来。**注意⚠️：最后一定要把大链表的最后一个置空，即 `currNewGreater->next = nullptr;`，否则会成环**

  <img src="分隔列表.drawio.png" width="70%">

* 注意：因为我们的做法相当于是直接从原链表上摘节点下来，而且不像[合并两个有序链表](#合并两个有序链表)这道题，我们不能确认最后新的链表的最后一个节点就是（任意）原来链表的最后一个节点（若是的话本身最后一个节点的next就已经是空了）。**所以最后一个节点的next必须要置nullptr**，否则就会形成环

### 合并K个有序链表

* 题目：[23. 合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
* 思路：用一个优先级队列来先将所有的节点入队列，然后思路就和[合并两个有序链表](#合并两个有序链表)这道题一样了。优先级队列默认 `std::less` 建大堆，记得用lambda自定义一下建小堆
* 注意：这道题和[分隔列表]((#分隔列表))那道题有同样的坑，就是因为不知道到底哪个原来的节点是新的最后一个节点，所以一定要将新的最后一个节点置空，否则会成环
* 时间复杂度分析：***O(NlogK)***，N是链表的总节点数，K是链表的条数

### 查找和最小的K对数字

### 复制带随机指针的链表

* [138. 随机链表的复制](https://leetcode.cn/problems/copy-list-with-random-pointer/)

* 思路1：构造深拷贝，问题在于每一个random应该放在什么位置？将要copy的节点连接到源节点的后面

  <img src="复制带随机指针的链表.png">

* 思路2：利用BST的KV模型：存储源节点和拷贝节点的KV映射

### 其他链表重构的题目

* [24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

  <img src="两两交换链表中的节点.drawio.png" width="60%">

## *链表双指针*

### 链表的中间结点

* [876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)

* 思路：快慢指针，慢指针一次走1步，快指针一次走2步

  <img src="链表的中间结点_快慢指针.png" width="50%">

### 删除链表中等于给定值val的所有结点

* [203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)

* 思路1：哨兵位简化尾插后直接遍历过去就行了，尾插一般要考虑哨兵位。说实话这道题使用这种方法已经够了，最自然的想法也就是这种方法

* 思路2：快慢指针，遇到等于val的就调整指针关系

  <img src="删除链表中等于给定值val的所有结点.png" width="50%">

* 思路3：遍历原链表，把不是val的结点拿出来尾插到新链表

### 输入一个链表，输出该链表中倒数第k个结点

* 题目
  * [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
  * <https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 思路
  * 两次遍历求出链表长度N后再走N-K步，复杂度为***O(N)***
  * 快慢指针，快指针先走k步，然后快慢指针同时走。等到快指针走到NULL时，慢指针就是倒数第k个结点。虽然复杂度也为***O(N)***，不过只需要一次遍历了

### 输入两个链表，找出它们的第一个公共结点

* 题目：[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)
* 思路1：快慢指针。分别找出两个链表的长度和长度差k，然后令长的为快指针走k步后，再令快慢之中遍历一次链表并同时判断node的地址是否有相同的
* 思路2：因为给的是struct结构体，所以分别建两个vector后push_back，将长的vector pop_back掉两个vector的长度差个元素，然后逐次比较
* 思路3：利用两个栈，分别入栈，将长的栈pop掉两个栈的长度差个元素，然后逐次比较
* 思路4：利用BST的K模型，找出第一个出现两次的节点

## *删除链表元素*

### <span id="删除排序链表中的重复元素">删除排序链表中的重复元素</span>

* 题目：[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)。这道题虽然标了简单难度，然而是比较麻烦的一道题

* 思路1：用单指针curr来跟踪走到哪里了，这么走是不太好控制的

* 思路2：快慢指针，注意处理尾巴是连续的重复节点的情况，此时要让 `slow->next = nullptr;`

  <img src="删除排序链表中的重复元素.drawio.png" width="70%">

### 删除排序链表中的重复元素 II

* 题目：[删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)
* 思路1：这道题不要用和[删除排序链表中的重复元素](#删除排序链表中的重复元素)一样的双指针走，主要问题在于if-else这种结构中slow是必然要移动的，我们既要用 `slow->val` 来判断是否值相等，又要保存slow之前的那个元素，若引入第三个指针好像会变得很复杂
* 思路2：当发现重复元素时用while把这段区间跳过，这样slow就还是开始重复的元素之前的那一个。尽管如此，这种方法仍然需要考虑一些特殊情况，比较容易犯错误
* 思路2：快慢指针 + table。第一遍遍历和[删除排序链表中的重复元素](#删除排序链表中的重复元素)一样，得到一个只保留一个重复元素的链表，并在此期间也建立一张重复元素的set。第二遍遍历时若遇到了这个节点就调整指针指向。这种方法虽然需要额外空间来保存一个set，但是不需要考虑边界条件或特殊情况，是最简单的一种方法
* 思路3：递归

### 从未排序的链表中移除重复元素

* 题目：[1836. 从未排序的链表中移除重复元素](https://leetcode.cn/problems/remove-duplicates-from-an-unsorted-linked-list/)
* 思路：快慢指针 + table。第一次遍历建立一个元素出现次数的table，第二遍历时若发现元素出现次数 `>=2`，就调整指针，将元素删去

## *判断成环*

### 给定一个链表，判断链表中是否有环

* <https://leetcode.cn/problems/linked-list-cycle/description/>
* 思路：用快慢指针转变为一个追击问题，若有环则慢指针肯定能追上快指针。若没有环则当fast或fast->next走完时就返回false
* 证明：为什么快指针每次走2步，慢指针每次走1步时若有环一定能追上？
  * slow进环后开始追击。假设slow进环后，fast和slow之间的距离是X
  * 这次fast真正开始追击slow，每追击一次，fast和slow之间距离缩短1
  * 直到距离缩短到0，二者相遇
* 如果快指针一次走3步、4步、n步时，fast是否肯定能追上slow呢？不一定！这时候环的大小就有影响了
  * 假设环的大小为R，假设fast一次走3步，每走一次fast和slow距离缩短2
    * 若fast和slow之间的距离N是偶数，则第一次就追上
    * 若X是奇数，则距离会变成X, X-2, ..., 3, 1, X-1
    * 此时开始第二次追击，若R-1是偶数（即R是奇数），则第二次就追上了
    * 若R-1是奇数（R是偶数），则永远追不上

### 返回链表开始入环的第一个结点

* <https://leetcode.cn/problems/linked-list-cycle-ii/>

* 思路1：让快慢指针同时从链表起始位置开始遍历链表找出相遇点。当二者相遇时，让一个指针从**相遇点**位置开始绕环运行，头指针重新从头出发。两个指针都是每次均走一步，最终肯定会在入口点的位置相遇。时间复杂度***O(N)***，空间复杂度***O(1)***

  <img src="返回链表开始入环的第一个结点.png" width="50%">

  * 当slow走1步，fast走2步时，slow进环以后，fast一定在2圈之内追上slow。因为追击过程快慢指针之间相对距离每次缩小1，不可能会错过，他们相对距离最多是1圈，slow最多走1圈就会被追上

  * 设环之前的路程为L，slow进环后走X，环的大小是R

  * 假设slow进环前，fast在环里面转了N圈（$N\geq1$，fast至少要走一圈追上slow）

  * 则fast走的路程为 $L+n*R+X\ (n=1,\cdots,n)$

  * 根据下面的公式可以看出若一个指针从相遇点出发，一个指针从头开始走，他们会在入口点相遇
    $$
    fast == slow\longleftrightarrow L+n*R+X = 2*(L+X) \rightarrow L=n*R-X=(n-1)*R+(R-X)\\\rightarrow L+(R-X)=(n-1)*R
    $$

  * 假设的参数中只有R是可以明确算出来的

* 思路2：建立索引遍历，第一个重新遇到的就是入口。时间、空间复杂度都是***O(N)***

## *单链表递归反转*

### 框架

### 反转一个单链表

* [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

* 遍历法

    * 思路1：颠倒指针

        <img src="206.翻转链表.gif" width="50%">

        ```c
        class Solution {
        public:
            ListNode* reverseList(ListNode* head) {
                ListNode* curr = head;
                ListNode* next = head;
                ListNode* prev = nullptr;
                while (curr != nullptr) {
                    next = curr->next;
                    curr->next = prev;
                    prev = curr;
                    curr = next;
                }
                return prev;
            }
        };
        ```

    * 思路2：遍历原链表，把所有结点拿出来头插尾插到新链表。这个题目的关系没有上面方法那么简单
    
        <img src="反转链表.drawio.png" width="60%">

* 递归法

### 反转一个链表的某个区间

### K个一组反转链表

## *回文链表*

### 链表的回文结构

* <https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&&tqId=29370&rp=1&ru=/activity/oj&qru=/ta/2016test/question-ranking>
* 思路1：快慢指针找到中间结点rhead后将rhead后面的部分逆置。奖后将head和rhead都看作慢指针，每次走一步并且比较，若有不同则返回false。奇数次和偶数次的情况可以统一为一种情况，奇数次时会形成环
* 思路2：直接新建一个翻转的新链表，然后两个指针同时走比较
* 思路3：二叉树后序遍历？

# 数组

## *双指针*

### 典型：O(1)原地移除元素

* [27. 移除元素](https://leetcode.cn/problems/remove-element/) 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。

* 思路：双指针

  <img src="27原地删除元素.gif" width="50%">

### 其他题目

* [26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)
* [283. 移动零](https://leetcode.cn/problems/move-zeroes/)
* [977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)

### 合并两个有序数组

* [88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/) 给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示 nums1和nums2中的元素数目。请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。
* 思路：因为是非递减的数组，所以三指针从后往前排

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int dest = m-1, src = n-1, dest_end = m+n-1;
    while (src>=0 && dest>=0)
    {
        if (nums2[src] >= nums1[dest])
            nums1[dest_end--] = nums2[src--];
        else
            nums1[dest_end--] = nums1[dest--]; 
    }
    while (src>=0)
        nums1[dest_end--] = nums2[src--]; 
}
```

### 汇总区间

* 题目：[228. 汇总区间](https://leetcode.cn/problems/summary-ranges/)
* 思路：快慢指针

```cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int stay = 0, move = 1;
        int n = nums.size();
        vector<string> ret {};
        while (move <= n - 1) {
            if (nums[move] == nums[move - 1] + 1) {
                move++;
            }
            else {
                if (stay == move - 1) {
                    ret.push_back(std::to_string(nums[stay])); // only one element
                }
                else {
                    ret.push_back(std::to_string(nums[stay]) + "->" + std::to_string(nums[move - 1]));
                }
                stay = move++;
            }
        }
        // last range
        if (n > 0) {
            if (stay == n - 1) {
                ret.push_back(std::to_string(nums[stay])); // only one element
            }
            else {
                ret.push_back(std::to_string(nums[stay]) + "->" + std::to_string(nums[n - 1]));
            }
        }
        return ret;
    }
};
```

## *前缀和*

前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和

## *差分数组*

查分数组主要适用的场景是频繁对原始数组的某个区间的元素进行增减

## *二维数组的遍历*

### 顺/逆时针旋转矩阵

### 螺旋遍历

* [59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)

螺旋遍历没有什么高级的技巧，就是按照顺序遍历即可。难点在于边界控制

核心是要将遍历统一为左闭右开方便上下左右的四趟遍历，其实就是要分成奇偶数两种情况

<img src="螺旋矩阵遍历.drawio.png">

## *字符串*

### 字符串最后一个单词的长度

* <https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&&tqId=21224&rp=5&ru=/activity/oj&qru=/ta/huawei/question-ranking>
* 思路：调用string::rfind找到最后一个空格后再用strlen

```cpp
int main() {
    string str;
    getline(cin, str); 
    size_t pos = str.rfind(' ');
    if (pos != string::npos)
    {
        cout << str.size() - pos - 1 << endl;
    }
    else
    {
        // 只有一个单词
        cout << str.size() << endl; 
    }
}
```

### 字符串中的第一个唯一字符

* <https://leetcode.cn/problems/first-unique-character-in-a-string/>
* 思路：计数排序

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        int countArr[26] = {0};
        for (auto ch:s)
        {
            countArr[ch-'a']++;
        }
        for (size_t i=0; i<s.size(); i++)
        {
            if (countArr[s[i]-'a'] == 1)
                return i;
        }
        return -1;
    }
};
```

### 字符串转整型数字

* <https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&&tqId=11202&rp=6&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 思路：从头遍历
```cpp
long long StrToInt(string str)
{
    long long sum = 0;
    int i = 0;
    int flag = 1; // 记录正负数
    int end = str.size(); // 不算\0
    while (i < end)
    {
        if ((str[i] > '0' && str[i] < '9') || (str[i] == '+' || str[i] == '-'))
        {
            if (i == 0 && (str[0] == '+' || str[0] == '-')) // 处理 +- 号
                str[0] == '+' ? flag : flag *= -1; // 若是-号，就将flag置为-1
            else
                sum = sum * 10 + (str[i] - '0');
            i++;
        }
        else
            return 0;
    }
    return flag * sum;
}
```

### 字符串相加--实现大整数加法

* <https://leetcode.cn/problems/add-strings/>
* 思路：从后往前将每一个转换为数字后进行加法，用next来保留进位。将加法得到的结果转换回string然后进行尾插。注意：string和vector一样因为效率原因不提供尾插，尾插的方法是直接+=，最后reverse

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        int end1 = num1.size() - 1, end2 = num2.size() - 1;
        int next = 0; // 保存进位
        string strRet; // 保存返回的string
        while (end1 >= 0 || end2 >= 0) // 两个都走完才结束
        {
            int val1 = end1 >= 0 ? num1[end1] - '0' : 0; // 若有一个加数走完了，那么就将他相应位看作0
            int val2 = end2 >= 0 ? num2[end2] - '0' : 0;
            int ret = val1 + val2 + next;
            next = ret > 9 ? 1 : 0;
            // // string 不支持 push_front，因为string和vector一样头插要挪动数据，效率很低。要使用insert
            // strRet.insert(0, 1, (ret % 10) + '0'); // strRet.insert(strRet.begin(), (ret % 10) + '0') 用迭代器
            --end1;
            --end2;
            // 尾插就是直接+=后最后统一reverse一下就可以了
            strRet += ('0' + ret%10);
        }
        // 类似于'1' + '9'这种情况下，还有1个进位
        if (next == 1)
            strRet += '1';
        reverse(strRet.begin(), strRet.end());
        // // 类似于'1' + '9'这种情况下，还有1个进位
        // if (next)
        //     strRet.insert(strRet.begin(), '1');
        return strRet;
    }
};
```

### 字符串相乘

### 反转字符串

* <https://leetcode.cn/problems/reverse-string/>
* 思路：头尾双迭代器

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        vector<char>::iterator begin = s.begin();
        vector<char>::iterator end = s.end() - 1;
        while (begin <= end) // 别用 !=，会有奇偶性问题
        {
            std::swap(*begin, *end);
            begin++;
            end--;
        }
    } 
};
```

### 仅仅反转字母

* <https://leetcode.cn/problems/reverse-only-letters/>
* 思路：双指针，若判断为字母就swap

```cpp
class Solution {
public:
    bool IsLetter(char ch)
    {
        if ((ch >= 'a' && ch <= 'z')
        || (ch >= 'A' && ch <= 'Z'))
            return true;
        else
            return false;
    }
    string reverseOnlyLetters(string s) {
        size_t begin = 0, end = s.size()-1;
        while (begin < end)
        {
            while (begin < end && !IsLetter(s[begin]))
                begin++;
            while(begin < end && !IsLetter(s[end]) )
                end--;
            std::swap(s[begin++], s[end--]);
        }
        return s;
    }
};
```

### 翻转字符串

### 区间部分翻转

### 反转字符串中的单词

### 验证回文字符串

## *滑动窗口*

### 典型例题 & 框架

* [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)

* 题目：

  给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。*

  找出该数组中满足其总和大于等于 `target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 

<img src="数组的滑动窗口.gif" width="40%">

滑动窗口的框架是一个 for/while + while，第一层循环控制的是终止位置，如何移动起始位置是滑动窗口的核心所在

```pseudocode
int right = 0; // 窗口的终止位置
int left = 0;  // 窗口的起始位置
while (控制right) {
	windows.add();
	right++;
    while (控制left) {
    	windows.remove();
    	left++;
    }
}
```

这个算法的复杂度仍然是 ***O(2N)***，因为所有元素最多就过两遍。相当于是两层for循环的剪枝

TODO：有负数咋办？

### 字符串问题

处理字符串问题要进行一些字符串的操作

### Rabin-Karp字符匹配算法

## *数组/顺序表*



### 杨辉三角

* <https://leetcode.cn/problems/pascals-triangle/>

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> vv;
        vv.resize(numRows); // resize初始化每一行
        // 每一行的首尾元素赋为1
        for (size_t i=0; i<vv.size(); i++)
        {
            vv[i].resize(i+1, 0);
            vv[i].front() = vv[i].back() = 1;
        }

        for (size_t i=0; i<vv.size(); i++)
        {
            for (size_t j=0; j<vv[i].size(); j++)
                if (!vv[i][j])
                    vv[i][j] = vv[i-1][j] + vv[i-1][j-1];
        }
        return vv;
    }
};
```

### 电话号码的字母组合

* <https://leetcode.cn/problems/letter-combinations-of-a-phone-number/>
* 思路：排列组合多路递归，深度优先遍历。

<img src="电话号码的字母组合.png">

```cpp
class Solution {
    const char* numToStr[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    //string numToStr[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
public:
    void combine(string digits, int di, vector<string>& retV, string combineStr)
    { // digits为选中的数字，di为其下标，retV存放返回的可能组合，combineStr
        // 取数字字符映射的字符串
        if (di == digits.size())
        {
            retV.push_back(combineStr);
            return;
        }
        int num = digits[di] - '0';
        string str = numToStr[num];
        for (auto ch : str)
            combine(digits, di+1, retV, combineStr+ch);
            // 这里注意不要写成combineStr+=ch了，因为处于for循环中，combineStr需要重复使用
    }
    vector<string> letterCombinations(string digits) {
        vector<string> v;
        if (digits.empty())
            return v;
        string str;
        combine(digits, 0, v, str);
        return v;
    }
};
```

# 栈和队列

### 括号匹配问题

* <https://leetcode.cn/problems/valid-parentheses/>
* 思路：左括号入栈，若不是左括号则进行匹配，若匹配则将此时的栈顶元素pop掉，若不匹配则返回false。知道全部元素判断完

    ```cpp
    class Solution {
    public:
        bool isValid(string s) {
            stack<char> st;
            int i = 0;
            while(s[i])
            {
                if (s[i] =='(' || s[i] == '[' || s[i] == '{') 
                {
                    st.push(s[i]); // 任意一种左括号就入栈
                    i++;
                }
                else
                {
                    if (st.empty()) // 处理只有 ']' 时错误地st.top()
                        return false;
                    if((st.top() == '(' && s[i] == ')') // 若栈顶和当前括号匹配时将栈顶Pop
                    || (st.top() == '[' && s[i] == ']')
                    || (st.top() == '{' && s[i] == '}'))
                    {
                        i++;
                        st.pop();
                    }
                    else
                        return false;
                }
            }
            if (!st.empty()) // 处理只有 '(' 的情况
                return false;
            return true;
        }
    };
    ```

* 改进：若队列中不仅仅包含括号，还有其他字符怎么办？多添加一个 else if 判断就可以

    ```cpp
    if (st.empty())
        return false;
    if ((st.top() == '(' && A[i] == ')')
        || (st.top() == '[' && A[i] == ']')
        || (st.top() == '{' && A[i] == '}'))
    {
        st.pop();
        i++;
    }
    else if (A[i] != ')' || A[i] != ']' || A[i] != '}') // 若不是右括号，则直接++
        i++;
    else
        return false;
    ```

### 用队列实现栈

* <https://leetcode.cn/problems/implement-stack-using-queues/>
* 思路：给两个FIFO的队列，保持一个队列存储数据，一个队列空着，空着的队列是为了将另一个队列的数据导过来

    <img src="用队列来实现栈.png" width="80%">

### 用栈实现队列

* <https://leetcode-cn.com/problems/implement-queue-using-stacks/>
* 思路：和用队列实现栈的思路一样，用两个LIFO的栈来回倒数据

    <img src="用栈来实现队列.png" width="80%">

### 设计循环队列/环形缓冲器

* 解决的问题是当位子有限时的排队，比如限定了人数的商店，只有当一个人出去了另一个人才能进来。OS中的生产者消费者模型
* <https://leetcode.cn/problems/design-circular-queue/>
* 思路：
  * 因为有可能是因为push满了也有可能是pop空了，此时都是 front == rear，无法判断到底是满了还是空了
  * 可以考虑多记录一个size
  * 也可以考虑多开一个空间不存储数据，当 rear + 1 == front 是就是满了，若 front == rear 就是空
  * 因为用单链表实现比较难取尾，所以用数组来实现
  * 要处理当tail或head在边界时的特殊情况

为了更方柏的取队尾数据，采用数组来实现

### 最小栈：要求时间复杂度为O(1)

* <https://leetcode.cn/problems/min-stack/>
* 思路：构造一个辅助栈minst存储最小值，当st中有小于等于minst堆顶数据的时候minst才插入

    <img src="最小栈.png">

```cpp
class MinStack {
public:
    MinStack() {
    // 不用处理，空的构造函数等价于默认构造函数，因为会自动调用初始化列表（实际上初始化的地方）进行默认的初始化
    // 因为类成员都是 stack<int> 这种有默认构造的内置数据类型，所以给一个默认构造也没事
    }
    void push(int val) {
        _st.push(val);
        if (_minst.empty() || val <= _minst.top())
            _minst.push(val);
    }
    void pop() {
        if (_minst.top() == _st.top()) // 若是和_st.top()相同的数据就删除_minst.top()
            _minst.pop();
        _st.pop();
    }
    int top() {
        return _st.top();
    }
    int getMin() {
        return _minst.top();
    }
private:
    stack<int> _st;
    stack<int> _minst;
};
```

* 进一步扩展：若待入栈的数据是大量重复数据该怎么办？比如插入10w个1。将minst中的数据类型改成一个struct或class，加一个计数器类成员。若是相同的数据则只要更新计数器就行

### 栈的弹出压入序列

* <https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 思路：用一个辅助栈来模拟push和pop的过程。若当前push的值不等于要pop的值就持续入；若和pop序列匹配就持续出。若辅助栈的值能pop完就为真否则为假

<img src="栈的弹出压入序列.png" width="70%">

```cpp
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        stack<int> st;
        int popi = 0;

        for (auto pushVal : pushV)
        {
            st.push(pushVal);
            // 出栈序列匹配后要持续比较，可能会有多个匹配
            while (!st.empty() && popV[popi] == st.top())
            {
                popi++;
                st.pop();
            }
        }
        return st.empty(); // return popi == popV.size();
    }
};
```

### 逆波兰表达式求值

* <https://leetcode.cn/problems/evaluate-reverse-polish-notation/>
* 波兰表达式 Polish notation 也称前缀表达式。在计算机中人类习惯的中缀表达式是无法进行有效计算的，必须转换成前缀或后缀表达式队列后，利用出栈和入栈再进行运算
  * 前缀表达法
  * 中缀表达式 `1 + 2 * 3`
  * 后缀表达式 `1 2 3 * +`：操作数的顺序不变，把运算符优先级按照顺序排列
* 思路
  * 给一个辅助栈，只入操作数，不入操作符
  * 遇到操作数就入栈，遇到运算符就就取栈顶的连续两个数据运算，运算结果继续入栈
  * 若序列走完了，最后辅助栈里栈顶元素就是结果

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> st;
        for (auto& str : tokens)
        {
            if (str == "+" || str == "-" || str == "*" || str == "/") // 若是操作符就要进行运算
            // 用的是一个string来进行比较，不会混淆负号和负数
            {
                long long right = st.top();
                st.pop();
                long long left = st.top();
                st.pop();
                switch(str[0]) // switch 是不支持string的，但str[0]是一个char
                {
                    case '+':
                        st.push(left + right);
                        break;
                    case '-':
                        st.push(left - right);
                        break;
                    case '*':
                        st.push(left * right);
                        break;
                    case '/':
                        st.push(left / right);
                        break;
                }
            }
            else // 若是操作数就进行入栈，将string转换为int
                st.push(stoi(str)); 
        }
        return st.top();
    }
};
```

### 基本运算器

* <https://leetcode.cn/problems/basic-calculator/>
* 包含了两个基本步骤：先要将输入的中缀表达式转换为后缀表达式，然后再利用后缀表达式求值
  * 中缀转后缀
    * 操作数输出到存储序列中，操作符入辅助栈
    * 栈为空，或者若操作符比当前栈顶的操作符优先级高则当前操作符入栈；若低于或等于栈顶操作符，则栈顶元素出栈放到存储序列中，然后当前操作符入栈（注意，若栈中有多个运算符，就要进行连续比较）。这是因为要控制栈顶的优先级高
    * 序列走完了，若辅助栈里还有操作符则依次输出到存储序列中
  * 若有括号，则设置一个flag，将 flag = 1，则将运算符优先级升到最高

### 数组中第k个大的元素

* <https://leetcode.cn/problems/kth-largest-element-in-an-array/>
* 思路：优先级队列建大堆，将前k-1个pop掉后，堆顶的就是第k个最大元素

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // 建大堆 -- O(N)
        priority_queue<int> maxHeap(nums.begin(), nums.end());
        while (--k) // 将前k-1个pop掉后，堆顶的就是第k个最大元素
            maxHeap.pop(); // O(logN * k)
        return maxHeap.top();
    }
};
```

# 二分查找

二分查找的复杂度是***O(logN)***

## *框架*

### 使用二分查找的前提

1. 有序数组，不论是排升序还是排降序
2. 返回一个索引

### 无重复值

[704. 二分查找](https://leetcode.cn/problems/binary-search/)

二分查找最重要的就是边界控制，而边界控制是要根据区间定义来的。二分查找根据区间定义的不同有两种写法

* 左闭右闭 `[left, right]`

  ```c++
  int binarySearch(vector<int>& nums, int target) {
      int left = 0;
      int right = nums.size() - 1;
      
      while (left <= right) {
          int mid = left + (right - left)/2; // int mid = (left + right) / 2;
          if (nums[mid] == target) {
              return mid;
          }
          else if (nums[mid] < target) { // 提高下界
              left = mid + 1;
          }
          else if (nums[mid] > target) { // 缩小上界
              right = mid - 1;
          }
      }
      return -1;
  }
  ```

  * 为什么要写成 `left + (right - left)/2`？这种表达和 `(left + right)/2` 是一样的效果，但是前者可以抵抗大整数相加溢出

  * 为什么while判断条件用了 `left <= right`？因为将right初始化为 `nums.size()-1`，而不是 `num.size()`，这相当于是左闭右闭的写法。所以当 `left == right` 的时候是有意义的，此时会做最后一次搜索，此时的搜索空间就是 `[left, left]`

  * 为什么迭代操作是 `left = mid + 1` 和 `right = mid - 1`？因为我们已经计算确定了 `nums[mid]` 不等于 target，可以直接把当前的mid排除在外了，所以因为区间定义是左闭右闭，所以把当前mid排除

  * 关于数组是奇数还是偶数的问题：奇数时 `/2` 可以整除，偶数时则要向下取整。但两种情况下边界都是 `+1`、`-1`，所以边界在不断缩小，适用于两种情况，可以手推一下下面两个例子

    ```
    奇数：0 3 5 7 9     target = 7
    偶数：0 3 5 7 9 11  target = 9
    ```

  * 全部用了else if没有用else的原因是这样可以有效的帮助我们理清楚三种情况

* 左开右开 `[left, right)`

  ```c++
  int binarySearch(vector<int>& nums, int target) {
      int left = 0;
      int right = nums.size();
      
      while (left < right) {
          int mid = left + (right - left)/2; // int mid = (left + right) / 2;
          if (nums[mid] == target) {
              return mid;
          }
          else if (nums[mid] < target) { // 提高下界
              left = mid + 1;
          }
          else if (nums[mid] > target) { // 缩小上界
              right = mid;
          }
      }
      return -1;
  }
  ```

  * while判断改为 `left < right`，因为这时候 `left==right` 没有意义
  * 区间迭代的时候是 `left=mid + 1` 和 `right=mid`，同样的因为我们已经计算确定了 `nums[mid]` 不等于 target，可以直接把当前的mid排除在外了，所以因为区间定义是左闭右开，所以把当前mid排除的方式就是直接让 `right=mid`。注意 ⚠️：`left=mid+1` 仍然是这样

### 有重复值：找左侧边界

### 无重复值：找右侧边界

## *二分查找题目*

## *扩展题目*

### 搜索二维矩阵

* 题目：[搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

### 搜索二维矩阵II

* 题目：[搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

## *二分查找变体*

# 二叉树

# nSum问题

# 进阶数据结构

## *纲领*

二叉树解题的总体思路可以分为两种

* 遍历思路 -- 回溯算法：**是否可以通过遍历一遍二叉树来得到答案？**若可以的话，就用一个 `traverse` 函数配合外部变量来实现
* 分解问题思路 -- 动态规划算法：**是否可以定义一个递归函数，通过子问题（子树）的答案推导出原问题的答案？**若是的话就写出递归函数，并充分利用这个函数的返回值

两种方式都要思考的问题是若单独抽出一个二叉树节点，需要对它做什么事？需要在什么时候做，即是在前序、中序还是后序？

下面是几道例题来体会这两种思路

### 例题：翻转二叉树

[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

* 遍历

  ```cpp
  TreeNode* invertTree(TreeNode* root) {
      traverse(root);
      return root;
  }
  
  void traverse(TreeNode* root) {
      if (!root) return;
      // 前序
      std::swap(root->left, root->right);
      traverse(root->left);
      traverse(root->right);
  }
  ```

* 分解

  ```cpp
  TreeNode* invertTree(TreeNode* root) {
      if (!root) return nullptr;
  
      TreeNode* left = invertTree(root->left);
      TreeNode* right = invertTree(root->right); 
      // 后序
      root->left = right;
      root->right = left;
  
      return root;
  }
  ```

### 例题：填充节点的右侧指针

[116. 填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

### 例题：二叉树展开为链表

[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

这个题目用分解成子问题的思路来做很方便，只要左子树和右子树分别拉平，自底向上就可以将整棵树拉平

这道题要注意的一个点是当把右子树接到原来的左子树上的时候要对左子树找尾，此时候应该要从root开始找，可以把左子树为空的情况囊括进去

<img src="二叉树展开为链表.drawio.png" width="70%">

## *二叉树的遍历 DFS*

### <span id="二叉树的遍历">二叉树的遍历框架</span>

二叉树遍历最常用、最典型的就是非线性的递归遍历，而且这种遍历是一种DFS

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
void traverse(TreeNode* root) {
    if (root == nullptr) return; // base case
    // 前序位置
    traverse(root->left);
    // 中序位置
    traverse(root->right);
    // 后序位置
}
```

二叉树可以扩展为多叉树，多叉树又可以进一步扩展为[图的DFS遍历](#图的遍历)

```cpp
/* 基本的 N 叉树节点 */
class TreeNode {
public:
    int val;
    vector<TreeNode*> children;
};

void traverse(TreeNode* root) {
    if (root == nullptr) return; // base case
    // 前序位置
    for (TreeNode* child : root->children)
        traverse(child);
    // 后序位置
}
```

关于二叉树的前中后序遍历的递归、非递归实现以及层序遍历等实现以及OJ题可以查看*数据结构与算法.md*的二叉树部分

<span id="链表和数组的前序和后序遍历">我们可以借此generalize前序和后序遍历到其他的数据结构</span>，如下图所示**前序位置，就是刚进入一个节点（元素）的时候**，而**后序位置就是即将离开一个节点（元素）的时候**。所以代码在前序和后序的不同位置执行的时机也不同

<img src="链表和数组的前序和后序遍历.drawio.png" width="80%">

一道典型的例题就是[1265. 逆序打印不可变链表](https://leetcode.cn/problems/print-immutable-linked-list-in-reverse/)

### 二叉树高度问题

* 求最大深度

  * [104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

  * 利用max递归求子树的最大深度

    ```cpp
    int maxDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        int leftDep = maxDepth(root->left);
        int rightDep = maxDepth(root->right);
    
        return max(leftDep, rightDep) + 1;
    }
    ```

* 求最小深度

  * <https://leetcode.cn/problems/minimum-depth-of-binary-tree/>

  * 思路1：和求最大深度相反用min，但要注意的是当有一个分支为空时，这个分支不能被计算在内，而是将有效子树的高度+1

    ```cpp
    int minDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        int leftHT = minDepth(root->left);
        int rightHT = minDepth(root->right);
        if (root->left && root->right) // 当有一颗子树为空时，这个分支不被计算在内
            return min(leftHT, rightHT) + 1;
        else
            return max(leftHT, rightHT) + 1;
    }
    ```

  * 思路2：BFS，当有一节个结点的左右子树都为0时，就输出当前的层数

    ```cpp
    int minDepth(TreeNode* root) {
        int depth = 0, levelSize;
        queue<TreeNode*> q;
        if (root) {
            q.push(root);
            levelSize = 1;
        }
        while (!q.empty()) {
            depth++;
            for (int i = 0; i < levelSize; i++) {
                TreeNode* front = q.front();
                if (!front->left && !front->right)
                    return depth;
                if (front->left)
                    q.push(front->left);
                if (front->right)
                    q.push(front->right);
                q.pop();
            }
            levelSize = q.size();
        }
        return depth;
    }
    ```

* 判断平衡二叉树

  * <https://leetcode.cn/problems/balanced-binary-tree/>

  * 思路：借助子树的高度差来递归判断每一棵子树是否是平衡树

    ```cpp
    int Height(TreeNode* root)
    {
        if (root == nullptr)
            return 0;
        int leftHT = Height(root->left);
        int rightHT = Height(root->right);
        return max(leftHT, rightHT) + 1;
    }
    
    bool isBalanced(TreeNode* root) {
        if (root == nullptr)
            return true;
        int leftHT = Height(root->left);
        int rightHT = Height(root->right);
        int diff = leftHT - rightHT;
        
        return abs(diff) < 2
            && isBalanced(root->left)
            && isBalanced(root->right);
    }
    ```

## *后序遍历的妙用*

### 后序遍历的特殊性

### 二叉树的直径

### 寻找重复的子树

## *层序遍历 BFS*

### 框架

<img src="Level_order_traversal.drawio.png"  width="40%">

核心就是利用FIFO的队列。[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```cpp
void levelTraverse(TreeNode* root) {
    queue<TreeNode*> q;
    if (root) q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        for (int i = 0; i < levelSize; i++) {
            TreeNode* top = q.front();
            // 对队首元素的操作
            if (top->left) q.push(top->left);
            if (top->right) q.push(top->right);
            q.pop();
        }
    }
}
```

### 层序遍历的题目

* [429. N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)：二叉树层序遍历扩展到N叉树
* [107. 二叉树的层序遍历 II](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)：102得到的res里的元素用reverse函数反转一下
* [637. 二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

## *二叉树的构造类问题*

### 单值二叉树

* <https://leetcode.cn/problems/univalued-binary-tree/>
* 思路：中序遍历

```cpp
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        if (root == NULL) // 前序
            return true;
        if (root->left && root->left->val != root->val)
            return false;
        if (root->right && root->right->val != root->val)
            return false;
        return isUnivalTree(root->left) && isUnivalTree(root->right);
    }
};
```

### 检查两颗树是否相同

### 对称二叉树



### 另一颗树的子树

### 判断二叉树是否是完全二叉树

### 删除二叉搜索树中的节点

* <https://leetcode.cn/problems/delete-node-in-a-bst/>
* 思路：参考BST的Insert实现，可以考虑循环和递归两种写法

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        // 找要删除的节点
        TreeNode* prev = nullptr;
        TreeNode* curr = root;
        while (curr)
        {
            if (curr->val > key) // 向左走
            {
                prev = curr;
                curr = curr->left;
            }

            else if (curr->val < key) // 向右走
            {
                prev = curr;
                curr = curr->right;
            }
            else// 找到了
            { // 找到了要考虑3种情况
                if (!curr->left) // curr的左子树为空
                { // 要考虑curr可能是prev的左子树，也可能是右子树
                    if (curr == root) // 当删除的是root的时候要特殊处理
                        root = curr->right;
                    else
                    {
                        if (curr == prev->left) // curr是prev的左子树
                            prev->left = curr->right;
                        else // curr是prev的右子树
                            prev->right = curr->right;
                    }
                    delete curr;
                    curr = nullptr;
                }
                
                else if (!curr->right) // curr的右子树为空
                { // 要考虑curr可能是prev的左子树，也可能是右子树
                    if (curr == root) // 当删除的是root的时候要特殊处理
                        root = curr->left;
                    else
                    {
                        if (curr == prev->left)
                            prev->left = curr->left;
                        else
                            prev->right = curr->left;
                    }
                    delete curr;
                    curr = nullptr;
                }
                else// curr的左右子树都不为空
                { // 采用替代删除--找右边最小左节点，然后替换val
                    TreeNode* minRPrev = curr; // 若minR还有一个右节点改咋办？要先“托孤”，且为了兼容删除root的情况，要让minRPrev=curr，而不是nullptr
                    TreeNode* minR = curr->right;
                    while (minR->left)// 找到最右边的最小节点
                    {
                        minRPrev = minR;
                        minR = minR->left;
                    }
                    swap(curr->val, minR->val);

                    // 考虑极端情况，若curr就是_root，此时minParent会出现空指针的情况
                    // 并且若一步都没有走的话，minR不一定是minParent的左节点，需要进行判断
                    if (minRPrev->left == minR)
                        minRPrev->left = minR->right;
                    else
                        minRPrev->right = minR->right;
                    delete minR;
                }
            }
        }
        return root; // 没找到
    }
};
```

### 二叉树创建字符串

* <https://leetcode.cn/problems/construct-string-from-binary-tree/>
* 用C语言来写，可以用strcat，strcat需要自己开空间，问题是要开多大，很麻烦
* 思路：左右都为空则省略掉相应括号；左子树不为空，右子树为空，则省略掉；左子树为空，右子树不为空，则不省略

```cpp
class Solution {
public:
    string tree2str(TreeNode* root) { // 传值传参效率问题，接口型的OJ不能改接口，要再写一个子函数
        if (root == nullptr)
            return string();
        string str;
        str += to_string(root->val);
        if (root->left || root->right) //左右都为空，就省略；左边为空，右边不为空不省略
        {
            str += '(';
            str += tree2str(root->left);
            str += ')';
        }

        if (root->right) // 右边为空就省略
        {
            str += '(';
            str += tree2str(root->right);
            str += ')';
        }
        return str;
    }
};
```

### 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

* <https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>
* 思路1：找到规律 -- ***O(h\*N)***
  
  <img src="指定节点的最近公共祖先--思路1.png">
  
  * 若都在左子树中，就往左走；若都在右子树中，就往右走
  * 若其中一个是父节点，那么它自己本身就是最近公共祖先
  * 一个是左子树中的节点，一个是右子树中的节点，那么该节点就是最近公共祖先
  
    ```cpp
    class Solution { // 总的时间复杂的为O(h*N) h为二叉树高度
    public: 
        bool Find(TreeNode* sub, TreeNode* x) //在子树中找节点, O(N)
        {
            if (sub == nullptr)
                return false;
            return sub == x
                || Find(sub->left, x)
                || Find(sub->right, x); //中序
        }
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            if (root == nullptr)
                return nullptr; 
            if (root == p || root == q)
                return root;
            bool pInLeft, pInRight, qInLeft, qInRight; 
            pInLeft = Find(root->left, p); // 去当前节点的左子树里找p，若没找到就是在右子树里
            pInRight = !pInLeft;
            qInLeft = Find(root->left, q);
            qInRight = !qInLeft;
            // 1. 一个在左一个在右，root就是最近公共祖先
            if ((pInLeft && qInRight) || (pInRight && qInLeft))
                return root;
            // 2. 都在左，递归去左子树找；都在右，递归去右子树找
            else if (pInLeft && qInLeft)
                return lowestCommonAncestor(root->left, p, q);
            else if (pInRight && qInRight)
                return lowestCommonAncestor(root->right, p, q);
            else //这道题不会走到这里
                return nullptr;
        }
    };
    ```
  
* 思路2：借助队列和三叉链（节点带parent），转换为链表相交问题 -- 优化到 ***O(N)***
  
  <img src="指定节点的最近公共祖先--思路2.png">
  
  ```cpp
  class Solution {
  public:
      bool FindPath(TreeNode* root, TreeNode* x, stack<TreeNode*>& path)
      {
          if (!root)
              return false;
          path.push(root);
          if(x == root)
              return true;
          if (FindPath(root->left, x, path) || FindPath(root->right, x, path)) // 只要有一个找到了就会进入
              return true;
          else // 两个子节点都没有找到或者都是空就要pop掉当前的节点
          {
              path.pop();
              return false;   
          }
      }
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          stack<TreeNode*> pPath, qPath;
          FindPath(root, p, pPath);
          FindPath(root, q, qPath);
          // 链表相交的思路3
          int diff = pPath.size() - qPath.size();
          stack<TreeNode*> *longer = &pPath;
          if (diff < 0)
              longer = &qPath;
          for (int i=0; i<abs(diff); i++)
              longer->pop();
          int len = pPath.size();
          for(int i=0; i<len; i++)
          {
              if (pPath.top() == qPath.top())
                  return pPath.top();
              else
              {
                  pPath.pop();
                  qPath.pop();
              }
          }
          return nullptr; // 这道题不会走到这一步
      }
  };
  ```
  
* 题目里已经说明了给出的节点一定在树里能找到；若不一定在树里，那么需要迭代更多
* 若换成搜索二叉树，那么就不需要find函数了，直接利用搜索二叉树进行优化

### 二叉树搜索树转换成排序双向链表

* <https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。也就是要在原来的搜索二叉树上进行改动，不能创建一个新的vector
* 思路1：和二叉树线索化（线索化在实际中没有价值）一样，令left指向中序顺序的前一个，令right指向中序顺序的后一个。用2次递归
* 思路2：

### 根据一棵树的前序遍历与中序遍历构造二叉树

* <https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>
* 必须是前序和中序或者中序和后序的序列和无重复值才能重建二叉树，若是前序和后序则不能。也就是必须要有中序，前序和后序确定树的根，而中序分割树
* 思路：前序创建树，中序分割左右子树

    ```cpp
    class Solution {
    public:
        TreeNode* _buildTree(vector<int>& preorder, vector<int>& inorder, int& pre_i, int inBegin, int inEnd)
        {
            if (inBegin > inEnd)
                return nullptr;
            TreeNode* root = new TreeNode(preorder[pre_i++]);
            // 分割中序
            int in_i = inBegin;
            while (in_i <= inEnd)
            {
                if (inorder[in_i] == root->val) // 找到根节点，因为无重复的val，所以可以这么找
                    break;
                else
                    in_i++;
            }
            // [inBegin, in_i-1] in_i [in_i+1, inEnd] 进行前序创建
            root->left = _buildTree(preorder, inorder, pre_i, inBegin, in_i-1);
            root->right = _buildTree(preorder, inorder, pre_i, in_i+1, inEnd);
            return root;
        }
        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
            int pre_i = 0;
            return _buildTree(preorder, inorder, pre_i, 0, inorder.size()-1);
        }
    };
    ```

* 根据一棵树的中序遍历与后序遍历构造二叉树：用中序和后序重建二叉树的时候的注意点在于先构建右子树，再构建左子树，因为后序的遍历顺序为左、右、root

    ```cpp
    TreeNode* _buildTree(vector<int>& inorder, vector<int>& postorder, int& post_i, int inBegin, int inEnd)
    {
        // ... 相同 进行后序创建
        root->right = _buildTree(inorder, postorder, post_i, in_i+1, inEnd); 
        root->left = _buildTree(inorder, postorder, post_i, inBegin, in_i-1);
        return root;
    }
    ```

## *BST*

### BST的重要性质

BST的详细情况可以看*数据结构与算法.md*，这里只给出最重要的几个性质

* 若它的左子树不为空，则左子树上所有节点的值都小于根节点的值
* 若它的右子树不为空，则右子树上所有节点的值都大于根节点的值
* 它的左右子树也都必须为BST

但是对于做算法题而言，BST最重要的一个隐藏性质是：**对BST的中序遍历结果是有序的（升序）**

### 利用中序遍历有序的性质

### BST基操

### BST的构造

# 图

## *图的遍历*

### 图的两种逻辑结构

* 邻接矩阵：`vector<vector<int>> matrix;`
* 邻接表：OJ做题时常用 `unordered_map` 来实现：**`unodered_map<V, vector<pair<V, W>>`**，其中作为key的V是源节点，后面的Value `vector` 是邻接表结构，pair中的V是目标节点，W则是权重

要表示无向图时候其实就是把原本相反方向的路径的值设成一样的就行了，也就是 `matrix[i][j] = matrix[j][i]`（假设这两个元素是连通的）

### 遍历

图的遍历就是从二叉树遍历扩展开来的[多叉树的DFS](#二叉树的遍历)

同时我们也知道图就是可能带环的树，所以说我们需要一个 `visited` 数组来帮我们记录哪些节点是已经访问过了，防止重复访问造成死循环

而 `onPath` 数组并不是必须的，我们可以用它来判断是否成环，比如用于路径依赖问题

### 名流问题

## *环检测及拓扑排序算法*

### 环检测 & 路径依赖问题

看到路径依赖问题，首先应该将其转换为有向图的逻辑结构，只要有向图中有环，就说明肯定存在路径依赖

笔者用[Leetcode 207. 课程表](https://leetcode.cn/problems/course-schedule/)这个典型的路径依赖问题来说明

### 拓扑排序

拓扑排序 topological sorting

笔者用[Leetcode 210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)个典型的拓扑排序问题来说明

### 课程表问题扩展

* [Leetcode 207. 课程表](https://leetcode.cn/problems/course-schedule/)进一步返回图中哪些节点是成环的？
* 课程表III
  * 题目：[Leetcode 630. 课程表 III](https://leetcode.cn/problems/course-schedule-iii/)
  * 思路
    * DFS
    * BFS
* 课程表IV
  * 题目：[Leetcode 1462. 课程表 IV](https://leetcode.cn/problems/course-schedule-iv/)
  * 思路
    * Floyd

## *二分图判定*

# set & map

哈希表最擅长做的就是给一个元素，看这个元素是否在表中出现过

* 数组：用下标做索引，如果元素的范围很大或者很分散的话，用数组就不合适，因为要开很大的空间，浪费空间
* set：避免重复的情况
* map

## *nSum*

### 一场意外：排序的twoSum

这道题严格意义上并不属于 nSum 问题，因为它用双指针就能解决

* 题目：[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)。从一个已经排升序的数组之中找出满足相加之和等于目标数 `target` 的两个数，以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`

* 思路：左右指针，因为已经排成升序了，所以如果当前两个边界的值大于 `target` 就缩小右边界，若小于 `target` 就放大左边界


### Base case：未排序的twoSum

<https://juejin.cn/post/7058682340515512333>

* 题目：[1. 两数之和](https://leetcode.cn/problems/two-sum/)。这道题目虽然标的是简单，但实际上比前面排序好的base case要麻烦，很有理由怀疑是两道题目的难易程度搞混了
* 思路
  * 和base case的区别是没有排序，所以我们首先要排序。但是用 `sort()` 排序是对原来的vector直接操作的，那么排完序之后就不能取到原来的序号了。所以笔者原来的思路是用unordered_map来保存 `<num, 对应的原下标>` 这种对应关系，但是因为题目里是有重复的key的，所以不能够用unordered_map
  * 如果考虑用multi_map的话虽然可以存下冗余的key，但是之后在通过num来找原下标的时候，会遇到对于同样的key到底是返回哪个序号的问题
  * 最后使用的是 `vector<pair<int, int>>` 的数据结构，它支持左右指针的随机访问，也可以把原来的下标给保存起来

### Generalization

现在泛化twoSum：`nums` 中**可能有多对**元素之和都等于 `target`，请你的算法返回**所有**和为 `target` 的元素对，其中**不能出现重复**

<img src="twoSum有重复.drawio.png">

适应这种情况的方式是左右指针如果遇到了重复的就继续移动，复杂度为快排引起的***O(NlogN)***

```cpp
vector<int> twoSum(vector<int>& numbers, int target) {
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> ret;
    while (lo <= hi) {
        int left = nums[lo], right = nums[hi];
    	if (nums[lo] + nums[hi] < target) {
        	while (lo < hi && nums[lo] == left) lo++;
        }
        else if (nums[lo] + nums[hi] > target) {
            while (lo < hi && nums[hi] == right) hi++;
        }
        else {
            ret.push_back({left, right});
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi++;
        }
    }
}
```

### threeSum & fourSum

## *其他*

### 前K个高频单词

* <https://leetcode.cn/problems/top-k-frequent-words/>
* 思路1：优先级队列通过构建仿函数，提供自定义仿函数less来实现字典序

    ```cpp
    struct Less // 为优先级队列自定义仿函数
    {
        bool operator()(const pair<string, int>& kv1, const pair<string, int>& kv2) const //临时变量具常性，不用const可能通不过编译
        {
            if (kv1.second < kv2.second) // 比较val的大小
                return true;
            if (kv1.second == kv2.second && kv1.first > kv2.first) // 若val相同，则按字典序排
                return true;
            return false;
        }
    };

    vector<string> topKFrequent(vector<string>& words, int k) {
        map<string, int> countMap; // 统计次数
        for (auto& str : words)
            countMap[str]++;
        // topK问题，优先级队列方案
        priority_queue<pair<string, int>, vector<pair<string, int>>, Less> maxHeap;
        for (auto& kv : countMap)
            maxHeap.push(kv);
        // 返回topK的vector<string>
        vector<string> v;
        while (k--)
        {
            v.push_back(maxHeap.top().first);
            maxHeap.pop();
        }
        return v;
    }
    ```

* 思路2：直接使用 `stable_sort`

    ```cpp
    struct Greater
    {
        bool operator()(const pair<string, int>& kv1, const pair<string, int>& kv2) const
        {
            if (kv1.second > kv2.second)
                return true;
            // // 若用的是stable_sort就不用提供下面的比较了，这里是间接解决了sort的稳定性问题
            // if (kv1.second == kv2.second && kv1.first < kv2.first) // 若val相同，则按字典序排
            //     return true;
            return false;
        }
    };
    vector<string> topKFrequent(vector<string>& words, int k) {
        map<string, int> countMap;
        for (auto str:words)
            countMap[str]++;
        // 保证字典序就要保证sort稳定性，因此用stable_sort
        // sort和stable_sort都要使用随机访问迭代器，因此将map里的东西转移到vector里
        vector<pair<string, int>> sortV(countMap.begin(), countMap.end());
        stable_sort(sortV.begin(), sortV.end(), Greater());

        vector<string> v;
        for (size_t i=0; i<k; i++)
            v.push_back(sortV[i].first);
        return v;
    }
    ```

* 思路3：使用multimap进行排序，因为map底层是红黑树，可以对key进行排序

    ```cpp
    vector<string> topKFrequent(vector<string>& words, int k) {
        map<string, int> countMap;
        for (auto& str : words)
            countMap[str]++;
        
        multimap<int, string, greater<int>> sortMap; //不能用map，因为要保留重复项
        for (auto& kv : countMap)
            sortMap.insert(make_pair(kv.second, kv.first));
        
        vector<string> v;
        multimap<int, string, greater<int>>::iterator it = sortMap.begin();
        for (size_t i=0; i<k; i++)
        {
            v.push_back(it->second);
            it++;
        }
        return v;
    }
    ```

### 在长度 2N 的数组中找出重复 N 次的元素

* [961. 在长度 2N 的数组中找出重复 N 次的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/)

* 思路：遍历一遍数组，放到计数的countMap里，若countMap的Val等于N，返回countMap的Key

  ```cpp
  int repeatedNTimes(vector<int>& nums) {
      unordered_map<int, int> countMap;
      for (auto e : nums)
          countMap[e]++;
  
      for (auto& kv : countMap)
      {
          if (kv.second == nums.size()/2)
              return kv.first;
      }
      return -1; //leetcode后台编译器需要在所有路径上都有返回值
  }
  ```

###  两个数组的交集

* [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)
* 思路：

# 暴力搜索算法

## *回溯算法*

### 回溯 vs. DFS

回溯算法和深度优先遍历有密切的关系，因为回溯算法就是一种深度优先遍历的实现方式

深度优先遍历是一种搜索算法，它通过递归地访问每个节点的所有后继节点，直到遇到终止条件或者无法再继续访问为止。回溯算法就是一种基于深度优先遍历的算法，在搜索的过程中遇到无法继续搜索的情况时，回溯算法会返回上一层节点，继续搜索其他路径。

回溯算法常用于解决组合问题、排列问题和搜索问题等，如求解数独、八皇后问题、迷宫问题等。在回溯算法的实现中，常常需要使用深度优先遍历来搜索所有可能的解。



回溯算法是一种树的算法



回溯算法：在树枝上选择和撤销选择

DFS：在节点上选择和撤销选择

```cpp
// DFS 算法把「做选择」「撤销选择」的逻辑放在 for 循环外面
void dfs(Node* root) {
    if (root == NULL) return;
    // 做选择
    printf("我已经进入节点 %p 啦\n", root);
    for (Node* child : root->children) {
        dfs(child);
    }
    // 撤销选择
    printf("我将要离开节点 %p 啦\n", root);
}

// 回溯算法把「做选择」「撤销选择」的逻辑放在 for 循环里面
void backtrack(Node* root) {
    if (root == NULL) return;
    for (Node* child : root->children) {
        // 做选择
        printf("我站在节点 %p 到节点 %p 的树枝上\n", root, child);
        backtrack(child);
        // 撤销选择
        printf("我将要离开节点 %p 到节点 %p 的树枝上\n", child, root);
    }
}

```

我们可以发现，当做DFS的时候，选择和撤销选择是在for外面，因此它可以把root给打出来。但是做回溯的时候选择和撤销是在for里面，也就是说这时候已经经过了节点，在转移到下一个节点的过程中了，所以它会把root给漏掉







### 算法思想

* 回溯算法实际上是一个类似枚举的搜索尝试过程，主要是在搜索过程中寻找问题的解，当发现已不满足求解条件时，就回溯返回，尝试别的路径
* 满足回溯条件的某个状态的点称为“回溯点”，也称为剪枝点

### 全排列问题

### N皇后问题

### 数独问题

## *回溯算法解决排列组合子集问题*

## *DFS算法*

### 岛屿类题目

## *BFS算法*

### BFS框架

GKI中学过BFS算法：BFS是一种采用队列以空间换时间的方法，**具有完备性**。虽然可以找到最优的路径，但大量的enqueue、dequeue操作使算法消耗很大，空间复杂度也比较大

```cpp
int BFS(Node start, Node target) {
    queue<Node> q; 
    set<Node> visited;
    
    q.push(start); 
    visited.insert(start);

    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; i++) {
            Node cur = q.front();
            q.pop();
            if (cur == target)
                return step;
            for (Node x : cur.adj()) {
                if (visited.count(x) == 0) {
                    q.push(x);
                    visited.insert(x);
                }
            }
        }
    }
    // 如果走到这里，说明在图中没有找到目标节点
}

```



### 滑动谜题



# 动态规划 DP

## *核心框架*

### 动态规划三要素

动态规划 DP Dynamic Programming 是一种解决复杂问题的算法设计技术，它通常用于运筹学中的最优化问题和组合问题，以在给定约束条件下找到最优解或计算问题的解决方案。动态规划算法的关键思想是将问题分解成子问题，然后将子问题的解合并以找到原始问题的解决方案

既然是要最优化，所以DP的一般形式就是求最值，而求最值的核心问题自然就是穷举。不过穷举并非一件简单的事情，动态规划三要素如下

1. 需要熟练掌握递归思维，列出正确的**状态转移方程**
2. 需要判断算法问题是否具备**最优子结构**，是否能够通过子问题的最值得到原问题的最值
3. 单纯暴力穷举的话效率会很低，所以需要使用**备忘录 DP table**来优化穷举过程，避免不必要的计算

### 状态转移方程 & 框架

动态规划问题通常通过状态转移方程来描述子问题之间的关系。这是问题的数学表示，用于定义如何从一个或多个子问题的解来计算原始问题的解

写出状态转移方程：明确 base case `->` 明确状态 `->` 定义dp数组/函数的含义

下面我们用两个例子Fibonacci数和凑零钱问题来说明动态规划

## *Fibonacci数*

[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

### 空间优化

滚动数组，求中间的一个状态仅使用之前的N个有效状态。能把***O(N^2)***空间复杂度降为***O(N)***，***O(N)***空间复杂度降为***O(1)***

注意滚动数组的赋值方向，从前往后赋值

### 相关题目

[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

[1137. 第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/)

### 凑零钱问题

要符合最优子结构，子问题之间必须互相独立

1. 确定 base case：amount为0时就返回0，此时
2. 确定**状态**，即原问题和子问题中会变化的变量：本题中coin的数量无限制，coin的面值也不变化，只有amount会随着凑零钱的进度不断向base case靠近。因此这道题里amount就是状态
3. 确定**选择**，选择导致状态产生变化的行为：选择什么面值的硬币会导致amount变化
4. 明确dp函数/数组的定义，列出状态转移方程

## *最长递增子序列*

## *背包类型问题*

# 数据结构设计

## *常数时间删除、查找数组中的任意元素*

# 数学运算技巧

## *常用的位操作*

### 不引入第三个变量交换两个变量

* 先加后减：可能会有溢出问题

  ```cpp
  a = a + b;
  b = a - b;
  a = a - b;
  ```

* 先减后加：可能会有溢出问题

  ```cpp
  a = b - a;
  b = b - a;
  a = a + b;
  ```

* 异或：速度很快，但是只能用于整数

  ```cpp
  a = a ^ b;
  b = a ^ b; // b == a^b^b == a
  a = a ^ b; // a == a^b^a^b^b == b
  ```

## *高效模幂运算*

## *高效寻找素数*

## *丑数*

### 丑数I

### 丑数II

### 丑数III

### 超级丑数

## *摩尔投票*

[169. 多数元素](https://leetcode.cn/problems/majority-element/)

# 随机算法

## *随机选择算法*

## *水塘抽样算法*

# 算法技巧

## *股票买卖问题*

## *打家劫舍问题*

## *KMP和BF*











### 统计参与通信的服务器

* 题目：[统计参与通信的服务器](https://leetcode.cn/problems/count-servers-that-communicate/)
* 思路：因为只要两台服务器位于同一行或者同一列就可以通信，所以只要判断在同一行或者同一列上是否有两台主机就可以。两次遍历即可

```cpp
class Solution {
public:
    int countServers(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> colTraverse(n, 0), rowTraverse(m, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j]) {
                    rowTraverse[i]++; 
                    colTraverse[j]++;
                }
            }
        }
        int ret = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] && (rowTraverse[i] >= 2 || colTraverse[j] >= 2)) {
                    ret++;
                }
            }
        }

        return ret;
    }
};
```

