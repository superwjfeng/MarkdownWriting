# 单链表

## *链表重构*

### 什么时候应该加哨兵位头节点？

哨兵位主要是方便了头插、头删的时候找头，以及方便调整头指针等

此外若给了一个空链表，那么首先我们需要判断是否链表为空

可以总结一下：**当需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理**

### <span id="合并两个有序链表">合并两个有序链表</span>

* <https://leetcode.cn/problems/merge-two-sorted-lists/description/>

* 思路1：双指针，比较结点数据大小。令一个为dest，另一个为src，进行尾插。这种方式虽然很清晰，但边界条件很不好控制

* 思路2：双指针归并，从头开始比较，取小的尾插到新链表。归并操作，指的是将两个顺序序列合并成一个顺序序列的方法

  <img src="合并两个有序列表.gif" width="70%">

### <span id="分隔列表">分隔列表</span>

* 题目

  * [86. Partition List - 力扣（LeetCode）](https://leetcode.cn/problems/partition-list/)
  * <https://www.nowcoder.com/practice/0e27e0b064de4eacac178676ef9c9d70?tpId=8&&tqId=11004&rp=2&ru=/activity/oj&qru=/ta/cracking-the-coding-interview/question-ranking>

* 思路：三指针，一个 `currNewGreater` 跟踪大数值链表，一个 `currNewLess` 跟踪小数值链表，另外一个 `currOld` 跟踪原链表中走到了哪里。`currOld` 走完之后，再把新的两个链表连接起来。最后一定要把大链表的最后一个置空，即 `currNewGreater->next = nullptr;`，否则会成环

  <img src="分隔列表.drawio.png" width="70%">

* 注意：因为我们的做法相当于是直接从原链表上摘节点下来，而且不像[合并两个有序链表](#合并两个有序链表)这道题，我们不能确认最后新的链表的最后一个节点就是（任意）原来链表的最后一个节点（若是的话本身最后一个节点的next就已经是空了）。**所以最后一个节点的next必须要置nullptr**，否则就会形成环

### 合并K个有序链表

* 题目：[合并 K 个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)
* 思路：用一个优先级队列来先将所有的节点入队列，然后思路就和[合并两个有序链表](#合并两个有序链表)这道题一样了。优先级队列默认 `std::less` 建大堆，记得用lambda自定义一下建小堆
* 注意：这道题和[分隔列表]((#分隔列表))那道题有同样的坑，就是因为不知道到底哪个原来的节点是新的最后一个节点，所以一定要将新的最后一个节点置空，否则会成环
* 时间复杂度分析：***O(NlogK)***，N是链表的总节点数，K是链表的条数

### 查找和最小的K对数字

### 复制带随机指针的链表

* <https://leetcode.cn/problems/copy-list-with-random-pointer/>

* 思路1：构造深拷贝，问题在于每一个random应该放在什么位置？将要copy的节点连接到源节点的后面

  <img src="复制带随机指针的链表.png">

* 思路2：利用BST的KV模型：存储源节点和拷贝节点的KV映射

## *链表双指针*

### 链表的中间结点

* <https://leetcode.cn/problems/middle-of-the-linked-list/description/>

* 思路：快慢指针，慢指针一次走1步，快指针一次走2步

  <img src="链表的中间结点_快慢指针.png" width="50%">

### 删除链表中等于给定值val的所有结点

* <https://leetcode.cn/problems/remove-linked-list-elements/>

* 思路1：快慢指针，遇到等于val的就调整指针关系

  <img src="删除链表中等于给定值val的所有结点.png" width="50%">

* 思路2：遍历原链表，把不是val的结点拿出来尾插到新链表

* 思路3：哨兵位简化尾插，尾插一般要考虑哨兵位

### 删除排序链表中的重复元素

* 题目：[删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)。这道题虽然标了简单难度，然而是比较麻烦的一道题
* 思路：

### 输入一个链表，输出该链表中倒数第k个结点

* 题目
  * [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)
  * <https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 思路
  * 两次遍历求出链表长度N后再走N-K步，复杂度为***O(N)***
  * 快慢指针，快指针先走k步，然后快慢指针同时走。等到快指针走到NULL时，慢指针就是倒数第k个结点。虽然复杂度也为***O(N)***，不过只需要一次遍历了

### 输入两个链表，找出它们的第一个公共结点

* 题目：<https://leetcode.cn/problems/intersection-of-two-linked-lists/description/>
* 思路1：快慢指针。分别找出两个链表的长度和长度差k，然后令长的为快指针走k步后，再令快慢之中遍历一次链表并同时判断node的地址是否有相同的
* 思路2：因为给的是struct结构体，所以分别建两个vector后push_back，将长的vector pop_back掉两个vector的长度差个元素，然后逐次比较
* 思路3：利用两个栈，分别入栈，将长的栈pop掉两个栈的长度差个元素，然后逐次比较
* 思路4：利用BST的K模型，找出第一个出现两次的节点

## *判断成环*

### 给定一个链表，判断链表中是否有环

* <https://leetcode.cn/problems/linked-list-cycle/description/>
* 思路：用快慢指针转变为一个追击问题，若有环则慢指针肯定能追上快指针。若没有环则当fast或fast->next走完时就返回false
* 证明：为什么快指针每次走2步，慢指针每次走1步时若有环一定能追上？
  * slow进环后开始追击。假设slow进环后，fast和slow之间的距离是X
  * 这次fast真正开始追击slow，每追击一次，fast和slow之间距离缩短1
  * 直到距离缩短到0，二者相遇
* 如果快指针一次走3步、4步、n步时，fast是否肯定能追上slow呢？不一定！这时候环的大小就有影响了
  * 假设环的大小为R，假设fast一次走3步，每走一次fast和slow距离缩短2
    * 若fast和slow之间的距离N是偶数，则第一次就追上
    * 若X是奇数，则距离会变成X, X-2, ..., 3, 1, X-1
    * 此时开始第二次追击，若R-1是偶数（即R是奇数），则第二次就追上了
    * 若R-1是奇数（R是偶数），则永远追不上

### 返回链表开始入环的第一个结点

* <https://leetcode.cn/problems/linked-list-cycle-ii/>

* 思路1：让快慢指针同时从链表起始位置开始遍历链表找出相遇点。当二者相遇时，让一个指针从**相遇点**位置开始绕环运行，头指针重新从头出发。两个指针都是每次均走一步，最终肯定会在入口点的位置相遇。时间复杂度***O(N)***，空间复杂度***O(1)***

  <img src="返回链表开始入环的第一个结点.png" width="50%">

  * 当slow走1步，fast走2步时，slow进环以后，fast一定在2圈之内追上slow。因为追击过程快慢指针之间相对距离每次缩小1，不可能会错过，他们相对距离最多是1圈，slow最多走1圈就会被追上

  * 设环之前的路程为L，slow进环后走X，环的大小是R

  * 假设slow进环前，fast在环里面转了N圈（$N\geq1$，fast至少要走一圈追上slow）

  * 则fast走的路程为 $L+n*R+X\ (n=1,\cdots,n)$

  * 根据下面的公式可以看出若一个指针从相遇点出发，一个指针从头开始走，他们会在入口点相遇
    $$
    fast == slow\longleftrightarrow L+n*R+X = 2*(L+X) \rightarrow L=n*R-X=(n-1)*R+(R-X)\\\rightarrow L+(R-X)=(n-1)*R
    $$

  * 假设的参数中只有R是可以明确算出来的

* 思路2：建立索引遍历，第一个重新遇到的就是入口。时间、空间复杂度都是***O(N)***


## *单链表反转问题*

### 框架

### 反转一个单链表

* <https://leetcode.cn/problems/reverse-linked-list/>
* 思路1：遍历原链表，把所有结点拿出来头插尾插到新链表

    <img src="反转一个单链表_头插.png" width="40%">

    ```c
    struct ListNode* reverseList(struct ListNode* head){
        struct ListNode* newhead = NULL;
        struct ListNode* curr = head;

        while (curr)
        {
            struct ListNode* next = curr->next;
            curr->next = newhead;
            newhead = curr;
            curr = next;
        }
        return newhead;
    }
    ```

* 思路2：颠倒指针

    <img src="反转一个单链表_颠倒指针.png" width="60%">

    ```c
    struct ListNode* reverseList(struct ListNode* head){
        if (head == NULL)
            return NULL;
        struct ListNode* prev = NULL;
        struct ListNode* curr = head;
        struct ListNode* next = curr->next;
        while (curr)
        {
            curr->next = prev; // 倒指向
            // 迭代
            prev = curr;
            curr = next;
            if (next) // curr到最后一个时还要迭代一次，此时next==NULL
                next = next->next;
        }
        return prev;
    }
    ```

### 反转一个链表的某个区间

### K个一组反转链表

## *回文链表*

### 链表的回文结构

* <https://www.nowcoder.com/practice/d281619e4b3e4a60a2cc66ea32855bfa?tpId=49&&tqId=29370&rp=1&ru=/activity/oj&qru=/ta/2016test/question-ranking>
* 思路1：快慢指针找到中间结点rhead后将rhead后面的部分逆置。奖后将head和rhead都看作慢指针，每次走一步并且比较，若有不同则返回false。奇数次和偶数次的情况可以统一为一种情况，奇数次时会形成环
* 思路2：直接新建一个翻转的新链表，然后两个指针同时走比较
* 思路3：二叉树后序遍历？

# 数组

## *双指针*

### 汇总区间

* 题目：[汇总区间](https://leetcode.cn/problems/summary-ranges/)
* 思路：快慢指针

```cpp
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        int stay = 0, move = 1;
        int n = nums.size();
        vector<string> ret {};
        while (move <= n - 1) {
            if (nums[move] == nums[move - 1] + 1) {
                move++;
            }
            else {
                if (stay == move - 1) {
                    ret.push_back(std::to_string(nums[stay])); // only one element
                }
                else {
                    ret.push_back(std::to_string(nums[stay]) + "->" + std::to_string(nums[move - 1]));
                }
                stay = move++;
            }
        }
        // last range
        if (n > 0) {
            if (stay == n - 1) {
                ret.push_back(std::to_string(nums[stay])); // only one element
            }
            else {
                ret.push_back(std::to_string(nums[stay]) + "->" + std::to_string(nums[n - 1]));
            }
        }
        return ret;
    }
};
```

## *前缀和*

前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和

## *差分数组*

查分数组主要适用的场景是频繁对原始数组的某个区间的元素进行增减

## *二维数组的高级遍历方法*

### 顺/逆时针旋转矩阵

### 螺旋遍历



## *字符串*

### 字符串最后一个单词的长度

* <https://www.nowcoder.com/practice/8c949ea5f36f422594b306a2300315da?tpId=37&&tqId=21224&rp=5&ru=/activity/oj&qru=/ta/huawei/question-ranking>
* 思路：调用string::rfind找到最后一个空格后再用strlen

```cpp
int main() {
    string str;
    getline(cin, str); 
    size_t pos = str.rfind(' ');
    if (pos != string::npos)
    {
        cout << str.size() - pos - 1 << endl;
    }
    else
    {
        // 只有一个单词
        cout << str.size() << endl; 
    }
}
```

### 字符串中的第一个唯一字符

* <https://leetcode.cn/problems/first-unique-character-in-a-string/>
* 思路：计数排序

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        int countArr[26] = {0};
        for (auto ch:s)
        {
            countArr[ch-'a']++;
        }
        for (size_t i=0; i<s.size(); i++)
        {
            if (countArr[s[i]-'a'] == 1)
                return i;
        }
        return -1;
    }
};
```

### 字符串转整型数字

* <https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&&tqId=11202&rp=6&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 思路：从头遍历
```cpp
long long StrToInt(string str)
{
    long long sum = 0;
    int i = 0;
    int flag = 1; // 记录正负数
    int end = str.size(); // 不算\0
    while (i < end)
    {
        if ((str[i] > '0' && str[i] < '9') || (str[i] == '+' || str[i] == '-'))
        {
            if (i == 0 && (str[0] == '+' || str[0] == '-')) // 处理 +- 号
                str[0] == '+' ? flag : flag *= -1; // 若是-号，就将flag置为-1
            else
                sum = sum * 10 + (str[i] - '0');
            i++;
        }
        else
            return 0;
    }
    return flag * sum;
}
```

### 字符串相加--实现大整数加法

* <https://leetcode.cn/problems/add-strings/>
* 思路：从后往前将每一个转换为数字后进行加法，用next来保留进位。将加法得到的结果转换回string然后进行尾插。注意：string和vector一样因为效率原因不提供尾插，尾插的方法是直接+=，最后reverse

```cpp
class Solution {
public:
    string addStrings(string num1, string num2) {
        int end1 = num1.size() - 1, end2 = num2.size() - 1;
        int next = 0; // 保存进位
        string strRet; // 保存返回的string
        while (end1 >= 0 || end2 >= 0) // 两个都走完才结束
        {
            int val1 = end1 >= 0 ? num1[end1] - '0' : 0; // 若有一个加数走完了，那么就将他相应位看作0
            int val2 = end2 >= 0 ? num2[end2] - '0' : 0;
            int ret = val1 + val2 + next;
            next = ret > 9 ? 1 : 0;
            // // string 不支持 push_front，因为string和vector一样头插要挪动数据，效率很低。要使用insert
            // strRet.insert(0, 1, (ret % 10) + '0'); // strRet.insert(strRet.begin(), (ret % 10) + '0') 用迭代器
            --end1;
            --end2;
            // 尾插就是直接+=后最后统一reverse一下就可以了
            strRet += ('0' + ret%10);
        }
        // 类似于'1' + '9'这种情况下，还有1个进位
        if (next == 1)
            strRet += '1';
        reverse(strRet.begin(), strRet.end());
        // // 类似于'1' + '9'这种情况下，还有1个进位
        // if (next)
        //     strRet.insert(strRet.begin(), '1');
        return strRet;
    }
};
```

### 字符串相乘

### 反转字符串

* <https://leetcode.cn/problems/reverse-string/>
* 思路：头尾双迭代器

```cpp
class Solution {
public:
    void reverseString(vector<char>& s) {
        vector<char>::iterator begin = s.begin();
        vector<char>::iterator end = s.end() - 1;
        while (begin <= end) // 别用 !=，会有奇偶性问题
        {
            std::swap(*begin, *end);
            begin++;
            end--;
        }
    } 
};
```

### 仅仅反转字母

* <https://leetcode.cn/problems/reverse-only-letters/>
* 思路：双指针，若判断为字母就swap

```cpp
class Solution {
public:
    bool IsLetter(char ch)
    {
        if ((ch >= 'a' && ch <= 'z')
        || (ch >= 'A' && ch <= 'Z'))
            return true;
        else
            return false;
    }
    string reverseOnlyLetters(string s) {
        size_t begin = 0, end = s.size()-1;
        while (begin < end)
        {
            while (begin < end && !IsLetter(s[begin]))
                begin++;
            while(begin < end && !IsLetter(s[end]) )
                end--;
            std::swap(s[begin++], s[end--]);
        }
        return s;
    }
};
```

### 翻转字符串

### 区间部分翻转

### 反转字符串中的单词

### 验证回文字符串

## *nSum*

### Base case: twoSum

* 题目：[两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)。从一个已经排升序的数组之中找出满足相加之和等于目标数 `target` 的两个数，以长度为 2 的整数数组 `[index1, index2]` 的形式返回这两个整数的下标 `index1` 和 `index2`

* 思路：左右指针，因为已经排成升序了，所以如果当前两个边界的值大于 `target` 就缩小右边界，若小于 `target` 就放大左边界

  ```cpp
  vector<int> twoSum(vector<int>& numbers, int target) {
      int lo = 0, hi = numbers.size() - 1;
      while (lo <= hi) {
          if (numbers[lo] + numbers[hi] < target)
              lo++;
          else if (numbers[lo] + numbers[hi] > target)
              hi--;
          else 
              return {lo + 1, hi + 1};
      }
      return {};
  }
  ```

### 未排序的twoSum

<https://juejin.cn/post/7058682340515512333>

* 题目：[两数之和](https://leetcode.cn/problems/two-sum/)。这道题目虽然标的是简单，但实际上比前面排序好的base case要麻烦，很有理由怀疑是两道题目的难易程度搞混了
* 思路
  * 和base case的区别是没有排序，所以我们首先要排序。但是用 `sort()` 排序是对原来的vector直接操作的，那么拍完序之后就不能取到原来的序号了。所以笔者原来的思路是用unordered_map来保存 `<num, 对应的原下标>` 这种对应关系，但是因为题目里是有重复的key的，所以不嫩够用unordered_map
  * 如果考虑用multi_map的话虽然可以存下冗余的key，但是之后在通过num来找原下标的时候，会遇到对于同样的key到底是返回哪个序号的问题
  * 最后使用的是 `vector<pair<int, int>>` 的数据结构，它支持左右指针的随机访问，也可以把原来的下标给保存起来

### Generalization

现在泛化twoSum：`nums` 中**可能有多对**元素之和都等于 `target`，请你的算法返回**所有**和为 `target` 的元素对，其中**不能出现重复**。

<img src="twoSum有重复.drawio.png">

适应这种情况的方式是左右指针如果遇到了重复的就继续移动，复杂度为快排引起的***O(NlogN)***

```cpp
vector<int> twoSum(vector<int>& numbers, int target) {
    sort(nums.begin(), nums.end());
    int lo = 0, hi = nums.size() - 1;
    vector<vector<int>> ret;
    while (lo <= hi) {
        int left = nums[lo], right = nums[hi];
    	if (nums[lo] + nums[hi] < target) {
        	while (lo < hi && nums[lo] == left) lo++;
        }
        else if (nums[lo] + nums[hi] > target) {
            while (lo < hi && nums[hi] == right) hi++;
        }
        else {
            ret.push_back({left, right});
            while (lo < hi && nums[lo] == left) lo++;
            while (lo < hi && nums[hi] == right) hi++;
        }
    }
}
```

### threeSum & fourSum

## *滑动窗口*

### Rabin-Karp字符匹配算法

## *数组/顺序表*

### 原地移除数组中所有的元素val，要求时间复杂度为O(N)，空间复杂度为O(1)

* <https://leetcode.cn/problems/remove-element/> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
* 思路：双指针 <img src="原地移除数组中所有的元素val.png" width="50%">

```c
int removeElement(int* nums, int numsSize, int val){
    int dest = 0, src = 0;
    while (src < numsSize)
    {
        if (nums[src] != val)
            nums[dest++] = nums[src++];
        else
            src++;
    }
    return dest;
}
```

### 删除排序数组中的重复项

* <https://leetcode.cn/problems/remove-duplicates-from-sorted-array/> 给你一个升序排列的数组nums，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持 一致 。
* 思路：双指针

```c
int removeDuplicates(int* nums, int numsSize){
    int move = 0, stay = 0;
    while (move < numsSize)
    {
        if (nums[move] != nums[stay])
            nums[++stay] = nums[move++];
        else
            move++;
    }
    return stay + 1;
}
```

### 合并两个有序数组

* <https://leetcode.cn/problems/merge-sorted-array/> 给你两个按非递减顺序排列的整数数组nums1和nums2，另有两个整数m和n，分别表示 nums1和nums2中的元素数目。请你合并nums2到nums1中，使合并后的数组同样按非递减顺序排列。
* 思路：因为是非递减的数组，所以三指针从后往前排

```c
void merge(int* nums1, int nums1Size, int m, int* nums2, int nums2Size, int n){
    int dest = m-1, src = n-1, dest_end = m+n-1;
    while (src>=0 && dest>=0)
    {
        if (nums2[src] >= nums1[dest])
            nums1[dest_end--] = nums2[src--];
        else
            nums1[dest_end--] = nums1[dest--]; 
    }
    while (src>=0)
        nums1[dest_end--] = nums2[src--]; 
}
```

### 杨辉三角

* <https://leetcode.cn/problems/pascals-triangle/>

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> vv;
        vv.resize(numRows); // resize初始化每一行
        // 每一行的首尾元素赋为1
        for (size_t i=0; i<vv.size(); i++)
        {
            vv[i].resize(i+1, 0);
            vv[i].front() = vv[i].back() = 1;
        }

        for (size_t i=0; i<vv.size(); i++)
        {
            for (size_t j=0; j<vv[i].size(); j++)
                if (!vv[i][j])
                    vv[i][j] = vv[i-1][j] + vv[i-1][j-1];
        }
        return vv;
    }
};
```

### 电话号码的字母组合

* <https://leetcode.cn/problems/letter-combinations-of-a-phone-number/>
* 思路：排列组合多路递归，深度优先遍历。

<img src="电话号码的字母组合.png">

```cpp
class Solution {
    const char* numToStr[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    //string numToStr[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
public:
    void combine(string digits, int di, vector<string>& retV, string combineStr)
    { // digits为选中的数字，di为其下标，retV存放返回的可能组合，combineStr
        // 取数字字符映射的字符串
        if (di == digits.size())
        {
            retV.push_back(combineStr);
            return;
        }
        int num = digits[di] - '0';
        string str = numToStr[num];
        for (auto ch : str)
            combine(digits, di+1, retV, combineStr+ch);
            // 这里注意不要写成combineStr+=ch了，因为处于for循环中，combineStr需要重复使用
    }
    vector<string> letterCombinations(string digits) {
        vector<string> v;
        if (digits.empty())
            return v;
        string str;
        combine(digits, 0, v, str);
        return v;
    }
};
```

# 栈和队列

### 括号匹配问题

* <https://leetcode.cn/problems/valid-parentheses/>
* 思路：左括号入栈，若不是左括号则进行匹配，若匹配则将此时的栈顶元素pop掉，若不匹配则返回false。知道全部元素判断完

    ```cpp
    class Solution {
    public:
        bool isValid(string s) {
            stack<char> st;
            int i = 0;
            while(s[i])
            {
                if (s[i] =='(' || s[i] == '[' || s[i] == '{') 
                {
                    st.push(s[i]); // 任意一种左括号就入栈
                    i++;
                }
                else
                {
                    if (st.empty()) // 处理只有 ']' 时错误地st.top()
                        return false;
                    if((st.top() == '(' && s[i] == ')') // 若栈顶和当前括号匹配时将栈顶Pop
                    || (st.top() == '[' && s[i] == ']')
                    || (st.top() == '{' && s[i] == '}'))
                    {
                        i++;
                        st.pop();
                    }
                    else
                        return false;
                }
            }
            if (!st.empty()) // 处理只有 '(' 的情况
                return false;
            return true;
        }
    };
    ```

* 改进：若队列中不仅仅包含括号，还有其他字符怎么办？多添加一个 else if 判断就可以

    ```cpp
    if (st.empty())
        return false;
    if ((st.top() == '(' && A[i] == ')')
        || (st.top() == '[' && A[i] == ']')
        || (st.top() == '{' && A[i] == '}'))
    {
        st.pop();
        i++;
    }
    else if (A[i] != ')' || A[i] != ']' || A[i] != '}') // 若不是右括号，则直接++
        i++;
    else
        return false;
    ```

### 用队列实现栈

* <https://leetcode.cn/problems/implement-stack-using-queues/>
* 思路：给两个FIFO的队列，保持一个队列存储数据，一个队列空着，空着的队列是为了将另一个队列的数据导过来

    <img src="用队列来实现栈.png" width="80%">

### 用栈实现队列

* <https://leetcode-cn.com/problems/implement-queue-using-stacks/>
* 思路：和用队列实现栈的思路一样，用两个LIFO的栈来回倒数据

    <img src="用栈来实现队列.png" width="80%">

### 设计循环队列/环形缓冲器

* 解决的问题是当位子有限时的排队，比如限定了人数的商店，只有当一个人出去了另一个人才能进来。OS中的生产者消费者模型
* <https://leetcode.cn/problems/design-circular-queue/>
* 思路：
  * 因为有可能是因为push满了也有可能是pop空了，此时都是 front == rear，无法判断到底是满了还是空了
  * 可以考虑多记录一个size
  * 也可以考虑多开一个空间不存储数据，当 rear + 1 == front 是就是满了，若 front == rear 就是空
  * 因为用单链表实现比较难取尾，所以用数组来实现
  * 要处理当tail或head在边界时的特殊情况

为了更方柏的取队尾数据，采用数组来实现

### 最小栈：要求时间复杂度为O(1)

* <https://leetcode.cn/problems/min-stack/>
* 思路：构造一个辅助栈minst存储最小值，当st中有小于等于minst堆顶数据的时候minst才插入

    <img src="最小栈.png">

```cpp
class MinStack {
public:
    MinStack() {
    // 不用处理，空的构造函数等价于默认构造函数，因为会自动调用初始化列表（实际上初始化的地方）进行默认的初始化
    // 因为类成员都是 stack<int> 这种有默认构造的内置数据类型，所以给一个默认构造也没事
    }
    void push(int val) {
        _st.push(val);
        if (_minst.empty() || val <= _minst.top())
            _minst.push(val);
    }
    void pop() {
        if (_minst.top() == _st.top()) // 若是和_st.top()相同的数据就删除_minst.top()
            _minst.pop();
        _st.pop();
    }
    int top() {
        return _st.top();
    }
    int getMin() {
        return _minst.top();
    }
private:
    stack<int> _st;
    stack<int> _minst;
};
```

* 进一步扩展：若待入栈的数据是大量重复数据该怎么办？比如插入10w个1。将minst中的数据类型改成一个struct或class，加一个计数器类成员。若是相同的数据则只要更新计数器就行

### 栈的弹出压入序列

* <https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&&tqId=11174&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 思路：用一个辅助栈来模拟push和pop的过程。若当前push的值不等于要pop的值就持续入；若和pop序列匹配就持续出。若辅助栈的值能pop完就为真否则为假

<img src="栈的弹出压入序列.png" width="70%">

```cpp
class Solution {
public:
    bool IsPopOrder(vector<int> pushV,vector<int> popV) {
        stack<int> st;
        int popi = 0;

        for (auto pushVal : pushV)
        {
            st.push(pushVal);
            // 出栈序列匹配后要持续比较，可能会有多个匹配
            while (!st.empty() && popV[popi] == st.top())
            {
                popi++;
                st.pop();
            }
        }
        return st.empty(); // return popi == popV.size();
    }
};
```

### 逆波兰表达式求值

* <https://leetcode.cn/problems/evaluate-reverse-polish-notation/>
* 波兰表达式 Polish notation 也称前缀表达式。在计算机中人类习惯的中缀表达式是无法进行有效计算的，必须转换成前缀或后缀表达式队列后，利用出栈和入栈再进行运算
  * 前缀表达法
  * 中缀表达式 `1 + 2 * 3`
  * 后缀表达式 `1 2 3 * +`：操作数的顺序不变，把运算符优先级按照顺序排列
* 思路
  * 给一个辅助栈，只入操作数，不入操作符
  * 遇到操作数就入栈，遇到运算符就就取栈顶的连续两个数据运算，运算结果继续入栈
  * 若序列走完了，最后辅助栈里栈顶元素就是结果

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        stack<long long> st;
        for (auto& str : tokens)
        {
            if (str == "+" || str == "-" || str == "*" || str == "/") // 若是操作符就要进行运算
            // 用的是一个string来进行比较，不会混淆负号和负数
            {
                long long right = st.top();
                st.pop();
                long long left = st.top();
                st.pop();
                switch(str[0]) // switch 是不支持string的，但str[0]是一个char
                {
                    case '+':
                        st.push(left + right);
                        break;
                    case '-':
                        st.push(left - right);
                        break;
                    case '*':
                        st.push(left * right);
                        break;
                    case '/':
                        st.push(left / right);
                        break;
                }
            }
            else // 若是操作数就进行入栈，将string转换为int
                st.push(stoi(str)); 
        }
        return st.top();
    }
};
```

### 基本运算器

* <https://leetcode.cn/problems/basic-calculator/>
* 包含了两个基本步骤：先要将输入的中缀表达式转换为后缀表达式，然后再利用后缀表达式求值
  * 中缀转后缀
    * 操作数输出到存储序列中，操作符入辅助栈
    * 栈为空，或者若操作符比当前栈顶的操作符优先级高则当前操作符入栈；若低于或等于栈顶操作符，则栈顶元素出栈放到存储序列中，然后当前操作符入栈（注意，若栈中有多个运算符，就要进行连续比较）。这是因为要控制栈顶的优先级高
    * 序列走完了，若辅助栈里还有操作符则依次输出到存储序列中
  * 若有括号，则设置一个flag，将 flag = 1，则将运算符优先级升到最高

### 数组中第k个大的元素

* <https://leetcode.cn/problems/kth-largest-element-in-an-array/>
* 思路：优先级队列建大堆，将前k-1个pop掉后，堆顶的就是第k个最大元素

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        // 建大堆 -- O(N)
        priority_queue<int> maxHeap(nums.begin(), nums.end());
        while (--k) // 将前k-1个pop掉后，堆顶的就是第k个最大元素
            maxHeap.pop(); // O(logN * k)
        return maxHeap.top();
    }
};
```

# 二分查找

二分查找的复杂度是***O(logN)***

## *框架*

### 使用二分查找的前提

1. 有序数组，不论是排升序还是排降序
2. 返回一个索引

### 核心

```cpp
int binarySearch(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left)/2; // int mid = (left + right) / 2;
        if (nums[mid] == target) {
            return mid;
        }
        else if (nums[mid] < target) { // 提高下界
            left = mid + 1;
        }
        else if (nums[mid] > target) { // 缩小上界
            right = mid - 1;
        }
    }
    return -1;
}
```

* 为什么要写成 `left + (right - left)/2`？这种表达和 `(left + right)/2` 是一样的效果，但是前者可以抵抗大整数相加溢出

* 为什么while判断条件用了 `left <= right`？因为将right初始化为 `nums.size()-1`，而不是 `num.size()`，这相当于是左闭右闭的写法。所以当 `left = right` 的时候做最后一次搜索，此时的搜索空间就是 `[left, left]`

* 为什么迭代操作是 `left = mid + 1` 和 `right = mid - 1`？

* 关于数组是奇数还是偶数的问题：奇数时 `/2` 可以整除，偶数时则要向下取整。但两种情况下边界都是 `+1`、`-1`，所以边界在不断缩小，适用于两种情况，可以手推一下下面两个例子

  ```
  奇数：0 3 5 7 9     target = 7
  偶数：0 3 5 7 9 11  target = 9
  ```

* 全部用了else if没有用else的原因是这样可以有效的帮助我们理清楚三种情况

### 找左侧边界

### 找右侧边界

## *二分查找题目*

## *扩展题目*

### 搜索二维矩阵

* 题目：[搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)

### 搜索二维矩阵II

* 题目：[搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

## *二分查找变体*

# 二叉树

## *纲领*

### 单值二叉树

* <https://leetcode.cn/problems/univalued-binary-tree/>
* 思路：中序遍历

```cpp
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        if (root == NULL) // 前序
            return true;
        if (root->left && root->left->val != root->val)
            return false;
        if (root->right && root->right->val != root->val)
            return false;
        return isUnivalTree(root->left) && isUnivalTree(root->right);
    }
};
```

### 检查两颗树是否相同

### 对称二叉树

### 二叉树遍历

* 前序遍历
* 中序遍历
* 后序遍历

### 另一颗树的子树

### 二叉树高度

* 求最大深度
  * <https://leetcode.cn/problems/maximum-depth-of-binary-tree/>
  * 利用max递归求子树的最大深度

    ```cpp
    int maxDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        int leftDep = maxDepth(root->left);
        int rightDep = maxDepth(root->right);
    
        return max(leftDep, rightDep) + 1;
    }
    ```

* 求最小深度
  * <https://leetcode.cn/problems/minimum-depth-of-binary-tree/>
  * 思路1：和求最大深度相反用min，但要注意的是当有一个分支为空时，这个分支不能被计算在内，而是将有效子树的高度+1

    ```cpp
    int minDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;
        int leftHT = minDepth(root->left);
        int rightHT = minDepth(root->right);
        if (root->left && root->right) // 当有一颗子树为空时，这个分支不被计算在内
            return min(leftHT, rightHT) + 1;
        else
            return max(leftHT, rightHT) + 1;
    }
    ```

  * 思路2：BFS，当有一节个结点的左右子树都为0时，就输出当前的层数
  
    ```cpp
    int minDepth(TreeNode* root) {
        int depth = 0, levelSize;
        queue<TreeNode*> q;
        if (root){
            q.push(root);
            levelSize = 1;
        }
        while (!q.empty()){
            depth++;
            for (int i = 0; i < levelSize; i++){
                TreeNode* front = q.front();
                if (!front->left && !front->right)
                    return depth;
                if (front->left)
                    q.push(front->left);
                if (front->right)
                    q.push(front->right);
                q.pop();
            }
            levelSize = q.size();
        }
        return depth;
    }
    ```
  
    

* 判断平衡二叉树

  * <https://leetcode.cn/problems/balanced-binary-tree/>
  * 思路：借助子树的高度差来递归判断每一棵子树是否是平衡树

    ```cpp
    int Height(TreeNode* root)
    {
        if (root == nullptr)
            return 0;
        int leftHT = Height(root->left);
        int rightHT = Height(root->right);
        return max(leftHT, rightHT) + 1;
    }
    
    bool isBalanced(TreeNode* root) {
        if (root == nullptr)
            return true;
        int leftHT = Height(root->left);
        int rightHT = Height(root->right);
        int diff = leftHT - rightHT;
        
        return abs(diff) < 2
            && isBalanced(root->left)
            && isBalanced(root->right);
    }
    ```

### 判断二叉树是否是完全二叉树

### 二叉树的构建及遍历

### 删除二叉搜索树中的节点

* <https://leetcode.cn/problems/delete-node-in-a-bst/>
* 思路：参考BST的Insert实现，可以考虑循环和递归两种写法

```cpp
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        // 找要删除的节点
        TreeNode* prev = nullptr;
        TreeNode* curr = root;
        while (curr)
        {
            if (curr->val > key) // 向左走
            {
                prev = curr;
                curr = curr->left;
            }

            else if (curr->val < key) // 向右走
            {
                prev = curr;
                curr = curr->right;
            }
            else// 找到了
            { // 找到了要考虑3种情况
                if (!curr->left) // curr的左子树为空
                { // 要考虑curr可能是prev的左子树，也可能是右子树
                    if (curr == root) // 当删除的是root的时候要特殊处理
                        root = curr->right;
                    else
                    {
                        if (curr == prev->left) // curr是prev的左子树
                            prev->left = curr->right;
                        else // curr是prev的右子树
                            prev->right = curr->right;
                    }
                    delete curr;
                    curr = nullptr;
                }
                
                else if (!curr->right) // curr的右子树为空
                { // 要考虑curr可能是prev的左子树，也可能是右子树
                    if (curr == root) // 当删除的是root的时候要特殊处理
                        root = curr->left;
                    else
                    {
                        if (curr == prev->left)
                            prev->left = curr->left;
                        else
                            prev->right = curr->left;
                    }
                    delete curr;
                    curr = nullptr;
                }
                else// curr的左右子树都不为空
                { // 采用替代删除--找右边最小左节点，然后替换val
                    TreeNode* minRPrev = curr; // 若minR还有一个右节点改咋办？要先“托孤”，且为了兼容删除root的情况，要让minRPrev=curr，而不是nullptr
                    TreeNode* minR = curr->right;
                    while (minR->left)// 找到最右边的最小节点
                    {
                        minRPrev = minR;
                        minR = minR->left;
                    }
                    swap(curr->val, minR->val);

                    // 考虑极端情况，若curr就是_root，此时minParent会出现空指针的情况
                    // 并且若一步都没有走的话，minR不一定是minParent的左节点，需要进行判断
                    if (minRPrev->left == minR)
                        minRPrev->left = minR->right;
                    else
                        minRPrev->right = minR->right;
                    delete minR;
                }
            }
        }
        return root; // 没找到
    }
};
```

### 二叉树创建字符串

* <https://leetcode.cn/problems/construct-string-from-binary-tree/>
* 用C语言来写，可以用strcat，strcat需要自己开空间，问题是要开多大，很麻烦
* 思路：左右都为空则省略掉相应括号；左子树不为空，右子树为空，则省略掉；左子树为空，右子树不为空，则不省略

```cpp
class Solution {
public:
    string tree2str(TreeNode* root) { // 传值传参效率问题，接口型的OJ不能改接口，要再写一个子函数
        if (root == nullptr)
            return string();
        string str;
        str += to_string(root->val);
        if (root->left || root->right) //左右都为空，就省略；左边为空，右边不为空不省略
        {
            str += '(';
            str += tree2str(root->left);
            str += ')';
        }

        if (root->right) // 右边为空就省略
        {
            str += '(';
            str += tree2str(root->right);
            str += ')';
        }
        return str;
    }
};
```

### 二叉树的分层遍历

* 自顶向下
  * <https://leetcode.cn/problems/binary-tree-level-order-traversal/>
  * 思路1：利用队列和记录每层的levelSize，每出一个--levelSize知道其为0，开始出下一层，控制一层一层出

      <img src="Level_order_traversal.png" width="40%">

    ```cpp
    class Solution {
    public:
        vector<vector<int>> levelOrder(TreeNode* root) {
            vector<vector<int>> vv; //定义一个二维数组用来保存返回值
            size_t levelSize; // 记录每层节点个数
            queue<TreeNode*> q; //定义一个队列用来存放树节点
            if (root) //若是root，设置默认值
            {
                q.push(root);
                levelSize = 1;
            }
            while(!q.empty())
            {
                vector<int> v; //定义保存每层节点的val的数组
                for (size_t i=0; i<levelSize; i++)
                {
                    TreeNode* front = q.front(); //保存队头，这样可以取得队头的子节点
                    q.pop(); //将队头pop掉，加载后面的节点
                    v.push_back(front->val); //将队头的val放到待返回的当前层数组里
                    if (front->left) //若队头的左、右子节点不为空，则加入队列中
                        q.push(front->left);
                    if (front->right)
                        q.push(front->right); 
                }
                vv.push_back(v); //将当前层得到的v放入待返回的vv中
                levelSize = q.size(); //更新levelSize
            }
            return vv;
        }
    };
    ```

  * 思路2：双队列，一个存结点指针TreeNode*，一个存元素对应所在的层数
* 自底向上
  * <https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/>
  * 上面的程序得到的vv里的元素用reverse函数反转一下

### 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先

* <https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/>
* 思路1：找到规律 -- ***O(h\*N)***
  * <img src="指定节点的最近公共祖先--思路1.png">
  * 若都在左子树中，就往左走；若都在右子树中，就往右走
  * 若其中一个是父节点，那么它自己本身就是最近公共祖先
  * 一个是左子树中的节点，一个是右子树中的节点，那么该节点就是最近公共祖先

    ```cpp
    class Solution { // 总的时间复杂的为O(h*N) h为二叉树高度
    public: 
        bool Find(TreeNode* sub, TreeNode* x) //在子树中找节点, O(N)
        {
            if (sub == nullptr)
                return false;
            return sub == x
                || Find(sub->left, x)
                || Find(sub->right, x); //中序
        }
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            if (root == nullptr)
                return nullptr; 
            if (root == p || root == q)
                return root;
            bool pInLeft, pInRight, qInLeft, qInRight; 
            pInLeft = Find(root->left, p); // 去当前节点的左子树里找p，若没找到就是在右子树里
            pInRight = !pInLeft;
            qInLeft = Find(root->left, q);
            qInRight = !qInLeft;
            // 1. 一个在左一个在右，root就是最近公共祖先
            if ((pInLeft && qInRight) || (pInRight && qInLeft))
                return root;
            // 2. 都在左，递归去左子树找；都在右，递归去右子树找
            else if (pInLeft && qInLeft)
                return lowestCommonAncestor(root->left, p, q);
            else if (pInRight && qInRight)
                return lowestCommonAncestor(root->right, p, q);
            else //这道题不会走到这里
                return nullptr;
        }
    };
    ```

* 思路2：借助队列和三叉链（节点带parent），转换为链表相交问题 -- 优化到 ***O(N)***
  * <img src="指定节点的最近公共祖先--思路2.png">

    ```cpp
    class Solution {
    public:
        bool FindPath(TreeNode* root, TreeNode* x, stack<TreeNode*>& path)
        {
            if (!root)
                return false;
            path.push(root);
            if(x == root)
                return true;
            if (FindPath(root->left, x, path) || FindPath(root->right, x, path)) // 只要有一个找到了就会进入
                return true;
            else // 两个子节点都没有找到或者都是空就要pop掉当前的节点
            {
                path.pop();
                return false;   
            }
        }
        TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
            stack<TreeNode*> pPath, qPath;
            FindPath(root, p, pPath);
            FindPath(root, q, qPath);
            // 链表相交的思路3
            int diff = pPath.size() - qPath.size();
            stack<TreeNode*> *longer = &pPath;
            if (diff < 0)
                longer = &qPath;
            for (int i=0; i<abs(diff); i++)
                longer->pop();
            int len = pPath.size();
            for(int i=0; i<len; i++)
            {
                if (pPath.top() == qPath.top())
                    return pPath.top();
                else
                {
                    pPath.pop();
                    qPath.pop();
                }
            }
            return nullptr; // 这道题不会走到这一步
        }
    };
    ```

* 题目里已经说明了给出的节点一定在树里能找到；若不一定在树里，那么需要迭代更多
* 若换成搜索二叉树，那么就不需要find函数了，直接利用搜索二叉树进行优化

### 二叉树搜索树转换成排序双向链表

* <https://www.nowcoder.com/practice/947f6eb80d944a84850b0538bf0ec3a5?tpId=13&&tqId=11179&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking>
* 要求不能创建任何新的结点，只能调整树中结点指针的指向。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。也就是要在原来的搜索二叉树上进行改动，不能创建一个新的vector
* 思路1：和二叉树线索化（线索化在实际中没有价值）一样，令left指向中序顺序的前一个，令right指向中序顺序的后一个。用2次递归
* 思路2：

### 根据一棵树的前序遍历与中序遍历构造二叉树

* <https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/>
* 必须是前序和中序或者中序和后序的序列和无重复值才能重建二叉树，若是前序和后序则不能。也就是必须要有中序，前序和后序确定树的根，而中序分割树
* 思路：前序创建树，中序分割左右子树

    ```cpp
    class Solution {
    public:
        TreeNode* _buildTree(vector<int>& preorder, vector<int>& inorder, int& pre_i, int inBegin, int inEnd)
        {
            if (inBegin > inEnd)
                return nullptr;
            TreeNode* root = new TreeNode(preorder[pre_i++]);
            // 分割中序
            int in_i = inBegin;
            while (in_i <= inEnd)
            {
                if (inorder[in_i] == root->val) // 找到根节点，因为无重复的val，所以可以这么找
                    break;
                else
                    in_i++;
            }
            // [inBegin, in_i-1] in_i [in_i+1, inEnd] 进行前序创建
            root->left = _buildTree(preorder, inorder, pre_i, inBegin, in_i-1);
            root->right = _buildTree(preorder, inorder, pre_i, in_i+1, inEnd);
            return root;
        }
        TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
            int pre_i = 0;
            return _buildTree(preorder, inorder, pre_i, 0, inorder.size()-1);
        }
    };
    ```

* 根据一棵树的中序遍历与后序遍历构造二叉树：用中序和后序重建二叉树的时候的注意点在于先构建右子树，再构建左子树，因为后序的遍历顺序为左、右、root

    ```cpp
    TreeNode* _buildTree(vector<int>& inorder, vector<int>& postorder, int& post_i, int inBegin, int inEnd)
    {
        // ... 相同 进行后序创建
        root->right = _buildTree(inorder, postorder, post_i, in_i+1, inEnd); 
        root->left = _buildTree(inorder, postorder, post_i, inBegin, in_i-1);
        return root;
    }
    ```

# set & map

### 前K个高频单词

* <https://leetcode.cn/problems/top-k-frequent-words/>
* 思路1：优先级队列通过构建仿函数，提供自定义仿函数less来实现字典序

    ```cpp
    struct Less // 为优先级队列自定义仿函数
    {
        bool operator()(const pair<string, int>& kv1, const pair<string, int>& kv2) const //临时变量具常性，不用const可能通不过编译
        {
            if (kv1.second < kv2.second) // 比较val的大小
                return true;
            if (kv1.second == kv2.second && kv1.first > kv2.first) // 若val相同，则按字典序排
                return true;
            return false;
        }
    };

    vector<string> topKFrequent(vector<string>& words, int k) {
        map<string, int> countMap; // 统计次数
        for (auto& str : words)
            countMap[str]++;
        // topK问题，优先级队列方案
        priority_queue<pair<string, int>, vector<pair<string, int>>, Less> maxHeap;
        for (auto& kv : countMap)
            maxHeap.push(kv);
        // 返回topK的vector<string>
        vector<string> v;
        while (k--)
        {
            v.push_back(maxHeap.top().first);
            maxHeap.pop();
        }
        return v;
    }
    ```

* 思路2：直接使用 `stable_sort`

    ```cpp
    struct Greater
    {
        bool operator()(const pair<string, int>& kv1, const pair<string, int>& kv2) const
        {
            if (kv1.second > kv2.second)
                return true;
            // // 若用的是stable_sort就不用提供下面的比较了，这里是间接解决了sort的稳定性问题
            // if (kv1.second == kv2.second && kv1.first < kv2.first) // 若val相同，则按字典序排
            //     return true;
            return false;
        }
    };
    vector<string> topKFrequent(vector<string>& words, int k) {
        map<string, int> countMap;
        for (auto str:words)
            countMap[str]++;
        // 保证字典序就要保证sort稳定性，因此用stable_sort
        // sort和stable_sort都要使用随机访问迭代器，因此将map里的东西转移到vector里
        vector<pair<string, int>> sortV(countMap.begin(), countMap.end());
        stable_sort(sortV.begin(), sortV.end(), Greater());

        vector<string> v;
        for (size_t i=0; i<k; i++)
            v.push_back(sortV[i].first);
        return v;
    }
    ```

* 思路3：使用multimap进行排序，因为map底层是红黑树，可以对key进行排序

    ```cpp
    vector<string> topKFrequent(vector<string>& words, int k) {
        map<string, int> countMap;
        for (auto& str : words)
            countMap[str]++;
        
        multimap<int, string, greater<int>> sortMap; //不能用map，因为要保留重复项
        for (auto& kv : countMap)
            sortMap.insert(make_pair(kv.second, kv.first));
        
        vector<string> v;
        multimap<int, string, greater<int>>::iterator it = sortMap.begin();
        for (size_t i=0; i<k; i++)
        {
            v.push_back(it->second);
            it++;
        }
        return v;
    }
    ```

### 在长度 2N 的数组中找出重复 N 次的元素

* [961. 在长度 2N 的数组中找出重复 N 次的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/)

* 思路：遍历一遍数组，放到计数的countMap里，若countMap的Val等于N，返回countMap的Key

  ```cpp
  int repeatedNTimes(vector<int>& nums) {
      unordered_map<int, int> countMap;
      for (auto e : nums)
          countMap[e]++;
  
      for (auto& kv : countMap)
      {
          if (kv.second == nums.size()/2)
              return kv.first;
      }
      return -1; //leetcode后台编译器需要在所有路径上都有返回值
  }
  ```

###  两个数组的交集

* [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)
* 思路：

# 暴力搜索算法



# 动态规划 Dynamic Programming 

## *Fibonacci类*

## *背包类型问题*

# 数据结构设计

## *常数时间删除、查找数组中的任意元素*

# 数学运算技巧

## *常用的位操作*

### 不引入第三个变量交换两个变量

* 先加后减：可能会有溢出问题

  ```cpp
  a = a + b;
  b = a - b;
  a = a - b;
  ```

* 先减后加：可能会有溢出问题

  ```cpp
  a = b - a;
  b = b - a;
  a = a + b;
  ```

* 异或：速度很快，但是只能用于整数

  ```cpp
  a = a ^ b;
  b = a ^ b; // b == a^b^b == a
  a = a ^ b; // a == a^b^a^b^b == b
  ```

## *高效模幂运算*

## *高效寻找素数*

## *丑数*

# 随机算法

## *随机选择算法*

## *水塘抽样算法*

# 股票买卖问题

# 打家劫舍问题











### 统计参与通信的服务器

* 题目：[统计参与通信的服务器](https://leetcode.cn/problems/count-servers-that-communicate/)
* 思路：因为只要两台服务器位于同一行或者同一列就可以通信，所以只要判断在同一行或者同一列上是否有两台主机就可以。两次遍历即可

```cpp
class Solution {
public:
    int countServers(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> colTraverse(n, 0), rowTraverse(m, 0);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j]) {
                    rowTraverse[i]++; 
                    colTraverse[j]++;
                }
            }
        }
        int ret = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] && (rowTraverse[i] >= 2 || colTraverse[j] >= 2)) {
                    ret++;
                }
            }
        }

        return ret;
    }
};
```

