# **C Learning**
1. ## 程序概览和基本概念
   1. ### 示例程序
    ```c
    #include <stdio.h>
    int main()
    {
        int num;
        num = 6;
        printf("HelloWorld!\n");
        printf("My faveourite number is %d", num);
        return 0;
    }
    ```
   2. ### 基本概念
      1. `#include <stdio.h>`：#include 称为C预处理器指令，导入头文件<stdio.h>
      2. `int main()`：main函数是一个程序的入口，必须要有，但实际上在调用main函数还有系统底层的函数
      3. `// /* */`：单行注释和跨行注释
      4. `int num` `num = 6;`
         1. 变量/标识符（Variable/Identifier）的声明和初始化，标识符在使用之前必须要进行声明和初始化，C99之前变量的声明一定要放在块顶部，C99标准允许其放在任意位置
         2. 命名变量时必须要用字母或下划线开始，不能用数字和其他字符，通常_或__开头的变量是留给操作系统和C库函数的
         3. int是一个数据类型，是一个关键词（keyword），不能被用作变量名
      5. `\n`为转义序列 excape sequence
      6. `%d`为占位符
      7. `return 0;`返回值，函数需要一个返回值，即使不写这条语句函数也会默认返回0，但写这条语句可以养成一种统一的代码风格
   3. ### 关键字和保留标识符
2. ## 数据和C 
   1. ### 数据类型关键字
      1. 整数和浮点数
      2. 整数
      3. 浮点数
   2. ### C语言基本数据类型
      1. int类型
      2. 其他整数类型
      3. 使用字符：char类型
         1. char类型用于存储字符，但由于在计算机中使用ASCII码来存储字符，因此char实际上是整型。每个char占用一个bit位
         2. ASCII码
            1. 65D-90D 大写字母；97D-122D 小写字母
            2. 0D NULL；32D 空格；48D-57D 1-9
         3. 用单引号括起来的单个字符被称为字符常量 character constant `char grade ='A'`
         4. C语言语法中没有规定char是有符号还是无符号，但为了保持统一，大部分编译器（包括vscode）中char都是**有符号**的
         5. 转义序列 escape sequence

         转义序列|含义
         :-|:-
         \a|警报(ANSIC)
         \b|退格
         \f|换页
         \n|换行
         \r|回车
         \t|水平制表符
         \v|垂直制表符
         \\\ |反斜杠
         \\'|单引号
         \\"|单引号
         \?|问号
         \0oo|八进制
         \xhh|十六进制
      4. _Bool类型
      5. 可移植类型：stdint.h和inttypes.h
      6. float、double和long double
      7. 负数和虚数类型
      8. 其他类型
      9.  类型大小：sizeof是C语言的内置运算符，以字节位单位给出指定类型的大小，C99和C11提供%zd转换说明匹配sizeof的返回类型。注意，sizeof返回的是size_t无符号整型
3. ## 字符串和格式化输入/输出
   1. ### 字符串 Character string 简介
      1. char类型数组和null字符
      2. 使用字符串
      3. 计算数组大小和元素个数
         1. `sizeof(str)/sizeof(str[0])` sizeof将会包括字符串末尾'\0'之前的所有char字节：即`char str[100]="I love Jiaxing."; sizeof(str);`其结果为100
         2. strlen()从第一个字符开始计算字符串中字符数，直到遇到空字符，然后返回空字符前字符总个数：即`char str[100]="I love Jiaxing。"; strlen(str);`其结果为15（包含空格和标点符号）
   2. ### 常量和C预处理器
      1. C预处理器：`#define NAME value` 变量的值在程序中可能会被改变，因此用预处理器
      2. const限定符
         1. int const *p：不能修改\*p所指向的值，但可以通过修改p地址
         2. int* const p：不能修改指针p，即p指向的地址不可修改，但*p指向的地址所村粗的指可以修改
      3. 明示常量
   3. ### printf()和scanf()
      1. printf()函数
         1. 转换说明：格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果；若没有匹配项，则根据系统和编译器不同结果也不同
                     
            转换说明|输出
            :-|:-
            %a和%A|浮点数、十六进制数和p计数法
            %c|单个字符
            %d|有符号十进制整数
            %i|有符号十进制整数，和%d相同
            %f|浮点数
            %e和%E|浮点数，e计数法
            %g和%G|根据值的不同自动选择
            %o|无符号八进制整数
            %p|指针
            %s|字符串
            %u|无符号十进制整数
            %x和%X|无符号十六进制整数，使用十六进制数0f和0F
            %%|打印一个百分号 
         2. 转换说明的意义：把给定的值翻译成要求的值并打印出来。程序把传入的值放入栈的内存区域，计算机根据变量类型（不是根据转换说明）把这些值放入栈中。printf()函数根绝转换说明（不是根据变量类型）从栈中读取值
         3. printf()**返回打印字符的个数**，如果有输出错误，则返回一个负值
         4. 打印长字符串
      2. scanf()函数
         1. scanf()函数使用空白，即**换行符、制表符和空格**把输入分成多个字段
         2. scanf()函数每次读取一个字符，***除了%c模式外跳过开头所有的空白字符开始读取第一个非空白字符***，并保存非空白字符直到再次遇到空白。当scanf()把字符串放进指定数组中时，他会在字符序列的末尾加上'\0'，让数组中的内容称为一个C字符串
         3. 格式字符串中的普通字符：除空格字符外的普通字符必须与输入字符串严格匹配。如`scanf("%d,%d"，&a, &b)`意味着必须使用逗号
         4. scanf()的返回值：返回成功读取的项数，如果输入错误返回0，如果退出则返回EOF
   4. ### getchar()和putchar()
      1. 这两个函数只用于处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁，同时它们也不需要转换说明。
      2. ctype.h系列的字符函数

4. ## 运算符、表达式和语句
   1. ### 操作符
      1. 算术操作符：+-*/%
      2. 移位操作符：<< >>
         1. 逻辑移位
         2. 算数移位
      3. 位操作符：&|^
      4. 赋值操作符：= -= += *= /= 
      5. 单目操作符
      6. 关系操作符：> == != <
      7. 逻辑操作符：&& ||
      8. 条件操作符：exp1 ? exp2 : exp3
      9.  逗号表达式
      10. 下标引用、函数调用和结构成员
   2. ### 优先级
      1. ();->;++ --;* &;sizeof;加减乘除取余;<< >>;> < == != && ||;= += -= *= /=;
      2. 只有对所有编译器唯一确定运算顺序的运算才是正确的，在一个语句里用太多的自加自减会引起混乱。仅仅有操作符的优先级和结合性是无法唯一确定某些表达式的计算路径的
   3. ### 类型转换
      1. 自动类型转换
         1. 算术转换：类型转换从高到低顺序：long double, double, float, unsignedlong long, long long, unsigned long, long, unsigned int, int。算术转换时内存中二进制表示的值没有变，知识计算机解释值的方式变了
         2. 升级和降级 Promotion and demotion
            `double x=2; double y=x+3/2 `这里输出为3.000000
         3. 整型提升：当传参和计算时，char和short被转换为int，float转换为double：整型提升是按照变量的数据类型的符号位来提升的
            1. 有符号数
               1. 负数的整型提升：高位补充1
               2. 正数的整型提升：高位补充0
            2. 无符号数：高位补充0
      2. 强制类型转换 (int)a
5. ## 循环
   1. ### while循环是最早出现的
   2. ### for循环是后期产生的，将控制变量的初始化、条件判断、循环条件的调整集成到一起
   3. ### do while循环至少进行一次，使用场景有限
6. ## 分支和跳转
   1. ### if语句：0表示假，其余为真（包括负数）
      1. 多重选择 else if
      2. else与if的配对：else与离它最近的if配对，除非最近的if被花括号括起来了
      3. 多层嵌套的if语句
   2. ### 循环辅助
      1. continue：执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。若continue语句在嵌套循环内，则只会影响包含该语句的内层循环
      2. break：终止（跳出）当前循环，并继续执行下一阶段的代码。若是在嵌套循环内，break只会跳出当前层循环，一个break只能跳一层
   3. ### 多重选择：switch和break
      1. 程序根据整形表达值跳转至相应得case标签处，然后执行剩余的**所有语句**，除非遇到break语句跳出。表达式和case标签都必须是**整数值**（包括char），标签必须是常量或完全由常量组陈给的表达式。如果没有case标签与表达式匹配，控制则转至标有default的语句（如果有的话）；否则将转至执行紧跟在switch语句后面的语句
      2. switch语句中的break：如果不使用break将无法实现分支，因为如果不用break将会顺序执行
      3. default：如果所有的case标签都不匹配，那么将会跳过这个switch结构，因此最好写上一个default语句。
      ```c
      #include <stdio.h>
      int main()
      {
         int day = 0;
         switch(day)
         {
            default:
               printf("Wrong Input!\n");
               break;
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
               printf("Workday.\n");
               break;
            case 6:
            case 7:
               printf("Weekend.\n");
               break;
         }
         return 0;
      }
      ```
      1. 如果表达式是浮点型或者范围，那么就不能使用switch，用if else结构方便
   4. ### goto语句：尽量避免使用goto语句，会扰乱程序的执行，在跳出深层循环嵌套时可以使用
7. ## 字符输入/输出和输入验证
   1. ### 单字符I/O：getchar()和putchar()
   2. ### 缓冲区 Buffer
      1. 为什么要有缓冲区？把若干字符作为一个块进行传输比逐个发送这些字符节约时间。如果打错字符也可以修改，这样按下回车时，传输的就是确认过的输入。但也不是所有的输入都要求有缓冲IO，比如游戏等交互程序就要求快速响应的无缓冲IO。C语言标准规定了把缓冲IO作为标准的原因是一些计算器不允许无缓冲输入。
      2. 分类
         1. 完全缓冲IO
         2. 行缓冲IO
   3. ### 结束键盘输入
      1. C语言有很多直接操作文件系统的库函数。从底层来看，C可以直接创建并调用操作系统的函数称为底层IO（low-level IO），但因为计算机系统的多样性，所以不可能为这些底层IO函数创建标准库。因此在较高层面上C可以通过标准IO包来处理文件，这涉及创建用于处理文件的标准模型和一套标准IO函数，在这一层面上，具体的C只需要四线负责处理不同系统的差异，以便用户使用统一的界面
      2. C程序处理的是流而不是直接处理文件。流 Stream是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。因此可以用处理文件的形式来处理键盘输入。程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C的输入函数内置了文件结尾检测器
      3. 大部分操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾，getchar()读取文件检测到结尾时返回一个特殊的值，即EOF（End of File），实际上EOF被预处理为-1
8. ## 函数
9. ## 数组和指针
    1.  ### 一维数组
        1. 初始化：`int char[] = {0};` 
            1.  当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化化0，即如果部分初始化数组，剩余的元素就会被初始化为0；而如果不初始化数组，数组元素和未初始化的普通变量一样，其中存储的都是垃圾值。**[]中的数字如果省略，那么编译器自动匹配数组大小和初始化列表中的项数。**
            2.  C不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值
        2. 数组边界：使用数组时不允许下标越界，越界结果根据不同编译器表现不同
        3. 数组元素编号从0开始
    2.  ### 多维数组（以二维数组为例）
        1.  `test[3][2]`的意思是一个三行二列的二维数组，`test[0]`的意思是第一行首元素的地址
        2.  初始化：`int test[3][2] = {{1,2,3,4,5}, {6,7,8,9,10}}`行的个数可以省略，但列的个数一定不能省，因为内存中是将二位数字从第一行到最后一行以大端或者小端逐次排放的，如果缺少列的个数将无法确定排放方式
    3. ### 指针和数组
       1. **数组名是数组首元素的地址**，即`arr == &arr[0];`
       2. 指针运算：指针+1后的地址是下一个元素的地址，而不是下一个字节的地址，即`arr+1 = &arr[1]`。这也是为什么必须声明指针类型的原因之一，内存中存储不同类型的数据的方式不同，每一个单位的数据也就有不一样的地址，因此也就有其所对应的指针类型。只知道开头地址是不够的，必须要知道指针的类型
    4. ### 函数、数组和指针
       1. 使用指针形参
       2. 指针表示法和数组表示法
    5. ### 保护数组中的数据
        1.  有时需要把数组设置为只读，这样程序只能从数组中检索值而不能修改数组。提高程序的鲁棒性。
    6. ### 指针和多维数组
    7. ### 变长数组 Variable-Length Array
    8. ### 复合字面量 Compound literal
10. ## 字符串和字符串函数
   1. ### 表示字符串和字符串I/O
   2. ### 字符串输入
   3. ### 字符串输出
   4. ### 字符串函数
      1. strlen()函数
      ```c
      int my_strlen(const char* str) //const增加鲁棒性
      //因为这个函数不会修改str
      {
         assert(str != NULL) //防范野指针
         int count;
         while (*str++ != '\0')
         {
            count++;
         }
         return count;
      }
      ```
      1. strcat()函数
      2. strncat()函数
      3. strcmp()函数
      4. strcpy()和strncpy()函数
         1. strcpy()
         ```c
         char* my_strcpy(char* dest, const char* src)
         {
            assert(dest && src)
            char* ret = dest //保存起始位置
            while(*dest++ = *src++)
            {
               ;
            }
            return ret
         }
         ```
         1. 更谨慎的选择 strncpy()
      5. sprintf()函数
      6. 其他字符串函数
11. ## 存储类别、连接和内存管理
   5. ### 存储类别
      1. 作用域 Scope
         1. 全局作用域 Global scope：整个c文件中都可使用
         2. 局部作用域/文件作用域 Local scope：定义在函数体中，或者在for、while、do while和if语言的代码块中，一但变量离开当前定义的块时，其内存会被释放，局部变量被销毁。外部函数不能使用内部函数定义的变量，而内部函数可以外部函数的变量，即内部函数变量的作用域包含了外部函数
         3. 在全局作用域和局部作用域种有相同名字的变量时，采用**就近原则，其有不同的地址**。如以下的代码输出结果为1：test中的a为局部变量，在test函数结束后被销毁，打印的a为全局变量a
        ```c
        #include <stdio.h>

        int a = 1;
        void test()
        {
            int a = 2;
            a += 1;
        }

        int main()
        {
            test();
            printf("%d\n",a);
            return 0;
        }
        ```
      2. 链接
      3. 存储器
      4. 自动变量