# *存储类别、连接和内存管理*

## *存储类别*

C语言提供了多种不同的模型或存储类别 storge class 在内存中存储数据。从硬件来看，将数据占用的内存称为对象 object，其用存储期 storage duration来描述；从软件来看，程序需要一种方法来访问对象，即声明变量，其用作用域 scope和链接 linkage来描述标识符。

### 作用域 Scope

1. 局部作用域/块作用域 Local scope：块是用一对花括号括起来的代码区域，例如整个函数体，或者在for、while、do while和if语言的代码块中，一但变量离开当前定义的块时，其内存会被释放，局部变量被销毁。外部函数不能使用内部函数定义的变量，而内部函数可以使用外部函数的变量，即内部函数变量的作用域包含了外部函数
2. 函数作用域 Function scope只用于goto语句中的标签
3. 函数原型作用域 Function prototype scope用于函数原型中的形参名（变量名）：函数圆形作用域的范围是从形参定义处到原型声明结束，这意味着在除变长数组外的函数声明中，形参的变量名无关紧要（因为该作用域不会影响到块作用域），只有形参的数据类型有用
4. 全局作用域/文件作用域 Global scope：定义在函数外面，整个c文件中都可使用
5. 在全局作用域和局部作用域中有相同名字的变量时，**采用就近原则，其有不同的地址**。如以下的代码输出结果为1：test中的a为局部变量，在test函数结束后被销毁，打印的a为全局变量a

    ```c
    #include <stdio.h>

    int a = 1;
    void test()
    {
        int a = 2;
        a += 1;
    }

    int main()
    {
        test();
        printf("%d\n",a);
        return 0;
    }
    ```

### 链接

1. C变量有3种链接属性：外部链接、内部链接或无链接
2. 具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量，这意味着这些变量仅属于定义他们的块、函数或原型
3. 具有文件作用域的变量可以是外部链接或内部链接。
    * 一个C文件称为一个翻译单元
    * 内部链接/文件作用域：仅限于一个翻译单元
    * 外部链接/全局作用域或程序作用域：延伸至其他翻译单元
### 存储期：描述了内存中存储的对象可以被访问的生存期
1. 自动变量
    * 声明在块或函数头中的任何变量都属于自动存储类别，其具有自动存储期、块作用域和无链接性
    * 没有{}的块（C99）
    * 自动变量不会初始化，除非显式初始化它。若没有初始化则分配一个随机值
    * 如果内层块中声明的变量与外层块中的变量同名时，内层块会隐藏外层块的定义，即**采用就近原则，其有不同的地址**
2. 寄存器变量：寄存器变量也是自动变量，但其存储在寄存器中，无法获取其地址
3. 静态变量：静态变量和外部变量在程序载入内存时已执行完毕，在程序结束后不会被销毁，保留在静态区中，如字符串常数
    * 块作用域的静态变量：在块中定义时用static类别说明符
    * 外部链接的静态变量/外部变量
    * 外部链接的静态变量又称为外部变量 external variable，其具有文件作用域、外部链接和静态存储期
    * 把变量的定义性声明 defining declaration 放在所有函数外面便创建了外部变量
    * 外部变量是可以被所有C文件访问的，若要使用的外部变量被定义在其他C文件中，要使用extern类别说明符再次声明
    * 外部变量如果没有初始化会被自动初始化为0
    * 内部链接的静态变量
    * 具有文件作用域、内部连接和静态存储器
    * 需要使用static修饰，只能在同一个文件中被访问，在其他文件中无法使用extern访问

    ```c
    int traveler = 5; //定义式声明 defining declaration
    static int stayhome = 1;

    void test(void)
    {
        extern traveler x; //引用式声明 referencing declaration
        //使用定义在其他C文件中的外部变量，并不是该文件中的外部变量
        //...
    }
    ```

4. 多文件：只有当程序由多个翻译单元组成时，才能体现出内部链接和外部链接的重要性
    * C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享
    * 如果外部变量定义在一个文件中，那么其他文件在使用该变量必须用extern进行引用声明。也就是说在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern接收前不可以使用该外部变量
5. 存储类别和函数：和变量相同有外部函数（默认）和静态函数，除非用static声明，否则默认为extern。C99新增了内联函数
6. 存储类别的选择

存储类别|存储期|作用域|链接|声明方式
:-|:-|:-|:-|:-
自动变量|自动|块|无|块内
寄存器变量|自动|块|无|块内，使用关键字 register
静态外部链接|静态|文件|外部|所有函数外
静态内部链接|静态|文件|内部|所有函数外，使用关键字static
静态无连接|静态|块|无|块内，使用关键字static

## *随机数和静态变量*

## *掷骰子*

## *动态内存开辟*

### 为什么存在动态内存分配

我们已经掌握的内存开辟方式有

```c
int val = 20; //在栈空间上开辟四个字节
char arr[10] = {0}; //在栈空间上开辟10个字节的连续空间
```

但是上述的空间开辟的方式有两个特点：

* 空间开辟大小是固定的
* 数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配
但是对于空间的需求不仅仅是上述的情况，很多时候我们到底需要多少空间，是随着程序的运行逐渐变化的，因此静态的空间开辟就不能满足需要了，需要进行动态内存开辟

### 动态内存分配函数

1. malloc()和free()

    ```c
    #include <stdlib.h>
    void* malloc (size_t size);
    void free (void* ptr);
    ```

    malloc()向内存申请一块连续可用的匿名空间，并返回指向这块空间的指针
    * 若开辟成功，返回开辟成功空间的地址
    * 若开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。否则如果开辟失败而不知道，会产生对野指针解引用等问题
    * 返回值的类型是void*，所以mallloc()并不知道开辟空间的类型，具体在使用的时候使用者自己进行强制转换

        ```c
        int* ptr = (int*) malloc(40); //开辟40个字节的int型空间
        int* p = ptr; //free()要从开辟空间的起始地址开始，所以不能直接用ptr
        if (p == NULL)) //检查动态内存空间开辟是否成功
        {
        perror("malloc");
        return 1;
        }

        int i = 0;
        for(i=0; i<10; i++)
        {
        *p = i;
        p++;
        }

        free(ptr); //释放空间
        ptr = NULL; //ptr释放后变成野指针，置空
        ```

    * 若参数size未定，则malloc()的行为是标准未定义的，由编译器决定

    free()用来释放回收动态开辟的内存
    * 若参数ptr指向的空间不是动态开辟的，则free()的行为未定义
    * 若参数ptr是NULL，则函数什么事都不做
2. calloc

    ```c
    void* calloc (size_t num, size_t size);
    ```

    calloc()的功能是为num个大小为size的元素开辟一块空间，并且把空间中的每个字节初始化为0；其与malloc()的区别只在于calloc()会在返回地址之前把申请的空间的每个字节初始化为全0
3. realloc

    realloc()让动态内存开辟更加灵活。有时我们发现过去申请的空间太小了，有时我们又觉得太大了，那为了合理的使用内存，我们一定会对内存的大小进行灵活的调整。realloc()就可以做到对动态开辟内存大小的调整

    ```c
    void* realloc (void* ptr, size_t size);
    ```

        * ptr为要调整的内存地址
        * size为调整之后新的内存空间的大小
        * 若开辟成功，则返回新空间的地址，否则返回NULL
        * 扩容时有两种情况
        * 原有空间之后有足够大的空间：直接扩展内存，原空间数据存放的数据不变
        * 原有空间之后的空间已经被用掉了，没有足够大的空间用来扩容
            * 在堆空间上找一个新的可用连续匿名空间，返回其地址
            * 拷贝原空间的数据到扩容的地址上
            * free原空间

    ```c
    int* p = (int*)malloc(40);

    if (p == NULL)
    {
        perror("malloc");
        return 1;
    }

    int* ptr = (int*)realloc(p, 80); //将空间扩容为存储80字节的int数据的空间
    if (ptr != NULL)
    {
        p = ptr;
    }

    free(p);
    p = NULL;
    ```

### 常见的动态内存错误

1. 对NULL指针的解引用操作

    ```c
    void test()
    {
        int* p = (int*)malloc(INT_MAX); //需要开辟的内存过大，malloc开辟失败，返回NULL
        *p = 20;
        free(p);
    }
    ```

    解决办法：对malloc函数的返回值进行判断后再使用
2. 对动态内存开辟空间的越界访问

    ```c
    void test()
    {
        int i = 0;
        int* p = (int*)malloc(10 * sizeof(int));
        if (p == NULL)
        {
        exit(EXIT_FAILURE);
        }
        
        for (i=0; i<=10; i++) //i<=10 访问11个int，造成越界
        {
        *(p+i) = i;
        }

        free(p);
    }
    ```

3. 对非动态开辟内存使用free()

    ```c
    int a = 10;
    int* p = &a;
    free(p);
    ```

4. 使用free()释放一块动态内存的一部分

    ```c
    int* p = (int*)malloc(40);
    p++;
    free(p);
    ```

5. 对同一块动态内存多次释放

    ```c
    int* p = (int*)malloc(40);
    free(p);
    free(p);
    ```

6. 动态开辟内存忘记释放，造成内存泄漏 Memory leak

    ```c
    void test()
    {
        int* p = (int*)mallloc(40);
        if (p != NULL)
        {
        *p = 20;
        }
    }

    int main()
    {
        test();
        while(1);
        return 1; //没有free()
    }
    ```

### 柔性数组/动态数组/伸缩性数组（C99） Flexible array

1. 柔性数组的特点
    1. 结构中的柔性数组成员前面必须至少有一个其他成员，且柔性数组一定要放在结构体最后
    2. sizeof返回的这种结构大小不包括柔性数组的内存
    3. 包含柔性数组成员的结构用malloc()进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小

    ```c
    #include <stdio.h> 
    #include <stdlib.h>

    struct S
    {
        int num;
        int arr[];
    }

    int main()
    {
        //柔性数组用malloc()初始化
        struct S* ps = (struct S*)malloc(sizeof(struct S) + 40);
        if (ps == NULL)
        {
        perror("malloc\n");
        return 1;
        }
        ps->num = 100;

        int i = 0;
        for(i=0; i<10; i++)
        {
        ps->arr[i] = i;
        }

        for(i=0; i<10; i++)
        {
        printf("%d ", ps->arr[i]);
        }

        //realloc()扩容
        struct S* ptr = (struct S*)realloc(ps, (sizeof(struct S) + 80));
        if (ptr == NULL)
        {
        perror("realloc\n");
        return 1;
        }
        else
        ps = ptr;

        //释放
        free(ps);
        ps = NULL;

        return 0;
    }
    ```

2. 柔性数组的使用
3. 柔性数组的优势