# *字符输入/输出和输入验证*

## *单字符I/O：getchar()和putchar()*

getchar()和putchar()每次只处理一个字符。这很方便计算机处理字符数据，且这是绝大多数文本处理程序所用的核心方法。

```c
//连续输入
char ch;
while ((ch = getchar()) != EOF)
   putchar(ch);

//或者下面这种写法
while (~(ch = getchar()))
   putchar(ch);
```

## *缓冲区 Buffer*

1. 为什么要有缓冲区？把若干字符作为一个块进行传输比逐个发送这些字符节约时间。如果打错字符也可以修改，这样按下回车时，传输的就是确认过的输入。但也不是所有的输入都要求有缓冲IO，比如游戏等交互程序就要求快速响应的无缓冲IO。C语言标准规定了把缓冲IO作为标准的原因是一些计算器不允许无缓冲输入。
2. 分类
   1. 完全缓冲IO：当缓冲区被填满时才刷新缓冲区
   2. 行缓冲IO：当出现换行符时刷新缓冲输入

## *结束键盘输入*

1. 文件、流和键盘输入
   1. C语言有很多直接操作文件系统的库函数。从底层来看，C可以直接创建并调用操作系统的函数称为底层IO（low-level IO），但因为计算机系统的多样性，所以不可能为这些底层IO函数创建标准库。因此在较高层面上C可以通过标准IO包来处理文件，这涉及创建用于处理文件的标准模型和一套标准IO函数，在这一层面上，具体的C只需要四线负责处理不同系统的差异，以便用户使用统一的界面
   2. C程序处理的是流而不是直接处理文件。**流 Stream是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示**打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。因此可以用处理文件的形式来处理键盘输入。程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C的输入函数内置了文件结尾检测器
2. 文件结尾
   1. 大部分操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾，getchar()读取文件检测到结尾时返回一个特殊的值，即EOF（End of File），实际上EOF被预处理为-1

## *重定向和文件*

## *创建更友好的用户界面*

1. 使用缓冲输入：使用 while((ch=getchar())!='\n')吸收换行符
2. 混合数值和字符输入

   ```c
   #include <stdio.h>
   void display(char cr, int lines, int width)
   {

   }
   ```

## *输入验证*

1. 分析程序
2. 输入流和数字

## *菜单浏览*

1. 任务
2. 使执行更顺利
3. 混合字符和数值输入