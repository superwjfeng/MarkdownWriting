## *结构和其他数据形式 Struct*

### 结构的声明

1. 结构声明与初始化

   ```c
   struct tag
   {
      int a; //结构布局
      char b;
      float c;
      int* ptr;
   }a, *pa; //结构变量
   ```

   1. 结构体变量的初始化：```struct tag A = {3, 'a', 3.50, ptr}```
   2. 访问结构成员：使用.运算符 ```tag.a; tag.b; tag.c; tag.ptr```
   3. 匿名结构体：不写tag名，只能用一次
2. 用->操作符访问结构体指针：```struct tag * A; A->a = 5;```

3. 结构体内存对齐
   1. 对齐规则
      * 第一个成员在于结构体变量偏移量为0的地址处
      * 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处
        * 对齐数=编译器默认对齐数与结构体成员大小的较小值
        * VS默认为8，Linux中则没有对齐数，结构体成员自身的大小就是对齐数
      * 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍
      * 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍出，结构体的整体大小就是所有最大对其书（含嵌套结构体的对齐数）的整数倍
   2. 为什么存在内存对齐
      * 平台原因（移植原因）：不是所有的硬件平台都能访问任意地址上的任意数据的，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常
      * 性能原因：数据结构（尤其是栈）应该尽可能地在自然边界上对齐。原因是为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次
   3. 修改默认对齐数：```#pragma pack()```

### 链式访问

### 联合体 Union

### 枚举 Enum