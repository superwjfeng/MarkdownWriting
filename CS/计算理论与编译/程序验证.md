https://zhuanlan.zhihu.com/p/295230186

# 程序验证介绍

## *intro*

### 定义

程序验证 Program/Software Verification 旨在**自动化**地证明程序的正确性，即程序在运行的过程中不会出错，并且程序的功能可以被满足。 程序验证的优点是能够自动化地进行程序的正确性证明。 但其缺点也很显著，比如

* 对需要使用复杂逻辑描述的功能属性不友好，一般用于证明一些低阶属性，比如程序中不存在除0错误、指针free后使用、数组越界或缓冲区溢出等问题
* 程序验证一般也依赖于**约束求解**，所以同样难以直接大规模地应用。 但随着验证算法和约束求解引擎的不断进步，程序验证的可用性将变得越来越好

> **程序验证**这一名词的含义其实非常广泛。 一般化地说，凡是用于**证明程序正确无误**的方法，都可以被称为程序验证。 因此，定理证明可以称为程序验证，建立程序的抽象模型进行**模型检测**也可以称为程序验证。 而本文所介绍的「自动化程序验证」，更加贴切的称呼应该是**软件模型检测**（Software Model Checking）。 在后续的篇章中，我们仍将这一套方法称为「程序验证」。

### 方法简介

程序验证中的动态验证就是各种测试，这个在 *EIST软件工程.md* 和 *测试.md* 中都有详细的介绍了。下面介绍的都是静态分析方法

常规的静态分析 Static Analysis 方法比较轻量级，适用于大规模代码，但比较大的问题是较高比例的**误报** False Positive。 所以静态分析报出的结果，需要逐一人工排查，从而导致耗费大量的人力资源。 比较有名的静态分析引擎如Coverity，目前已经实现较大规模商业化应用

* 符号执行 Symbolic Execution可以看作是更加准确的测试方法，它通过符号值来静态“执行”程序，积累**路径条件** Path Condition，直到到达目标位置，再对路径条件进行**约束求解** Constraint Solving，判断目标位置的**可达性**Reachability。 由于需要使用约束求解，而且对循环不友好，所以符号执行方法比较难以大规模应用。 经典的符号执行工具如[KLEE](https://link.zhihu.com/?target=https%3A//klee.github.io)，已被加入LLVM的官方项目列表中
* 定理证明 Theorem Proving 方法是使用高阶逻辑 High Order Logic, HOL 对程序及其需要满足的性质进行建模描述，然后使用机器辅助证明的方法，一步一步证明程序能够满足要求的性质。 定理证明方法主要的缺陷是自动化程度较低，需要大量的专业人力参与，编写证明代码，对软件的快速更新迭代不友好。 辅助定理证明的典型工具是[Coq](https://link.zhihu.com/?target=https%3A//coq.inria.fr)，于2014年获得ACM软件系统奖。 此外，值得一提的是，基于定理证明方法验证的C语言编译工具链[CompCert](https://link.zhihu.com/?target=https%3A//compcert.inria.fr/)，于2021年获得ACM软件系统奖
* 模型检测 Model Checking 是一种经典的形式化分析方法。 它通过构造软件系统的抽象模型，来检测其是否满足要求的性质。 模型检测方法的缺点是系统模型的建立需要领域专家的参与。 寻找恰当的抽象层次，从而足以证明系统的特定属性，是模型检测的一大难点。 过分的抽象将导致属性无法证明；而不足的抽象又将导致太多属性无关的冗余细节，从而引发状态爆炸，无法在合理的时间内得到结果。 经典的模型检测工具有[NuSMV](https://link.zhihu.com/?target=https%3A//nusmv.fbk.eu)、[SPIN](https://link.zhihu.com/?target=http%3A//spinroot.com/spin)等等。 其中，SPIN于2002年获得ACM软件系统奖
* 基于模型驱动开发 Model Driven Development 的B方法，以及其对应的工具链[Event B](https://link.zhihu.com/?target=http%3A//www.event-b.org)

## *示例*

# 理论基础

## *循环不变式*

## *霍尔逻辑*

霍尔逻辑 Floyd-Hoare Logic

$\left\{P\right\}c\left\{Q\right\}$

# k归纳法