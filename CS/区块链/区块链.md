# 比特币

## *数据结构*

区块链重点使用的哈希需要具备三个性质：collision free、hiding 和 puzzle friendly，这部分可以看 *数据结构与算法.md* 的哈希部分

### 区块

一个区块 block 可以分为块头 block header 和块身 block body（具体的交易内容）

* 全节点含有完整信息，既保存block header，也保存block body
* 轻节点只保存一个block header。比如说手机上的比特币钱包

### 区块链

区块链是一个用哈希指针形成的链表，但并不是指Linux内核中用到的哈希链表 hlist（哈希桶）

和普通指针指向某一个内存地址不同，哈希指针指向的是把前面的整个结构体（包括前面结构体的另外的哈希指针）进行哈希计算后得到的哈希指。可以实现 tamper-evident log 来防篡改，这是因为对每一个结构体的修改都是牵一发而动全身的，所以只要记住最后一个哈希指针，就可以判断前面任意区块链的内容有没有被修改过，普通链表则没有检测修改的功能

<img src="区块链结构.png">

区块链中的第一个区块称为创世纪块 genesis block，最后一个区块称为最近块 most recent block

## *Merkle Tree*

### Merkle Tree的结构

<img src="MerkleTree.drawio.png" width="60%">

Merkle Tree 中用哈希指针代替普通指针，效果和区块链一样，都是牵一发而动全身的效果

* 最底层的L1、L2等是 data blocks，它们可以代表一笔笔的交易内容 transaction
* 而上面的则都是哈希指针，根节点称为root hash或top hash

### Merkle proof

现在要解决的问题是：如何证明一个轻节点属于区块链？使用 Proof of membership/Proof of inclusion ***O(logN)***

找到保存在block header中的Merkle Root，然后一直往上溯源验证， 从data block到root的路径就被称为 Merkle Proof

<img src="MerkleProof.png" width="70%">

假设某个轻节点想要知道上图中的黄色交易是否包含在轻节点所在区块的Merkle Tree中，但是轻节点只有Merkle Root

1. 先计算出待验证交易的哈希值
2. 这个轻节点会向某个全节点发出请求，请求一个能够证明待证明交易被包含在某个全节点中的 Merkle Proof。全节点在收到请求后，会把红色的哈希值发给轻节点
3. 从待证明交易往上不断溯源，如果最终root的hash和轻节点保存的Merkle Root一致就证明成功

由于collision resistence的性质，在实际中不可能人为制造Merkle Proof

另外后面的节点算出前面节点的hash值作为hash指针放在当前节点会影响更后面的节点内容，有环的话就会发生先有鸡还是先有蛋的问题

无法证明proof of non-membership，因为要验证所有的叶节点来证明不在Merkle Tree中，此时的复杂度是线性的。如果要证明的话必须是Sorted Merkle Tree

## *共识协议*

Double spending attack 花两次攻击/双花攻击。数字货币所面临的一个主要挑战就是如何应对双花攻击

数字货币本质上就是一个文件

电子支付是过中心化的，每次交易都得到中心（央行）查询和提交，虽然在实践中其正确性和安全性已经得到验证，但过程会比较复杂。去中心化思路就是将中心的验证职能分散给每一个用户

CreateCoin 铸币权

比特币系统中每笔交易都包含了输入和输出两部分，输入部分



## *挖矿*

挖矿是一个发放货币的过程

# 以太坊 Ethereu