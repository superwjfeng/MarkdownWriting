# λ Calculus

[认知科学家写给小白的Lambda演算 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/30510749)

[Palmström: The Lambda Calculus for Absolute Dummies (like myself) (palmstroem.blogspot.com)](https://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html)

[Learn X in Y Minutes: Scenic Programming Language Tours](https://learnxinyminutes.com/docs/zh-cn/lambda-calculus-cn/)

## *λ Calculus的表示*

### λ Calculus 的历史

λ calculus, λ演算的发明者为 Alonzo Church，它和由 Alan Turing 所提出的图灵机模型都是受到 David Hilbert 的影响而提出的。Hilbert 鼓励数学家们去将证明过程纯机械化，这样机器就可以通过形式语言推理出大量定理（是不是有点像人工智能，机器自己把定理枚举了

所谓机械论就是一种认为自然界整体就是一个复杂的机器或工艺品，其不同组成部分间并没有内在联系的哲学

后来可以证明λ演算等价于图灵机，即 Church-Turing Thesis。即λ演算是图灵完备的，这是一个可以用于模拟任何图灵机的通用模型

### Overview

λ演算由变量 variables、函数 functions 和应用 applications 组成

| 名称 | 语法                 | 示例      | 解释                                                     |
| ---- | -------------------- | --------- | -------------------------------------------------------- |
| 变量 | `<变量名>`           | x         | 一个名为x的变量                                          |
| 函数 | `λ<参数>.<函数体>`   | `λx.x`    | 一个以 `x`（前者）为参数、以 `x`（后者）为函数体的函数   |
| 应用 | `<函数><变量或函数>` | `(λx.x)a` | 以 `a` 为参数调用函数 `λx.x`，将函数体中所有的x都替换为a |

### 表达式

<img src="lambda表达式.webp" width="40%">

在λ演算中，一行符号被叫做表达式。比如说上面这个表达式：$(\lambda x.\lambda y)(ab)$。表达式只包含以下符号：

- λ和点 `.` 用以描述函数。函数由λ和变量开头，跟上一个点，然后是表达式。Church之所以使用λ完全是一个巧合，实际上λ没有任何特别的含义，它只是说函数由此开始。在λ后面，在点之前的字母，被称作头部 head，点后面的表达式，被称作体 body 部
- 单个字母（abcd...)，被称作变量。一个表达式可以是单个字母，或多个字母。一般的，我们可以把两个表达式写在一起组成一个新的表达式
- 括号 `()`。括号表明表达式被括起来的部分是一个整体（就像句子中的括号表示这部分是一个整体）。当我们没有括号时，我们从左到右分析表达式

## *规约*

### 函数解析

<img src="解析lambda表达式.png" width="30%">

在函数后边又跟了一个表达式时，它可以被解析 resolve。解析过程就是将头部一个变量去掉，然后将它所有在体部的出现的这个变量替换成写在函数后边跟着的表达式

这个解析求值当的操作是通过β-归约, β-Reduction完成的, 它本质上是词法层面上的替换

在头部中提到的变量被称作**约束变量 bound variables**，没有提到的称作**自由变量 free variables**。因为函数可以是其他函数的一部分，所以一个变量可以同时是约束变量，又是自由变量

```
(λx.x)a ----> a
(λx.y)a ----> y # 函数体内没有x，所以a没有地方替换x，结果为y
```

### Currying

尽管λ演算传统上仅支持单个参数的函数，但我们可以通过Currying 柯里化的技巧创建多个参数的函数

Currying 是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术

在理论计算机科学中，柯里化提供了在简单的理论模型中，比如：只接受一个单一参数的λ演算中，研究带有多个参数的函数的方式

带多个参数的函数其实就是高阶函数，也就是函数里面又套了函数，比如说下面的

```
(λx.(λy.x))a <--------> (λxy).x(a) = λy.a # 等价
```

 规则：从左向右替换，每替换一次，就消去head中最左边的变量

## *应用*

### 布尔运算

λ演算中只有函数，没有布尔值、数字或者其他任何传统的非函数数据类型

* 布尔值中的True和False是如下定义的

  ```
  True: λx.λy.x(any_value) <--------> λ(xy).x(any_value) <--------> λ(y).(any_value)
  False: λx.λy.y(any_value) <--------> λ(xy).y(any_value) <--------> λ(y).(null)
  ```

  解释一下上面的False定义：当表达式被解析，它会把第一个表达式丢掉，然后第二个原封不动。它的约束变量x会被空字符串替换（因为它不在体中出现），当然参数y也就没有用了，因为它无人可接收。所以最后留下一个y

* NOT

* AND

* OR

### 条件

### 数字

尽管 lambda 演算中没有数字, 我们还可以用[邱奇编码](https://zh.wikipedia.org/wiki/邱奇编码)([Church numerals](https://en.wikipedia.org/wiki/Church_encoding))将数字嵌入到 lambda 演算中

上面已经定义的True也就是1，可以继续嵌套表达式来定义其他的自然数，比如说定义2

```
λ(xy).x(x(any_value)) <--------> 2
```

也就是说嵌套几次最后得到的自然数就是多少
$$
n=\lambda\underbrace{(f(f(\cdots f(n))))}_{n}
$$

### 加减乘除

## *不动点*

# 函数式编程

函数式编程 Functional Programming, FP 是一种编程范式，它将计算视为数学函数的求值，并避免了数据的状态改变以及可变数据。在函数式编程中，函数是一等公民 first-class citizens，这意味着函数可以作为参数传递给其他函数，也可以作为结果返回，还可以被赋值给变量

λ演算是函数式编程最重要的基础。而且λ演算的函数可以接受函数作为输入的参数和输出的返回值

## *函数式编程的特性*

最重要的特性莫过于函数在FP中被当作一等公民（first-class citizens）。这意味着函数可以被应用，也可以被当作数据。更具体来说函数可以作为参数传递给其他函数，也可以作为其他函数的返回结果

* 纯函数 Pure Functions 是函数式编程的核心概念之一。一个纯函数具有以下两个主要特性：
  * 输出只依赖于输入：给定相同的输入，纯函数总是返回相同的输出
  * 无副作用：执行函数不会对系统的状态产生影响，即不会修改任何外部状态或数据
* 不可变性 Immutability：在函数式编程中，一旦数据被创建，它就不能被改变。所有的数据结构都是不可变的。如果需要修改某个数据结构，需要创建一个新的数据结构来代替原来的版本
* 无副作用 Side Effect：的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果
* 引用透明 Referential transparency：指的是函数的运行不依赖于外部变量或"状态"，只依赖于输入的参数，任何时候只要参数相同，引用函数所得到的返回值总是相同的
* 高阶函数 Higher-Order Functions：大量使用高阶函数：变量存储、闭包应用、函数高度可组合
* 函数组合 Function Composition：函数组合涉及将多个函数组合成单个函数，这个新函数继承了组合中的每个函数的行为。这促进了代码重用和模块化
* 惰性评估 Lazy Evaluation：惰性评估指的是表达式直到其值真正需要时才被计算。这允许程序构造潜在无限的数据结构，如无限列表和流
* 递归 Recursion：由于不可变性，函数式语言中经常使用递归来实现循环或遍历数据结构。大多数函数式语言提供优化技术（如尾递归优化）来使递归操作更加高效
* 类型系统 Type Systems：很多函数式编程语言（如Haskell）拥有非常强大的类型系统，包含类型推断、代数数据类型等特性，它们可以帮助捕获编程错误并在编译时期进行更多的优化

函数式编程语言的例子包括但不限于Haskell、Erlang、Clojure、F#和Scala。现代多范式语言如JavaScript、Python、Ruby和C#也支持函数式编程的一些特性。

函数式编程的优势在于代码通常更简洁、更易于理解，并且因为其无副作用和不可变性的特点，它能极大地降低并发编程中出现问题的风险。缺点可能包括对于习惯了命令式编程的开发者来说有一定的学习曲线，以及与基于命令式编程的语言相比，在某些情况下性能上的差异

## *Monad*

# OCaml

OCaml是一种功能强大的编程语言，它结合了函数式编程 Functional Programming、命令式编程 Imperative Programming 和面向对象编程 Object-Oriented Programming的特点。OCaml诞生于1996年，由INRIA（法国国家信息与自动化研究所）开发，是Caml语言家族中的一个重要成员

## *安装*

### 使用opam进行安装

opam, OCaml Package Manager 是OCaml的包管理器

首先安装opam

```cmd
$ sh <(curl -sL \
https://raw.githubusercontent.com/ocaml/opam/master/shell/install.sh)
```

或者也可以自己去网站上安装 https://opam.ocaml.org/doc/Install.html.

接下来安装ocaml解释器和配置环境

```cmd
$ opam init --bare
$ opam switch create 5.1.1
$ eval $(opam env)
$ opam install ocaml-lsp-server dune utop mparser \
ocamlformat ounit2 qcheck
```

最后安装一下VS Code的OCaml Platform extension

## *表达式*

### 基本表达式

```ocaml
# 3+4;;
- : int = 7
```

* At `#`, the interpreter is waiting for input
* The `;;` causes evaluation of the given input
* The result is computed and returned together with its type

### 预定义的常数和操作符

| Type   | Constants: examples | Operators     |
| ------ | ------------------- | ------------- |
| int    | 0, 3, -7            | `+ - * / mod` |
| float  | -3.0, 7.0           | `+. -. .* /.` |
| bool   | ture, false         | `not || &&`   |
| string | "hello"             | `^`           |
| char   | 'a', 'b'            |               |

OCaml的很多operators没有重载，只能由int来使用，其他数据类型的，比如说float，要用其他的操作符

### 比较符

所有的数据类型都支持 `= <> < <= >= >`

这里有个 `<>` 操作符用于比较两个值是否不相同。如果两个值不相同，它返回 `true`；如果它们相同，它返回 `false`

```ocaml
# let are_not_equal = 3 <> 4;;
val are_not_equal : bool = true
```

### 变量

通过 `let` 给一个变量赋值

```ocaml
# let seven = 3 + 4;;
val seven : int = 7
# seven;;
- : int = 7
```

和其他编程语言不同，变量必须要用一个小写字母开头

另外如果定义了同名变量会构成隐藏 hidden

```ocaml
# let seven = 42;;
val seven : int = 42
# seven;;
- : int = 42
# let seven = "seven";;
val seven : string = "seven"
```

### 复合数据类型

* Tuples

  ```ocaml
  # (2, 3, 4, 5);;
  - : int * int * int * int = (2, 3, 4, 5)
  # ("hello", true, 3.14159);;
  -: string * bool * float = ("hello", true, 3.14159)
  ```

  没有长度为1的tuples，因为可以在expression外面套括号，编译器无法区分。但是可以有长度为0的，称为unit
  ```ocaml
  # 1;;
  - : int = 1
  # (1);;
  - : int = 1
  # ();;
  - : unit = ()
  ```

* Pairs 是长度为2的 Tuples

  ```ocaml
  # (3 , 4);;
  - : int * int = (3, 4)
  # (1=2,"hello");;
  - : bool * string = (false, "hello")
  ```

* Records，类似于struct。可以调换字段的定义顺序

  如果有很多相同的字段，with 可以重复利用已经定义过的实例

  ```ocaml
   # type test = { a : int; b : string };;
  type test = { a : int; b : string; }
  # let t1 = { a = 5; b = "abc" };;
  val t1 : test = {a = 5; b = "abc"}
  # let t2 = { t1 with a = 3};;
  val t2 : test = {a = 3; b = "abc"}
  ```

* Lists

## *流控制*

### match

match 类似于swtich，`_` 是default的情况

### 分支

```ocaml
if e then e1 else e2
```

### 循环

## *函数*

### 函数定义

### Tail Call

OCaml中的尾调用（tail call）是函数式编程中一个重要的概念，它指的是在函数的最后一步直接进行的函数调用。当一个函数调用是另一个函数的最后一个动作时，我们称这个函数调用是"尾调用"。这种调用可以被编译器或运行时环境优化以避免增加新的栈帧到调用栈上，这种优化成为"尾调用优化"（tail call optimization, TCO）

```ocaml
(* 非尾递归因为在递归调用后还有乘法操作 *)
let rec factorial n =
  if n = 0 then 1
  else n * factorial (n - 1)

(* 尾递归因为对helper的调用是函数的最后操作 *)
let factorial n =
  let rec helper n acc =
    if n = 0 then acc
    else helper (n - 1) (n * acc)
  in
  helper n 1
```

在第一个`factorial`函数中，每次调用`factorial`需要等待递归调用返回结果才能继续执行乘法操作。这意味着系统必须保留每个递归调用的状态，导致栈空间随着递归深度线性增长。

而在第二个`factorial`函数中（使用了`helper`辅助函数），每次对`helper`的递归调用都是函数体中的最后操作，并且传入了累积值`acc`。因此，当前的帧可以被清除，新的调用可以重用该帧的空间。如果编译器或运行时环境实现了尾调用优化，那么即使在非常深的递归层次也不会出现栈溢出的情况。

OCaml 是众多支持尾调用优化的语言之一，这使得在编写递归函数时能够有效地利用内存资源，在处理大量数据或深层递归时尤其重要。通过尾调用优化，递归代码可以达到与迭代相同的空间效率

### 递归函数

## *多态函数*

## *Modules*





读入其他文件

```ocaml
#use "Hello.ml";;
```



# Haskell

[Haskell Language](https://www.haskell.org/)

Haskell是一种标准化的纯函数式编程语言，以其强大的类型系统和对函数式编程概念的支持而闻名。它于1990年首次发布，并以数学家Haskell Curry的名字命名，Curry以他在逻辑学和组合抽象代数方面的贡献著称

## *工具链*

要开始使用Haskell，你可以做以下事情：

1. **安装GHC**：Glasgow Haskell Compiler (GHC) 是目前使用最广泛的Haskell编译器。安装GHC通常也会包括安装Haskell的交互式环境GHCi。

2. **使用Cabal或Stack管理项目**：Cabal和Stack是两个流行的Haskell项目管理工具，用于处理库依赖、构建和测试Haskell程序。

3. **学习语言基础**：由于Haskell和其他主流编程语言（如C++、Java 或 Python）在概念上有很大不同，因此学习它的语法和函数式编程的概念是很重要的。

   *探索库**：Haskell有一个庞大的第三方库生态系统，在[Hackage](https://hackage.haskell.org/) 包管理器中可以找到。

### 一个简单的示例

下面是一个使用Haskell编写的简单程序，该程序定义了一个计算斐波那契数列的函数：

```haskell
fibonacci :: Int -> Integer
fibonacci n = fibs !! n
    where fibs = 0 : 1 : zipWith (+) fibs (tail fibs)

main :: IO ()
main = print (fibonacci 10)
```

在这段代码中，`fibonacci` 函数通过一个无限列表 `fibs` 来定义，这个列表是通过惰性求值生成的。`zipWith` 函数用来取两个列表（`fibs` 和它的尾部 `tail fibs`）并应用 `(+)` 函数来产生新的元素。最后，`main` 函数输出斐波那契数列中的第10个数字。

Haskell的优雅和强大来自于其纯粹的函数式特性和强类型系统，使得代码通常更易于推理，并减少了运行时错误。然而，与命令式和面向对象编程语言相比，Haskell的学习曲线可能相对较陡峭。尽管如此，Haskell提供了许多高级功能，对那些寻求深入理解函数式编程的人来说，它提供了丰富的资源和工具。
