# C++17独占

## *扩展的聚合类型*

### 聚合类的常规条件

聚合类 Aggregate Class 是一种特殊的类类型，具有特定的属性和行为。聚合类的主要特点是

* 所有成员都是 public
* 没有定义任何构造函数（不过可以定义成default）、基类、虚函数或私有/受保护的非静态数据成员
* 没有类内初始值
* 没有基类，也没有virtual函数（C++17取消）

```cpp
struct Data {
    Data() = default;
    int ival;
    string s;
}
```

### C++17对聚合类的扩展

聚合类的定义更加宽松，允许包含带有默认参数的非静态数据成员、内联函数等特性，但依然要满足成员都是公有的、没有用户定义的构造函数等要求

* 必须是公开的基类，不能是private或者protected的基类
* 必须是非虚继承

```c++
class MyStringWithIndex : public std::string {
public:
    int index_ = 0;
}
MyStringWithIndex s{ {"hello world"}, 1 }; // 直接用列表初始化，总是假设基类是一种在所有数据成员之前声明的特殊成员，可以省略里面的{}
```

另外标准库 `<type_traits>` 中提供了一个聚合类型的甄别方法 `is_aggregate_v()`

### 扩展聚合类型的兼容问题

### 聚合类在C++中的用途和优势

聚合类在C++中用于表示简单的数据结构和对象，通过简洁的成员初始化语法和与C的兼容性，方便地进行数据操作、交互和持久化操作

* 快速的成员初始化：聚合类可以使用聚合初始化语法进行快速的成员初始化，无需显式定义构造函数。配合 `{}` 列表初始化，可以方便地初始化聚合类的成员变量。注意：**初始化的顺序一定要和聚合类成员声明的顺序一样**
* 适用于数据结构和简单对象：聚合类常用于表示简单的数据结构和对象，比如结构体。由于聚合类的成员都是公有的，可以直接访问和修改成员变量，方便进行数据操作和传递
* 与C兼容性：聚合类可以与C语言代码进行无缝交互，因为它们在内存布局上与C结构体相似。这使得聚合类在与现有的C库或C接口进行交互时很有用
* 便于序列化和持久化：聚合类的简单结构使得对其进行序列化和持久化操作变得简单。可以直接将聚合类的数据写入文件或进行网络传输

## *支持初始化语句的if和switch*

## *扩展的inline说明符*

## *确定的表达式求值符号*

# C++20独占

## *三向比较*

## *协程*

协程 coroutine

## *概念和约束*

## *位域初始化*

# C++17 & C++20 共同特性

## *简化命名空间写法*

## *typename*

随着别名模板的引入，坚守class作为模板参数的声明已经失去了意义，所以在C++17正式引入了typename用来声明模板参数

除了声明模板参数之外，内嵌类型的声明也需要使用typename。C++17中只有两种例外，即指定基类和成员初始化的时候不需要用typename。C++20增加了一些可以忽略typename关键字的情况

## *结构化绑定*

### 多个返回值的场景

结构化绑定 structured binding

### 结构化绑定的类型

* 绑定到原生数组
* 绑定到结构体和类对象
* 绑定到元祖和类元祖的对象
