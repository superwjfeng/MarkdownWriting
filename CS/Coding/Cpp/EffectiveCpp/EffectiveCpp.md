# 让自己习惯C++

## *条款1：将C++视做一个语言联邦*

### C++的四种子语言

今天的C++是一门多范式编程语言 Multiparadigm programming language，同时支持过程式 procedural、面向对象 object-oriented、函数式 functional、泛型 generic和元编程 metaprogramming 特性。这种能力和灵活性使C++成为无可比拟的工具，但也会引起一些混乱。这种混乱就是**似乎所有的“规范语法”规则都会有一些例外**

一种理解方法是将C++视做一个语言联邦，在每一种子语言中的语法规则不一定在另一种子语言中完全使用。C++主要有以下几种子语言

<img src="C++联邦.drawio.png" width="50%">

* C++的C语言部分：C++仍然是基于C的。块、语句、预处理器、内置数据类型、数组、指针等都来自于C。在许多情况下，C++提供的解决问题的方法优于C中的对应方法（比如[条款2：尽量以const、enum、inline替换 #define](#条款2)和[条款13：以对象管理资源](#条款13)），但当使用C++的C部分时，高效编程的规则反映了C语言相对有限的功能：没有模板，没有异常，没有重载等
* C++的面向对象部分：C++的这一部分就是C with Classes的全部内容，即类（包括构造函数和析构函数）、封装、继承、多态、虚函数（动态绑定）等。这是C++中面向对象设计的经典规则最直接适用的部分
* C++的模板部分：这是C++的泛型编程部分。事实上模板是如此强大，它们产生了一种全新的编程范式--模板元编程 template metadata programming TMP。[条款48](#条款48)提供了TMP的概述，但除非是一个铁杆模板迷，否则不必过于担心它。TMP的规则很少与主流C++编程交互
* C++的STL部分：STL是一个模板库，但它是一个非常特殊的模板库。它通过一些约定，很好地将容器、迭代器、算法和函数对象地融合在一起。使用STL时需要确保遵循它的约定

### 简单举例

**当在四种不同的子语言之间切换时，为了实现高效的编程需要遵守的规则是不同的**。下面举一个函数传递的例子

* 对于内置类型 built-in type，值传递通常比引用传递更高效
* 但在C++的面向对象部分时，用户定义构造函数和析构函数的存在意味着引用传递到常量通常更好
* 在C++的模板部分尤其如此，因为在那里，你甚至不知道正在处理的对象的类型
* 然而当进入STL时，迭代器和函数对象是基于C中的指针建模的，因此对于STL中的迭代器和函数对象，旧的C值传递规则再次适用

## <span id="条款2">*条款2：尽量以const、enum、inline替换 `#define`*</span>

因为C的历史原因，`#define` 预处理仍然很常用。事实上，C++的发明者 Dr. Bjarne Stroustrup 也致力于去除C++中预处理器的使用

使用 `#define` 预处理替换有两个显著的缺点

1. 不方便追踪错误，编译器不会显式宏名称
2. 即使很小心了，编写宏仍然是极易出错，应该考虑用内联函数来替换。通过使用内联函数模板，可以获得宏的所有效率，以及普通函数的所有可预测行为和类型安全

```c++
#define ASPECT_RATIO 1.653 // 不好
const double aspect_ratio = 1.653; // 用常量来代替
```

下面两种特殊情况需要我们考虑

### 定义常量指针

```c++
#define AUTHORNAME "Scott Meyers"
const char * const author_name = "Scott Meyers"; // const pointer & pointer to a const
const string author_name2 = "Scott Meyers"; // better
```

定义字符串时不是 `const char *`，这只是一个常量指针，但按照 `#define` 或常量的意义应该既是一个指针常量，也是一个常量指针，即 `const char * const`

然而写成 `const char * const` 这种形式很难看，用C++标准库提供的string会好很多

### 类的专属常量

* 静态常量

  要把常量的作用域限制为类，就必须把它设为成员；而要确保最多有一个常量的副本，就必须把它设为静态成员

  然而在C++中，类静态常量的使用非常特殊。一般的静态变量不能给缺省值，只能在类外面给初始值

  但是有例外：`const static int`、`const static char`、`const static bool` 类型的静态变量可以给缺省值，比如哈希桶中的素数size扩容就用到了这个特性

  或者更准确地可以理解为，**上面三种类型的静态常量的初始值如果在类内声明时指定的，那么在类外定义时反而不允许赋初始值**；反过来如果在类外定义指定了初值，那么类内声明就不可以给出

  非常匪夷所思，明明是类内声明却可以给出初始值，但就是这么规定的

  甚至只要不获取它们的地址，那么甚至可以在不提供类外定义的情况下只声明并使用它们

  ```c++
  class GamePlayer {
  public:
      int get_numturns() { return num_turns; }
  private:
      const static int num_turns = 5; // const static 类型的声明，在这里初始化了！
      int scores_[num_turns];
  }
  const int GamePlyaers::num_turns; // const static 类型的定义，只要不获取它们的地址，可以不给出
  ```

* 枚举常量

  另一种方法是使用枚举，反正只要是编译时顺序确定的就行了

  ```c++
  class GamePlayer {
  public:
      int get_numturns() { return NumTurns; }
  private:
      enum { NumTurns = 5 };
      int scores_[NumTurns];
  }
  ```

### 总结

考虑到const、枚举和内联的可用性，对预处理器（特别是 `#define`）的需求减少了，但并没有完全消除。`#include` 仍然是必不可少的，`#ifdef//#ifndef` 继续发挥避免 circular dependency 的重要作用

* 对于简单常量，首选const对象或枚举，而不是 `#define`
* 对于类似函数的宏，优先选择内联函数

## *条款3：尽可能使用const*

### const指针和函数声明

优秀的自定义类型需要与内置类型保持一致性

问题：乘法重载的时候不用传左值吧

### const限定成员函数

这部分在 *Cpp基础&11.md* 中的类与对象（上）-- 类成员中的const成员部分讲过了，可以回顾一下

在成员函数上使用const

* 使类的接口意图更明确。知道哪些函数可以修改一个对象，哪些不能，这是很重要的
* 使得使用const对象成为可能

C++中成员函数可以根据是否可以通过this来修改对象可以分为两类（即是否有const修饰整个成员函数），并且分别重载

一般返回值是否设置为const &和this是否设置为const都是成对的。因为不能通过this来修改的时候，同样也不能通过返回的引用来修改

### 位常量与逻辑常量

### 避免const重载的代码重复

## *条款4：确定对象被使用前已先被初始化*

C/C++中定义无初值的对象时对象是否会被初始化的规则很复杂。一般来说，如果使用C++的C部分，并且初始化可能会导致运行时成本，则不能保证会初始化。如果使用C+t的非C部分。情况则有时会不同。比如说数组不一定保证其内容初始化，而vector的内容必须初始化

最佳方法是始终在使用对象之前初始化它们。对于内置类型的非成员对象，需要手动完成。如

```C++
int x = 0;                                //手动初始化int类型
const char * text = "A C-style string" ;  //指针的手动初始化
double d;                                 //通过读取输入流来“初始化”，定义后确保立刻赋值也是可以的
std: :cin >> d;
```




**对于几乎所有其他的情况下，初始化的责任都落在构造函数身上**

# 构造/析构/赋值运算

## *条款7：为多态基类声明virtual析构函数*

# 资源管理

## <span id="条款13">*条款13：以对象管理资源*</span>

# 设计与声明

## *条款18：让接口容易被正确使用*

## *条款19：设计class就是设计type*

## *条款20：优先使用常量引用传递*

### 为什么要常量？

值传递 pass-by-value 时是通过对象的拷贝构造来产生一个副本来传入参数的，这种代价可能会很大，特别是对于自定义数据类型

按照约定，内置类型、STL中的迭代器和函数对象都是值传递的

至于传常量有两个好处

1. **保护参数不变性**，使用常量引用可以确保在函数内部不会修改传入的参数值
2. **支持常量和非常量**：常量引用可以接受常量和非常量类型的实参。这增加了函数的通用性。这是因为非常量传给const是权限缩小，扩大了传参范围，即const参数和普通参数都可以传给const引用

当然传常量引用的前提是我们没有把参数设计为输出型参数，否则传的是常量引用我们也自然就不能够修改它了

若不做输出型参数的情况下，仍然把常量引用设置为普通引用会产生两个问题

1. 给使用者一种误导，即这个参数在函数内部是可以被改变的，甚至会意外改变这个参数
2. 限制了传参范围，此时const数据类型因为权限扩大问题无法传递给普通参数

### 切割问题

## *条款21：函数返回不要滥用引用*

若函数要返回的对象是在函数内部构造的（非静态）局部对象，那么一旦出了块作用域编译器就自动调用析构把它销毁了，此时若返回引用会产生空指针错误，要用传值返回

如果是在函数作用域里new到堆上的话，还要考虑没有delete会产生内存泄漏的问题

只有当返回的对象是在函数开始之前就已经存在的对象，即对象的作用域不限于函数的块作用域，此时才可以传引用返回

当不希望返回的对象被修改时，返回对常量的引用

## *条款22：将数据设为私有*

# 实现

# 继承与面向对象设计

# 模版与泛型编程

## <span id="条款48">*条款48：认识template元编程*</span>

# 定制new和delete

# 杂项讨论