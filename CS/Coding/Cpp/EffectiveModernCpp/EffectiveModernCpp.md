# 类型推导

## *条款1：理解模板类型推导*

```c++
template<typename T> void f(ParamType param); // 函数模板
f(expr); // 函数调用
```

T的类别推导，不仅仅依赖expr，还依赖于ParamType的形式

### ParamType是指针或引用，但不是万能引用

### ParamType是万能引用

### ParamType既非指针也非引用

## *条款2：理解auto类型推导*

auto类型推导和模板类型推导的规则基本上完全一致，它们之间可以建立起一一映射的关系，它们之间也确实存在双向的算法变换

### `{}` 的auto类型推导

## *条款3：理解decltype*

## *条款4：掌握查看类型推导结果的方法*

# auto

# 转向现代C＋＋

## *条款7：区别使用 `()` & `[]` 创建对象*

### 多样化的初始化方法

可以用下面的程序在Linux上通过 `-fno-elide-constructors` 关闭编译器的所有优化后得到结果

```c++
class A {
public:
  A(int a) : a_(a) {
    std::cout << "A(int a)" << std::endl;
  }
  A(const A &a) {
    std::cout << "A(const A& a)" << std::endl;
  }
private:
  int a_ = 0;
};
```

1. `A a = 10;` 隐式转换：自动先调转换构造产生一个临时量，然后再掉拷贝构造把临时量拷贝给对象

    ```c++
    /* 打印结果
    A(int a)
    A(const A& a)
    */
    ```

2. `A a(10);`：直接调用一次拷贝

    ```c++
    /* 打印结果
    A(const A& a)
    */
    ```

3. `A a = (10);` 和第一种初始化是一样的

4. `A a{10};`：调一次构造

    ```c++
    /* 打印结果
    A(int a)
    */
    ```

5. `A a = {10}` ：调一次构造，C++11时和第四种构造是一样的，C++14开始不一样了

### `{}` 列表初始化的优势

* `{}` 列表初始化的优势：完美解决下面的问题，即 `{}` 可以一次性接收多个参数、`{}` 只需要一次构造

  * `A a = 10;` 的问题
    * `=` 初始化无论如何只能接受一个参数，若把拷贝构造改成需要两个参数，就不能用它了
    * `=` 初始化需要额外进行一次拷贝

  * `A a(10);` 的问题：被用做函数参数或返回值时还是会执行拷贝

* `{}` 列表初始化有一项新的特性：它禁止内置类型之间进行隐式窄化类别转换 narrowing conversion。所谓的隐式窄化类别转换就是指可能导致数据的精度或范围减小，可能会导致数据丢失或截断的类型转换，比如下面这种

  ```c++
  double x = 5.7;
  int y = x; // 隐式窄化类别转换，将5.7转换为5
  ```

* 列表初始化也大大简化了聚合类的初始化，一个拥有众多类成员的聚合类不需要定义复杂的构造函数就可以直接使用列表初始化进行初始化了

* 列表初始化免疫解析问题 most vexing parse

  对于下面这个声明，C++有两种解释方式：对象参数的创建或者函数类型的声明。也就是说下面 `int (value)` 的括号是没有效果的。C++规定了，任何能够解析为声明的都要解析为声明，而这就会带来副作用

  ```c++
  int i(int (value)); // int i (int value)
  TimerKeeper time_keeper(Timer()); // 本意是调用，传入了一个Timer() 匿名对象
  // TimeKeeper time_keeper(Timer (*)()); 解析成了声明
  ```

  若我们时候 `{}` 列表初始化就不会出现这样的解析错误

### array和 `{}` 的坑

[大括号之谜：C++的列表初始化语法解析_too many initializers for-CSDN博客](https://blog.csdn.net/devcloud/article/details/114523118)

## *条款9：优先考虑别名声明而非typedef*

# 智能指针

# 右值引用

## *条款23：理解 `std::move` & `std::forward`*

# lambda表达式

# 并发API