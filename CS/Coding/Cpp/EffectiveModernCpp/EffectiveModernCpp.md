

# 转向现代C++

## *条款11：优先使用delete，而非private*

对于习惯了C++11之后的程序员来说，使用delete而非private来禁止使用某种成员函数的方式早已成为习惯。这点在 *Cpp基础&1114.md* - 拷贝控制 - 阻止拷贝 中已经展示过了。这里再做一些补充

### 明确错误原因

声明为delete的函数一般都会被声明为public，而不是private。因为在尝试访问成员函数时，C++编译器默认**先校验可访问性，后校验删除状态**

若设置为private，则错误原因会变成方法不可访问。则容易混淆真正的错误原因

### delete可以修饰任意方法

delete可以用来修饰任意方法，一个应用就是将一些不想要的隐式构造给过滤掉。比如有下面这个判断幸运值的方法

```c++
bool is_lucky(int number); // 原始版本
bool is_lucky(char) = delete; // 拒绝 char 型别
bool is_lucky(bool) = delete; //拒绝 bool 型别
bool isLucky (double) = delete; // 拒绝 double 和 float 型别
```

对于这个函数，bool、long、double这些整形都可以隐式转换为int，所以要把这两个重载函数给delete掉

### 禁止特定模板的实例化

delete还可以结合模板特化来阻止不应该实现的模板实例化

```c++
template <>
void processPointer<void> (void*) = delete；

template <>
void processPointer<char>(char*) =  delete;
```

用C++98的private思路是不行的，因为不可能让成员函数模板的某个特化有不同于主模板的访问限定符

```c++
class Widget {
public:
	templatextypename T>
	void processPointer (T* ptr) {}
private: 
    template <> // 错误！
    void processPointer<void>(void*)；
}；
```

## *条款12：将要重写的方法声明为override*

阐述了一下使用override的好处

## *条款13：优先使用const_iterator，而非iterator*





## *条款17：理解特殊成员函数的生成（三五法则）*

三（C++98）/五（C++11）法则是对两个C++标准下类的默认成员函数编写规则的总结

默认生成的成员函数都是non-virtual、inline，且具有public的访问权限。除非是一个定义了虚析构函数的基类的派生类，这些派生类的合成析构函数都是virtual的

大三律 Rule of Three：当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。即分配了动态内存的构造函数必然要实现析构函数，因此为了实现深拷贝也必然要实现拷贝构造和重载赋值运算符。但是有一个重要例外，就是在继承体系中的基类里必须要定义虚析构函数，此时无法用这条法则来判断是否需要拷贝控制成员

* 需要拷贝操作的类也需要赋值操作，反之亦然
* 两种拷贝操作是互相独立的，声明了其中的一个不会阻止编译器生成另一个

C++11之后默认成员函数变成了8个，增加了移动构造和移动赋值

* 只有在要实现深拷贝（深拷贝意味着肯定要进行资源管理）的时候才有显式实现这两个成员函数的价值，比如 string、vector、list
* 若不需要深拷贝，则可以自动生成，但自动生成的条件比较苛刻：没有实现任何的拷贝操作、移动操作和析构操作（一般要自己实现析构就说明要清理资源的深拷贝，也就要同时实现拷贝和赋值重载），此时编译器才会自动生成一个默认移动构造
* 默认移动构造会对内置类型按字节拷贝，即浅拷贝；对于自定义类型就要看它是否实现了移动构造，若实现了就调用移动构造，没有实现就用拷贝构造
* 移动赋值和移动构造彼此不独立，声明了其中的一个就会阻止编译器生成另一个
* 若显式提供了移动构造或移动赋值，那么编译器就不会提供拷贝构造和拷贝赋值；相反若显示提供了拷贝操作，则编译器就同样不会提供移动操作了。毕竟如果成员移动被认为不是适当的移动方式的话，也就没有理由期望按成员复制是对象认为适当的复制方式
* 只要用户声明了析构函数，就不会生成移动操作

所有五个拷贝控制成员应该看作一个整体。一般来说，若一个类定义了任何一个拷贝操作，它就应该定义所有五个操作







