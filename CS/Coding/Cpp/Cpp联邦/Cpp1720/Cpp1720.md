# C++17独占

## *支持初始化语句的if和switch*

## *扩展的inline说明符*

## *确定的表达式求值符号*

## *其他特性*

### `std::variant`

# C++20独占

## *三向比较*

## *协程*

C++20 引入了协程 coroutine 的概念，**它是一种支持异步执行的函数或子例程**。协程允许函数的执行在某个点上暂停，将控制权交回给调用者，然后在稍后的时间继续执行，而不阻塞线程

协程是一种轻量级线程，它能够处理非阻塞的、异步的任务，如事件循环、I/O 操作等，而不需要创建额外的线程

### 协程的使用

### co_await

### co_yield

### co_return

### promise_type

## *概念和约束*

## *位域初始化*

## *指定初始化*

## *格式化字符串库*

### `std::format`

std::format - Lancern的文章 - 知乎 https://zhuanlan.zhihu.com/p/355166681

`std::format` 是 C++20 中引入的一个格式化字符串的库，它允许你以一种更简洁和类型安全的方式进行字符串格式化。在使用 `std::format` 之前，通常我们使用 `sprintf` 或者其他类似的函数，但这些函数存在一些安全性和易用性的问题。`std::format` 的设计旨在解决这些问题

`std::format` 的使用基本和Python的格式化字符串是一模一样的。`std::format` 是一个函数模板，其原型为

```c++
template <typename ...Args>
std::string format(std::string_view fmt, const Args&... args);
```

`std::format` 接受一个格式化字符串（所谓格式化字符串是一种包含占位符的字符串，这些占位符在运行时被具体的值替代。这样的字符串通常用于输出信息时，以便以一种结构化和可读的方式呈现数据）作为第一个参数，然后使用**花括号 `{}` 表示占位符**，占位符中的内容将被后续参数替换

```c++
#include <format>
#include <iostream>

int main() {
    // 格式化字符串
    std::string formattedString = std::format("Hello, {}!", "world");
    // 输出结果
    std::cout << formattedString << std::endl;

    return 0;
}
```

### 为自定义类型指定格式化方法

`std::format` 可以支持对自定义的数据类型进行格式化

### 补充：第三方fmt库

`fmtlib/fmt ` 格式化库提供了类似于 C++20 中的 `std::format` 的字符串格式化功能，它的目标是提供高性能的、类型安全的字符串格式化，语法上类似于 Python 中的字符串格式化

`fmt::format` 和 C++20 中的 `std::format` 在使用上非常相似，因为 `fmt::format` 的设计灵感就来自于 C++20 中的 `std::format`。两者都提供了类似的语法和功能，以一种更现代和类型安全的方式进行字符串格式化

主要的相似之处包括：

1. 使用花括号 `{}` 作为占位符
2. 支持多种类型的格式化，包括整数、浮点数、字符串等
3. 允许在占位符中使用格式说明符，例如 `:.2f` 表示浮点数保留两位小数

虽然在使用上很相似，但需要注意的是，`std::format` 是标准 C++ 的一部分，而 `fmt::format` 是一个单独的第三方库（fmt库），它在C++20之前就已经存在了，并为那些尚未升级到C++20的项目提供了类似的功能

在C++20及之后的标准中，优先选择使用 `std::format`，因为它是标准库的一部分，有望成为C++中的通用标准。而对于早期标准的项目，或者对于不支持C++20的编译器，可以考虑使用 `fmt::format` 这个第三方库

## *其他特性*

### 模块

模块 module 是C++20引入的新特性，它的主要用途是将大型工程中的代码拆分成独立的逻辑单元，以方便大型工程的代码管理

### 按值进行默认比较

# C++17 & C++20 共同特性

## *简化命名空间写法*

有时候打开一个嵌套命名空间可能只是为了向前声明某个类或者函数，但是却需要编写冗长的嵌套代码，这无疑是一种麻烦

```c++
namespace A {
    namespace B {
        namespace C{
            void foo() {}
        }
    }
}
```

C++17允许更简洁的嵌套命名空间写法

```c++
// 两种写法等价
namespace A::B::C {
    void foo() {}
}

```

C++20进一步简化了内联命名空间的定义方法。inline 可以出现在除第一个 namespace 之外的任意 namespace 之前

```c++
namespace A::B::inline C {
    int foo1() {} 
}
namespace A::inline B::C {
    int foo2() {} 
}
```

## *扩展的聚合类型*

### 聚合类的C++11条件

聚合类 aggregate class 是一种特殊的类类型，具有特定的属性和行为。`<type_traits>` 中提供了一个聚合类型的萃取方法 `is_aggregate_v()`，可以用来判断是否是聚合类

聚合类的主要特点是

* 所有成员都是 public
* 没有定义任何构造函数（不过可以定义成default）或私有/受保护的非静态数据成员
* 没有类内初始值
* 没有基类，也没有virtual函数（C++17取消）

```cpp
struct Data {
    Data() = default;
    int ival;
    string s;
}
```

### C++17对聚合类的扩展

聚合类的定义更加宽松，允许包含带有默认参数的非静态数据成员、内联函数等特性，但依然要满足成员都是公有的、没有用户定义的构造函数等要求

* 必须是公开的基类，不能是private或者protected的基类
* 必须是非虚继承

```c++
class MyStringWithIndex : public std::string {
public:
    int index_ = 0;
}
// 因为总是假设基类是一种在所有数据成员之前声明的特殊成员，所以套了一层{}给string初始化
MyStringWithIndex s1{ {"hello world"}, 1 }; // 直接用列表初始化
MyStringWithIndex s2{ "hello world", 1 }; // 可以省略里面的{}，效果是一样的
```

基类是否是聚合类和派生类是否是聚合类没有关系，比如说上面继承的 `std::string` 就肯定不是一个聚合类。所以只要派生类及其基类满足上面的所有条件，则派生类就是一个聚合类

如果派生类存在多个基类，那么其初始化的顺序和其继承的顺序相同

### 扩展聚合类型的初始化

C++11之后聚合类可以使用 `{}` 来直接初始化（合理怀疑聚合类内会自动生成带有 `std::initialzier_list` 的构造）。C++98还是要用构造函数，若一个“聚合类”有大量成员，那么写构造函数还是很麻烦

下面是扩展聚合类型的一些使用注意事项

* 下面是因为从C++17扩展带来的初始化的不兼容问题：C++17之前下面的代码能够通过编译，此时DerivedData不是一个聚合类，所以 `DerivedData d{};` 等价于 `()` 构造，此时虽然基类的构造是protected，但派生类可以调用它

  C++17之后DerivedData变成了一个聚合类，而聚合类不允许使用基类的protected构造，所以编译失败

  ```c++
  class BaseData {
  	int data_;
  public:
  	int Get() { return data_; }
  protected:
  	BaseData() : data_(11) {}
  };
  class DerivedData : public BaseData {
  public:
  };
  
  DerivedData d{};
  ```

* 禁止聚合类型使用**用户声明的构造函数**

  ```c++
  // default 和 delete 都是用户声明的构造函数
  struct X { X() = default; };
  struct Y { Y() = delete; };
  
  Y y1(); // 失败
  Y y2{}; // 成功
  ```

  上面两个都是用户声明了构造函数的聚合类。因为用 `{}` 初始化没有经过构造函数，所以y2初始化成功了，但问题是我们删除了它的构造，想要实现的效果就应该是无法初始化的，这显然违背了设计初衷

  为了补上这个漏洞，C++20禁止了聚合类使用default和delete这两种用户声明的构造函数

### 聚合类在C++中的用途和优势

聚合类在C++中用于表示简单的数据结构和对象，通过简洁的成员初始化语法和与C的兼容性，方便地进行数据操作、交互和持久化操作

* 快速的成员初始化：聚合类可以使用聚合初始化语法进行快速的成员初始化，无需显式定义构造函数。配合 `{}` 列表初始化，可以方便地初始化聚合类的成员变量。注意：**初始化的顺序一定要和聚合类成员声明的顺序一样**
* 适用于数据结构和简单对象：聚合类常用于表示简单的数据结构和对象，比如结构体。由于聚合类的成员都是公有的，可以直接访问和修改成员变量，方便进行数据操作和传递
* 与C兼容性：聚合类可以与C语言代码进行无缝交互，因为它们在内存布局上与C结构体相似。这使得聚合类在与现有的C库或C接口进行交互时很有用
* 便于序列化和持久化：聚合类的简单结构使得对其进行序列化和持久化操作变得简单。可以直接将聚合类的数据写入文件或进行网络传输

## *强枚举类型*

### 初始化列表有底层类型的枚举类型

C++17支持让强枚举类型通过初始化列表来初始化，因为强枚举类型有默认的底层类型int，而枚举类型则一定要是指定了底层类型之后才允许使用初始化列表来初始化

```c++
enum class HighSchool {
    student,
    teacher,
    principal
}

HighSchool h{1};
```



### 使用using打开强枚举类型

## *typename*

随着别名模板的引入，坚守class作为模板参数的声明已经失去了意义，所以在C++17正式引入了typename用来声明模板参数

除了声明模板参数之外，内嵌类型的声明也需要使用typename。C++17中只有两种例外，即指定基类和成员初始化的时候不需要用typename。C++20增加了一些可以忽略typename关键字的情况

## *lambda*

### 常量lambda和捕获 `*this`

### 捕获 `[=, this]`

## *结构化绑定*

### 多个返回值的场景

结构化绑定 structured binding

### 结构化绑定的类型

* 绑定到原生数组
* 绑定到结构体和类对象
* 绑定到元祖和类元祖的对象

## *noexcept*



## *新增预处理和宏*

### 属性特性测试宏

### 语言功能特性测试宏

## *可变参数模板*

### 折叠表达式

### lambda初始化捕获的包展开
