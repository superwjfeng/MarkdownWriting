# 模板 & 泛型编程

## *模板的定义*

泛型编程 Generic Programming：编写与类型无关的通用代码，是代码复用的一种手段

模板是泛型编程的基础，模板是一种静态的多态，因为它在编译的时候就确定了

###  模版要定义在头文件里

当编译器遇到一个模版定义时，它不会生成代码，**只有当实例化模版的时候编译器才会生成代码**。这种特性会影响到如何组织代码以及错误何时才会被检测到

若在本模块中找不到函数和变量的地址（即定义），那么会在链接阶段去总符号表里找，所以函数和变量只要在头文件中有一个声明就可以，定义可以放到某个模块的c文件中。但是类和模版不同，它们是在编译阶段实例化数据的“蓝图”，每一个用到它们的文件都必须知道它们的具体定义，而不仅仅是声明。所以**完整的类和模版必须要定义在头文件中**

涉及到模版的报错往往非常复杂，非常难以debug。这也是使用模版的一个缺点

**模板不能进行分离编译**，否则会因为两次编译导致链接错误，因此要统一放在头文件里，但在同一个文件里可以分离编译

### 控制实例化 -- 外部模板

前面说过只有当实例化模版的时候编译器才会生成代码，若不同的编译单元使用了同一份实例化模板的时候，那么在各自的编译单元都会生成对应的模板，这会导致严重的代码膨胀

和避免全局变量重定义一样，我们可以使用外部模板 extern template 来控制实例化，从而减少代码膨胀。外部模板的形式如下

```c++
extern template class Foo; // 实例化声明
template class Foo {} // 实例化定义
```

外部模板意味着指示编译器在之后的链接过程中去其他编译单元中找到，也就是整体程序共享了一个实例化模板。因此要**确保至少有一个实例化定义，而且extern声明必须出现在任何使用此实例化模板的代码之前**

### 模板的优缺点

* 优点
  * 模板复用了代码，节省资源，更快的迭代开发，STL库的诞生很大程度上得益于此
  * 增强了代码的灵活性
* 缺点
  * 模板只是将重复的代码交给编译器实现，因此模板也会导致代码膨胀问题，从而导致编译时间变长
  * 出现模板编译错误时，错误信息非常凌乱，不易定位错误

## *函数模板*

### 模板参数

函数模板 function template 代表了一个函数家族，该函数模板与类型无关，在使用时被参数化，根据实参类型产生函数的特定类型版本

```c++
// 模板参数定义了模板类型，类似函数参数，但函数参数定义了参数对象
// typename后面类型名字T是随便取的，一般是大写字母或者单词首字母大写 T、Ty、K、V，代表了一个模拟类型/虚拟类型
template<typename T> void Swap(T& left, T& right) {
    T temp = left;
    left = right;
    right = temp;
}
// swap在std中有模板定义了
```

模板定义以关键字template开始，后跟一个模板参数列表 template parameter list，这是一个以逗号分隔的一个或多个模板参数 template parameter 的列表。模板定义中，模板参数列表不能为空

模板参数有两种

* 模板类型参数 type parameter

* 非类型模板参数 nontype parameter：非类型模板参数表示一个值而非一个类型，通过一个特定的类型名而非关键字class或typename来指定它

  ```c++
  template<class T, size_t N = 10> class array {
  public:
  private:
      T _a[N];
  };
  ```

  * 非类型模板参数只能用于整形、指针或引用，浮点数、类对象以及字符串是不允许作为非类型模板参数的
  * 非类型的模板参数必须在编译期就能确认结果

函数模板可以声明为inline或constexpr的，说明符放在模板参数列表之后，返回类型之前

```c++
template<typename T> inline T min(const T&, const T&);
```

### 函数模板的实例化

**函数模板实例化的原理：模板实参推断 template argument deduction 和函数模板实例化 instantiation**

函数模板是一个设计图，他本来并不是真正用来执行任务的函数，每次调用相关函数编译器都要根据函数模板进行一次类型推演产生相关函数

* 隐式实例化 implicit instantiation：让编译器根据实参**自动推演**模板参数的实际类型。模板中不会进行隐式类型转换，编译器不知道该转成哪一个会报错，需要用户自已进行强制类型转换
* 显式实例化 explicit instantiation：在函数名后的 `<>` 中由用户指定模板参数的实际类型
  * 参数需要强转时可以使用

      ```cpp
      // Add(1.1, 2) // 报错
      Add((int)1.1, 2); // 用户强转输入
      Add<int>(1.1, 2); // 模板的显式实例化
      ```

  * 需要指定返回类型时一定要显式实例化

    ```cpp
    // 已经定义了一个A类
    template<class T> T* Func(int n) {
        T* a = new T[n];
        return a;
    }
    // 不能自动推演返回类型T
    Func<A>(10); // 显式实例化
    ```

## *类模板*

### 模板定义

```cpp
// template<typename T>
// 上下两种类模板都可以
template<class T> class Foo {
    Foo();
    // 在类模板内可以简化模板类名的使用
    Foo& some_function() {}
private:
    T* _a;
};
// 同一个头文件的类模板外定义
template<typename T> inline Foo() {}
```

* 类模板实例化的方法和函数模版实例化时候的自动推演不同，**类模板必须要显式实例化**，也就是说需要显式给出 `<>` 里面的类型，这些类型被称为显式模版实参 explicit template argument 列表，它们会被绑定到模版参数
* 类模板名字不是真正的类，实例化的结果 `Stack<int>` 才是真正的类，若不显式实例化，编译器无法判断
* **在头文件中的类模板之外定义成员函数的时候必须要把关键字template及其后的类模板参数列表带上**
* 在类模板内可以简化模板类名的使用，此时不需要写参数列表；在类模板外的类函数内也可以

默认情况下，类模板的成员函数只有当程序要用到它的时候才会实例化 

### 类模板的static成员

类模板同样可以声明static成员，但是使用类模板的static成员和在普通类中使用static成员有一些区别

```c++
template<typename T> class Foo {
public:
    static std::size_t count() { return ctr; }
private:
    static std::size_t ctr;
}
```

类模板的每个实例都有一个独有的static对象

### typename的特殊使用

查看 *EffectiveCpp.md* 的条款42

### 成员模板

成员模板 member template 是普通类或类模板中的模板函数，**成员模板不能是虚函数**

当在类模板外定义类模板的成员模板时要依次给出类模板参数列表和函数模板参数列表

```c++
template<typename T>
template<typename It>
Blob<T>::Blob<It b, It e>
    :data_(std::make_shared<std::vector<T>>(n, e)) {}
```

## *友元与模板*

## *模版参数*

### 模板的作用域

**非依赖名字 non-dependent name** 和**依赖名字 dependent name** 是模板编程中的两个重要概念。其中，非依赖名字是指不依赖于模板参数的名字，例如全局变量、函数名、类型名等，而依赖名字则是指依赖于模板参数的名字，例如模板参数名、模板内部定义的类型名等

在C++模板的实例化过程中，编译器需要在模板定义时和模板实例化时分别对非依赖名字和依赖名字进行名称查找

* 对于非依赖名字，**编译器必须在模板定义时就确定其含义**，因此这些名字必须是**可见**的
* 对于依赖名字，编译器只有在**模板实例化**时才能确定其含义，因此这些名字可以在模板定义时不可见，但必须在模板实例化时可见

声明的**可见性 Visibility**指的是在哪些作用域内可以访问该声明。一般来说，声明在其所在的作用域内是可见的，即在该作用域内可以使用该声明。若声明是在一个内层作用域中，而其外层作用域中已经存在同名的声明，那么该内层作用域中的声明会隐藏外层作用域中的同名声明，此时外层作用域中的声明不可见

```cpp
template <typename T>
void foo(T x) {
    int y = 10;  // 可见的非依赖名字
    x += y;     // 可见的依赖名字
    // ...
}

int main() {
    int x = 5;
    foo(x);
    return 0;
}
```

在这个例子中，`foo`是一个函数模板，接受一个类型为`T`的参数`x`。在`foo`函数模板内部，我们定义了一个整数变量`y`，它是一个可见的非依赖名字。同时，`x`是一个依赖名字，它依赖于模板参数`T`。在`main`函数中，我们定义了一个整数变量`x`，然后调用了`foo`函数模板，将变量`x`作为参数传递进去

```cpp
template <typename T>
void foo(T x) {
    bar(x);  // 不可见的非依赖函数名
}

int main() {
    int x = 5;
    foo(x);
    void bar(int);  // 定义了一个非依赖函数bar，但在foo模板定义时不可见
    return 0;
}
```

在这个例子中，`foo`是一个函数模板，接受一个类型为`T`的参数`x`。在`foo`函数模板内部，我们尝试调用一个名为`bar`的非依赖函数。然而，在`main`函数中定义的`bar`函数虽然与`foo`调用的`bar`同名，但是在`foo`模板定义时并不可见。这样的情况下，在编译时编译器无法找到可用的`bar`函数定义，导致编译错误

### 默认模板实参

C++11标准以前只允许为类模板提供默认模板实参 default template argument，而C++11标准允许为类和函数都提供默认实参。比如说下面这个例子中 compare有一个默认模板实参 `less<T>` 和一个默认函数实参 `F()`

```c++
template<typename T, typename F = less<T>>
int compare (const T &v1, const T &v2，F f = F()) {
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
}
```

当使用一个类模板的时候，模板名之后的尖括号是必须要带上的，尖括号指出类必须从一个模板实例化而来。即使是一个类模板为其所有模板参数都提供了默认实参的时候，也要带上尖括号，这说明我们希望用那些默认实参来实例化一个类模板

```c++
template<class T = int> class Numbers { // T默认为int
public:
	Numbers(T v= 0) : val_(v) {}
private:
	T val_;
};
Numbers<long double> lots_of_precision;
Numbers<> average _precision; //空<>表示我们希望使用默认类型
```

## *实参推断*

### 类型转换

### 函数指针 & 实参推断

## *模板特化*

模板的特化 Specialization -- **针对某些类型进行特殊化处理**

### 函数模板特化

```cpp
// 函数模板
template<typename T> bool Greater(T left, T right) {
    return left > right;
}
// 若输入的参数是指针，就不会进行实例化，而是直接进入下面的特化
template<> bool Greater<Date*>(Date* left, Date* right) {
    return *left > *right;
}
```

* 必须要现有一个基础的函数模板
* 关键字 `template` 后面接一对空的尖括号 `<>`
* 函数名后跟一对 `<>`，尖括号中指定需要特化的类型
* 必须要使用模板参数关键字 `typename` 或 `class`，这两者在定义模板是等价的，不能将 `class` 换成 `struct`

### 类模板特化

* 正常模板

    ```cpp
    template<class T1, class T2>
    class Data{};
    ```

* 全特化 full specialization：将模板参数列表中所有的参数都确定化

    ```cpp
    template<>
    class Data<int, char>{};
    ```

* 偏特化 partial specialization，它有下面两种形式
  * 部分特化：将模板参数类表中的一部分参数特化

    ```cpp
    template<class T1>
    class Data<T1, int>{};
    
    //调用
    Data(int, int); // 此时会进入特化，因为第二个参数类型匹配
    ```

  * 参数更进一步的限制

    ```cpp
    template<class T1, class T2>
    class Data<T1*, T2*>{};
    
    template<class T1&, class T2&>
    class Data<T1&, T2&>{};
    ```

## *模板参数的匹配原则*

* 一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数
* 匹配的非模板参数函数/类 > 最匹配、最特化 > 一般模板产生实例

### 例题

* 下列的模板声明中，其中几个是正确的

    ```cpp
    1)template // 错误
    2)template<T1,T2> // 错误，缺少模板参数关键字 typename或class
    3)template<class T1,T2> // 错误，缺少模板参数关键字 typename或class
    4)template<class T1,class T2> // 正确
    5)template<typename T1,T2> // 错误，缺少模板参数关键字 typename或class
    6)template<typename T1,typename T2> // 正确
    7)template<class T1,typename T2> // 正确
    8)<typename T1,class T2> // 错误，没有template关键字
    9)template<typeaname T1, typename T2, size_t N> // 正确
    10)template<typeaname T, size_t N=100, class _A=alloc<T>> // 正确
    11)template<size_t N> // 正确
    ```

* 以下程序的输出结果为

    ```cpp
    template<typename Type>
    Type Max(const Type &a, const Type &b) {
        cout<<"This is Max<Type>"<<endl;
        return a > b ? a : b;
    }
    template<>
    int Max<int>(const int &a, const int &b) {
        cout<<"This is Max<int>"<<endl;
        return a > b ? a : b;
    }
    template<>
    char Max<char>(const char &a, const char &b) {
        cout<<"This is Max<char>"<<endl;
        return a > b ? a : b;
    }
    int Max(const int &a, const int &b) {
        cout<<"This is Max"<<endl;
        return a > b ? a : b;
    }
    int main() {
        Max(10,20); // "This is Max" // 可以直接匹配非模板参数，虽然形参是引用和权限缩小，但非模板参数仍然是最匹配的
        Max(12.34,23.45); // "This is Max<Type>" // 没有匹配的特化模板或显式实例化的实例，因此要调用模板
        Max('A','B'); // "This is Max<char>" // 已经给出了特化模板，直接匹配
        Max<int>(20,30); // "This is Max<int>" 直接进行了显式实例化，但因为给出了int条件下的特化，所以使用特化模板
        return 0;
    }
    ```
    
* 以下程序运行结果为

    ```cpp
    template<class T1, class T2>
    class Data {
    public: 
        Data() { cout << "Data<T1, T2>" << endl; }
    private:
        T1 _d1;
        T2 _d2;
    };
    template <class T1>
    class Data<T1, int> {
    public:
        Data() { cout << "Data<T1, int>" << endl; }
    private:
        T1 _d1;
        int _d2;
    };
    template <typename T1, typename T2>
    class Data <T1*,T2*> {
    public:
        Data() { cout << "Data<T1*, T2*>" << endl; }
    private:
        T1 _d1;
        T2 _d2;
    };
    template <typename T1, typename T2>
    class Data <T1&, T2&> {
    public:
        Data(const T1& d1, const T2& d2)
        : _d1(d1)
        , _d2(d2)
        {cout << "Data<T1&, T2&>" << endl;}
    private:
        const T1 & _d1;
        const T2 & _d2;
    };
    int main() {
        Data<double, int> d1; // "Data<T1, int>" 第二个参数int已经最匹配了 class Data<T1, int>
        Data<int, double> d2; // "Data<T1, T2>" 没有最匹配的特化模板，需要进行模板实例化
        Data<int*, int*> d3; // "Data<T1*, T2*>"
        Data<int&, int&> d4(1, 2); // "Data<T1&, T2&>"
        return 0;
    }
    ```

## *可变参数模板*

### 声明 & 实例化

可变参数在C语言中就有了，比如printf的参数就是一个可变参数，底层是用 `va_list` 来接收的，具体可以看 *C.md* - 数组和指针 - 可变参数列表

**C++11把可变参数扩展到了模板中**。一个可变参数模板 variadic template 就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为参数包 parameter packet，用 `...` 来表示，一般命名为Args。存在两种参数包

* 模板参数包 template parameter packet：表示零个或多个模板参数 `typename... Args` 或 `class... Args`
* 函数参数包 function parameter packet：表示零个或多个函数参数

```c++
template<typename T, typename... Args> void foo(const T &t, const Args&... rest);
```

可以使用 `sizeof...` 操作符来获取包中的元素

```cpp
template<typename T, typename... Args> 
void foo(const T &t, const Args&... rest);
	cout << sizeof...(args) << endl;
	////不能这么用
	//for (int i = 0; i < sizeof...(args); i++) {
	//	cout << args[i] << " ";
	//}
	//cout << endl;
}
```

编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数目

```c++
int i= 0: double d =3.14; string s = "how now brown cow"; 
£oo(i, s, 42, d); // 包中有三个参数
foo(s, 42, "hi"); // 包中有两个参数 
foo(d, s); // 包中有一个参数
foo ("hi"); // 空包
// 相当于编译器为foo实例化出了四个版本
void foo (const int &, const string&, const int &, const double&); 
void foo (const stringa, const int&, const char 13]&); 
void foo (const double&, const string&); 
void foo (const char [31&);
```

### 递归函数方式展开参数包

函数参数包可以以递归调用的方式来展开。参数包里没有参数的时候就不能递归调用原函数了，要定义一个非可变参数的函数重载，类似于递归的base condition。非可变参数版本的声明必须在作用域中，否则会导致可变参数版本会无限递归

对于最后一次调用，非可变参数模板比可变参数模板更特例化，因此编译器会选择非可变参数的版本

```cpp
// 非可变参数版本
void ShowList() {
	cout << endl;
}
// Args... args 代表N个参数包（N >= 0）
template<class T, class ...Args>
void ShowList(const T& val, Args... args) {
	cout << "ShowList(val：" << sizeof...(args) << " -- 参数包：";
	cout << val << "）" << endl;
	ShowList(args...);
}
```

### 逗号表达式展开参数包

### 包扩展

### 转发参数包

可以组合使用可变参数模板与 `std::forward` 来编写函数，以实现保留实参性质不变地传递给其他函数

# 模版元编程