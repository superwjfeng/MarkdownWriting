## *简介*

正则表达式是正则语言，使用单个字符串来描述、匹配一系列符合某个语法规则的字符串。在很多文本编辑器里，正则表达式都被用来检索、替换或者说**模糊匹配**那些符合某个模式 pattern 的文本。在Linux中，grep、sed、awk等文本处理工具都支持通过正则表达式来进行模式匹配

正则语言不仅限于某种特定编程语言，它在许多编程语言中都有支持，包括但不限于Perl、Python、Java、C++、JavaScript等

注意：**正则表达式的修饰符在不同编程语言和正则表达式引擎中可能会有些许不同**，因此在使用时，请查看相应的文档以了解支持和行为的详细信息。修饰符可以根据需要进行组合，以满足特定的匹配需求，从而提高正则表达式的灵活性和功能

## *元字符*

正则语言的元字符是一组特殊字符，它们具有特殊的含义，**用于在正则表达式中表示模式和匹配规则**。这些元字符通常不表示字面字符，而是表示一些特定的文本模式或操作

常规匹配就是一串**不包含**任何特殊字符的正则表达式匹配它自己

### 常用特殊字符用于模糊匹配

* `^` 匹配一行的开头，`^a` 以a开头的行
* `$` 匹配一行的结束，`t$` 以t为结尾的行。`^$` 匹配空行
* `.` **除换行符 `\n` 之外**的任意单个字符，比如 `r..t` 可以匹配任意以r开头，以t结尾的4字单词
* `*` wildcard 匹配前面一个字符零次或多次（任意多次），比如 `ro*t` 可以是rt、rot、root ... 。`.*` 可以匹配任意字符串，比如想要匹配任意以a开头，以bash结尾的字符串 `^a.*bash$`
* `+` 匹配前面一个字符一次或多次（至少一次）
* `?` 匹配前面一个字符零次或一次（至多一次）。例如，`ab?`匹配 "a" 或 "ab"
* `[]` 字符类集合：用于匹配单个字符中的一个字符。例如，`[aeiou]`匹配任何一个元音字母。下面是一些常用的字符类集合
  * `[0-9]` 匹配一个0到9的数字
  * `[0-9]*` 匹配任意长度的数字字符串
  * `[a-z]` 匹配一个a-z的字符
  * `[a-z]*` 匹配任意长度的字符字符串
  * `[A-Za-z0-9]` 匹配A-Z或者a-z或者0-9之间的任意字符
* `[^]`：在字符类内使用脱字符表示匹配除指定字符之外的任何字符。例如，`[^0-9]`匹配任何非数字字符
* `|`（管道符）：用于分隔多个模式，表示“或”关系。例如，`cat|dog`匹配 "cat" 或 "dog"
* `()`（捕获组 capturing group）：用于创建一个捕获组，可以在匹配中提取和操作捕获的子字符串。标记一个子表达式的开始和结束位置，子表达式可以获取供以后使用
* `{}` 用于确定匹配的次数
  * `{n}`：要求字符出现n次
  * `{n,}`：要求字符出现n到多次
  * `{n,m}`：要求字符出现n到m次

* `/` **通常不是正则表达式模式的一部分，而是用于包围正则表达式模式的定界符 delimiter**。在许多编程语言和环境中，正则表达式通常需要包含在斜杠之间，以指示这是一个正则表达式。这种方式有助于解释器或编译器识别正则表达式的开始和结束

### `\` 转义

`\` 表示转义，并不会单独使用。由于所有特殊字符都有其特定的匹配模式，当我们想要匹配某一特殊字符本身时，比如说想要找出所有包含 `$` 的行，就会发生问题，所以此时可以用 `\` 来消除特殊字符的特殊意义

注意：C++中使用时所有带有 `\` 的转义符都要写成 `\\` 转义

* `\A`：匹配输入字符串的开头，与 `^` 不同，它只匹配整个字符串的开始，不受多行模式的影响。
* `\Z`：匹配输入字符串的结尾，与 `$` 不同，它只匹配整个字符串的结尾，不受多行模式的影响。
* `\b`：匹配一个单词边界，用于确保匹配的单词或字符序列处于单词的开头或结尾。例如， `'er\b'` 可以匹配"never" 中的 `'er'`，但不能匹配 `"verb"` 中的 `'er'`
* `\B`：匹配非单词边界，与 `\b` 相反，用于匹配不处于单词边界的位置。`'er\B'` 能匹配 "verb" 中的 `'er'`，但不能匹配 "never" 中的 `'er'`
* `\w`：匹配任何字母、数字或下划线字符，相当于`[a-zA-Z0-9_]`
* `\W`：匹配任何非单词字符，与 `\w` 相反
* `\d`：匹配任何数字字符，相当于`[0-9]`
* `\D`：匹配任何非数字字符，与 `\d` 相反
* `\s`：匹配任何空白字符，包括空格、制表符、换行符等
* `\S`：匹配任何非空白字符，与 `\s` 相反
* `\t`：匹配制表符字符
* `\n`：匹配换行符字符
* `\r`：匹配回车符字符

### `?=`、`?<=`、`?!`、`?<!` 断言

正则表达式中的 `?=`、`?<=`、`?!`、`?<!` 是一些特殊的构造，用于进行正则表达式的先行断言 lookahead 和后行断言 lookbehind。它们允许在匹配模式中添加条件，以便只匹配满足特定条件的文本。以下是它们的作用和用法：

* 正向先行断言 Positive Lookahead
  * 语法：`exp1(?=exp2)`
  * 作用：查找 exp2 前面的 exp1。在当前位置匹配满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之后的文本
  * 示例：`/foo(?=bar)/` 匹配 "foo"，但只有在后面紧跟着 "bar" 的情况下才匹配成功
* 正向后行断言 Positive Lookbehind
  * 语法：`(?<=exp2)exp1`
  * 作用：查找 exp2 后面的 exp1。在当前位置之前匹配满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之前的文本
  * 示例：/(?<=foo)bar/ 匹配 "bar"，但只有在前面紧跟着 "foo" 的情况下才匹配成功
* 负向先行断言 Negative Lookahead
  * 语法：`exp1(?!exp2)`
  * 作用：查找后面不是 exp2 的 exp1。在当前位置匹配不满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之后的文本
  * 示例：/foo(?!bar)/ 匹配 "foo"，但只有在后面不紧跟着 "bar" 的情况下才匹配成功
* 负向后行断言 Negative Lookbehind
  * 语法：`(?<!exp2)exp1`
  * 作用：查找前面不是 exp2 的 exp1。在当前位置之前匹配不满足条件的文本，但不消耗输入字符串。它是一个零宽度断言，只检查当前位置之前的文本
  * 示例：`/(?<!foo)bar/` 匹配 "bar"，但只有在前面不紧跟着 "foo" 的情况下才匹配成功

这些断言允许在匹配模式中添加条件，以限制匹配的范围，或者确保某些文本前后都满足特定条件。它们在处理复杂文本匹配问题时非常有用，但也需要谨慎使用，因为它们可能导致正则表达式变得复杂难懂

### 修饰符

正则表达式中的修饰符是一些可选标志，它们可以附加到正则表达式模式的末尾，以改变匹配行为。这些修饰符通常是单个字母，例如在大多数编程语言中都是单个字符

以下是一些常见的正则表达式修饰符：

* **/i**（不区分大小写）：通常用于匹配时不区分字母大小写。例如，`/abc/i` 可以匹配 "abc"、"AbC"、"aBC" 等。
* **/g**（全局匹配）：通常用于找到所有匹配项，而不仅仅是第一个匹配项。例如，`/abc/g` 可以找到输入字符串中的所有 "abc"
* **/m**（多行匹配）：通常用于处理多行文本，修改 `^` 和 `$` 的行为，使它们匹配每一行的开头和结尾。例如，`/pattern/m` 可以匹配多行文本中的 "pattern"
* **/s**（单行匹配）：通常用于处理单行文本，使 `.` 匹配**包括换行符在内**的任何字符。例如，`/a.b/s` 可以匹配 "a\nb"
* **/x**（扩展模式）：通常用于允许在模式中添加注释和空白字符，以提高可读性。例如，`/a b c/x` 可以匹配 "abc"
* **/u**（Unicode模式）：通常用于处理Unicode字符。它启用了Unicode字符的特殊处理，以便正确匹配Unicode字符。例如，`/\w/u` 可以匹配任何Unicode字母、数字和下划线

## *运算符优先级*

1. `\` 转义符
2. `(), (?:), (?=), []` 圆括号和方括号
3. `*, +, ?, {n}, {n,}, {n,m}` 限定符
4. `^, $, \任何元字符、任何字符` 定位点和序列（即：位置和顺序）
5. `|` 替换，"或"操作。字符具有高于替换运算符的优先级，使得"m|food"匹配"m"或"food"。若要匹配"mood"或"food"，请使用括号创建子表达式，从而产生"(m|f)ood"

## *常用正则表达式*

[正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)

### 校验数字的表达式

* 数字：`^[0-9]*$`
* n位的数字：`^\d{n}$`
* 至少n位的数字：`^\d{n,}$`
* m-n位的数字：`^\d{m,n}$`
* 零和非零开头的数字：`^(0|[1-9][0-9]*)$`
* 非零开头的最多带两位小数的数字：`^([1-9][0-9]*)+(\.[0-9]{1,2})?$`
* 带1-2位小数的正数或负数：`^(\-)?\d+(\.\d{1,2})$`
* 正数、负数、和小数：`^(\-|\+)?\d+(\.\d+)?$`
* 有两位小数的正实数：`^[0-9]+(\.[0-9]{2})?$`
* 有1~3位小数的正实数：`^[0-9]+(\.[0-9]{1,3})?$`
* 非零的正整数：`^[1-9]\d*$` 或 `^([1-9][0-9]*){1,3}$` 或 `^\+?[1-9][0-9]*$`
* 非零的负整数：`^\-[1-9][]0-9"*$` 或 `^-[1-9]\d*$`
* 非负整数：`^\d+$` 或 `^[1-9]\d*|0$`
* 非正整数：`^-[1-9]\d*|0$` 或 `^((-\d+)|(0+))$`
* 非负浮点数：`^\d+(\.\d+)?$` 或 `^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$`
* 非正浮点数：`^((-\d+(\.\d+)?)|(0+(\.0+)?))$` 或 `^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$`
* 正浮点数：`^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$` 或 `^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$`
* 负浮点数：`^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$` 或 `^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$`
* 浮点数：`^(-?\d+)(\.\d+)?$` 或 `^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$`

### 校验字符的表达式

* 汉字：`^[\u4e00-\u9fa5]{0,}$`
* 英文和数字：`^[A-Za-z0-9]+$` 或 `^[A-Za-z0-9]{4,40}$`
* 长度为3-20的所有字符：`^.{3,20}$`
* 由26个英文字母组成的字符串：`^[A-Za-z]+$`
* 由26个大写英文字母组成的字符串：`^[A-Z]+$`
* 由26个小写英文字母组成的字符串：`^[a-z]+$`
* 由数字和26个英文字母组成的字符串：`^[A-Za-z0-9]+$`
* 由数字、26个英文字母或者下划线组成的字符串：`^\w+$` 或 `^\w{3,20}$`
* 中文、英文、数字包括下划线：`^[\u4E00-\u9FA5A-Za-z0-9_]+$`
* 中文、英文、数字但不包括下划线等符号：`^[\u4E00-\u9FA5A-Za-z0-9]+$` 或 `^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$`
* 可以输入含有 `^%&',;=?$\"` 等字符：`[^%&',;=?$\x22]+`
* 禁止输入含有 `~` 的字符：`[^~]+`

### 特殊需求表达式

* Email地址：`^\w+([-+.]\w+)\*@\w+([-.]\w+)\*\.\w+([-.]\w+)\*$`
* 域名：`[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(\.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+\.?`
* Internet URL：`[a-zA-z]+://[^\s]\*` 或 `^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]\*)?$`
* 手机号码：`^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$`
* 电话号码("XXX-XXXXXXX"、"XXXX-XXXXXXXX"、"XXX-XXXXXXX"、"XXX-XXXXXXXX"、"XXXXXXX"和"XXXXXXXX)：`^(\(\d{3,4}-)|\d{3.4}-)?\d{7,8}$`
* 国内电话号码(0511-4405222、021-87888822)：`\d{3}-\d{8}|\d{4}-\d{7}`
* 电话号码正则表达式（支持手机号码，3-4位区号，7-8位直播号码，1－4位分机号）: `((\d{11})|^((\d{7,8})|(\d{4}|\d{3})-(\d{7,8})|(\d{4}|\d{3})-(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1})|(\d{7,8})-(\d{4}|\d{3}|\d{2}|\d{1}))$)`
* 身份证号(15位、18位数字)，最后一位是校验位，可能为数字或字符X：`(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)`
* 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：`^[a-zA-Z][a-zA-Z0-9_]{4,15}$
* 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：`^[a-zA-Z]\w{5,17}$`
* 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：`^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z])[a-zA-Z0-9]{8,10}$`
* 强密码(必须包含大小写字母和数字的组合，可以使用特殊字符，长度在8-10之间)：`^(?=.\*\d)(?=.\*[a-z])(?=.\*[A-Z]).{8,10}$`
* 日期格式：`^\d{4}-\d{1,2}-\d{1,2}`
* 一年的12个月(01～09和1～12)：`^(0?[1-9]|1[0-2])$`
* 一个月的31天(01～09和1～31)：`^((0?[1-9])|((1|2)[0-9])|30|31)$`
* 钱的输入格式：
  1. 有四种钱的表示形式我们可以接受:"10000.00" 和 "10,000.00", 和没有 "分" 的 "10000" 和 "10,000"：`^[1-9][0-9]\*$`
  2. 这表示任意一个不以0开头的数字,但是,这也意味着一个字符"0"不通过,所以我们采用下面的形式：`^(0|[1-9][0-9]\*)$`
  3. 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：`^(0|-?[1-9][0-9]\*)$`
  4. 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧。下面我们要加的是说明可能的小数部分：`^[0-9]+(.[0-9]+)?$`
  5. 必须说明的是,小数点后面至少应该有1位数,所以"10."是不通过的,但是 "10" 和 "10.2" 是通过的：`^[0-9]+(.[0-9]{2})?$`
  6. 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：`^[0-9]+(.[0-9]{1,2})?$`
  7. 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：`^[0-9]{1,3}(,[0-9]{3})\*(.[0-9]{1,2})?$`
  8. 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：`^([0-9]+|[0-9]{1,3}(,[0-9]{3})\*)(.[0-9]{1,2})?$`
  9. 备注：这就是最终结果了,别忘了"+"可以用"*"替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里
* xml文件：`^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$`
* 中文字符的正则表达式：`[\u4e00-\u9fa5]`
* 双字节字符：`[^\x00-\xff]` (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))
* 空白行的正则表达式：`\n\s\*\r` (可以用来删除空白行)
* HTML标记的正则表达式：`<(\S\*?)[^>]\*>.\*?|<.\*? />` ( 首尾空白字符的正则表达式：`^\s\*|\s\*$` 或 `(^\s\*)|(\s\*$)` (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)
* 腾讯QQ号：`[1-9][0-9]{4,}` (腾讯QQ号从10000开始)
* 中国邮政编码：`[1-9]\d{5}(?!\d)` (中国邮政编码为6位数字)
* IPv4地址：`((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})(\.((2(5[0-5]|[0-4]\d))|[0-1]?\d{1,2})){3}`