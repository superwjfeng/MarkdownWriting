# 响应式编程

## *响应式宣言*

[The Reactive Manifesto](https://www.reactivemanifesto.org/)

<img src="响应式编程宣言.webp">

响应式编程是一种面向数据流和变化传播的编程范式，旨在简化事件驱动应用的实现。响应式编程专注于如何创建依赖于变更的数据流并对变化做出响应



函数响应式编程 Functional Reactive Programming, FRP：通过一系列的操作符，RxCpp允许开发者将异步操作视为数据流进行处理，简化了复杂的并发和事件处理问题





## *响应式编程要解决的问题*

### 回调地狱

所谓的回调函数 callback function 就是指当一个函数作为参数传入另一个参数中，并且它不会立即执行，只有当满足一定条件后该函数才可以执行，这种函数就称为回调函数

回调地狱 callback hell 就是为是实现代码顺序执行而在回调函数中嵌套回调函数，它会造成我们的代码可读性非常差，后期不好维护



### fire and forget mechanism

Fire and forget 通常指的是一种处理流程或者函数调用的方式，其中一旦发起了一个操作（如发送一个请求、开始一个异步任务等），便不需要进一步地进行跟踪或管理。这个操作将独立于发起者自行完成其全部工作。在这种模式下，发起操作的代码不会等待操作的完成、也不会获取操作结果的反馈

其实就是异步的一种说法

# RxCpp

Reactive Extensions (ReactiveX, Rx)。Rx是一个编程模型，目标是提供一致的编程接口，帮助开发者更方便的处理异步数据流，Rx库支持.NET、JavaScript和C++，Rx近几年越来越流行了，现在已经支持几乎全部的流行编程语言了

下面介绍 RxCpp [ReactiveX/RxCpp: Reactive Extensions for C++ (github.com)](https://github.com/ReactiveX/RxCpp)



> ReactiveX is a library for composing asynchronous and event-based programs by using observable sequences. Rx 是一个使用可观测的序列来组成异步的、基于事件的程序的库。



### push & pull

* push 异步推送数据模式：应用程序在数据检索过程中是被动的：除了订阅了可观察的数据源之外，它不会主动轮询数据源，而只是对推送到它的数据做出反应。但是当流不再没有更多数据或者出错时，数据源也会向订阅者发送通知
* pull 同步拉取数据模式：应用程序在数据检索过程中处于活动状态，在方便时通过调用 on_next 来控制检索的速度。这种模式是同步的，这意味着应用程序可能在轮询数据源时被阻塞

响应式编程采用push 推送模式。通过订阅数据流（在Rx中称为可观察序列 Obsrevable）来向应用程序提供数据。Rx 实现的推送模型由 Rx.Observable/Observer 的可观察模式表示。Rx.Observable 将自动通知所有观察者任何状态变化。如果要通过订阅注册，可以使用 Rx.Observable 的 subscribe 方法，该方法接受一个 Observer 并返回一个一次性的。随后 Observer 能够跟踪和处置订阅

## *架构*

### 核心概念

数据流 stream 的思想和体系结构中的dataflow架构很相似

1. 一切皆为数据流

2. Observable 可观察对象 是对数据流的抽象，表示有限或者无限多个现在或者将来到达的事件。Observable提供了onNext，onError，onCompleted供开发者定制新元素到达，出现错误，或者流结束时的程序的行为

3. Observer 观察者 是对Observable的响应

4. Operator 是处于观察者与被观察者之间的流操作符。不同的流操作符如`map`, `filter`, `merge`, `zip`等则提供了对数据流的强大控制，使得我们可以像处理数组一样处理异步数据

   反应式编程的一个关键优势在于它的可组合性。不同数据流可以相互组合，创建出新的数据流，这极大地提高了代码的复用性和可读性

### 架构图

<img src="RxCpp架构.jpeg">

## *Observable*

**为了从 observable 集合接收通知，您使用 Observable 的 subscribe 方法将 Observer 对象传递给它**。作为对这个观察者的回报，**subscribe 方法返回一个一次性对象，该对象充当订阅的句柄。****这允许您在完成后清理订阅。对该对象调用 dispose 会将观察者与源分离，以便不再传递通知。**正如你可以推断的，在 Rx 中你不需要显式地取消订阅一个事件

## *Subject*

**Subject 类型同时实现了 Observable 和 Observer，**从某种意义上说，**它既是观察者又是可观察对象。**您可以使用主题订阅所有观察者，然后将主题订阅到后端数据源。这样，**主体可以充当一组订阅者和源的代理**。您可以使用主题来实现具有缓存、缓冲和时移的自定义 observable。此外，您可以使用主题向多个订阅者广播数据。

**默认情况下，主题不会跨线程执行任何同步。**他们不采用调度程序，而是假设所有序列化和语法正确性都由主题的调用者处理。**主题只是向订阅者线程安全列表中的所有订阅观察者广播。**这样做的好处是可以减少开销并提高性能。但是，如果您想使用调度程序同步对观察者的传出调用，则可以使用 Synchronize 方法来执行此操作





### Marble Diagram

# 算子

[ReactiveX - Operators](https://reactivex.io/documentation/operators.html#conditional)

大部分算子都是作用在Obsrevable上，然后返回一个Observable的

## *Creating Observables*

Operators that originate new Observables.

- [**`Create`**](https://reactivex.io/documentation/operators/create.html) — create an Observable from scratch by calling observer methods programmatically。该算子在RxCpp中不存在
- [**`Defer`**](https://reactivex.io/documentation/operators/defer.html) — do not create the Observable until the observer subscribes, and create a fresh Observable for each observer
- [**`Empty`/`Never`/`Throw`**](https://reactivex.io/documentation/operators/empty-never-throw.html) — create Observables that have very precise and limited behavior
- [**`From`**](https://reactivex.io/documentation/operators/from.html) — convert some other object or data structure into an Observable
- [**`Interval`**](https://reactivex.io/documentation/operators/interval.html) — create an Observable that emits a sequence of integers spaced by a particular time interval
- [**`Just`**](https://reactivex.io/documentation/operators/just.html) — convert an object or a set of objects into an Observable that emits that or those objects
- [**`Range`**](https://reactivex.io/documentation/operators/range.html) — create an Observable that emits a range of sequential integers
- [**`Repeat`**](https://reactivex.io/documentation/operators/repeat.html) — create an Observable that emits a particular item or sequence of items repeatedly
- [**`Start`**](https://reactivex.io/documentation/operators/start.html) — create an Observable that emits the return value of a function
- [**`Timer`**](https://reactivex.io/documentation/operators/timer.html) — create an Observable that emits a single item after a given delay

## *Transforming Observables*

Operators that transform items that are emitted by an Observable.

- [**`Buffer`**](https://reactivex.io/documentation/operators/buffer.html) — periodically gather items from an Observable into bundles and emit these bundles rather than emitting the items one at a time
- [**`FlatMap`**](https://reactivex.io/documentation/operators/flatmap.html) — transform the items emitted by an Observable into Observables, then flatten the emissions from those into a single Observable
- [**`GroupBy`**](https://reactivex.io/documentation/operators/groupby.html) — divide an Observable into a set of Observables that each emit a different group of items from the original Observable, organized by key
- [**`Map`**](https://reactivex.io/documentation/operators/map.html) — transform the items emitted by an Observable by applying a function to each item
- [**`Scan`**](https://reactivex.io/documentation/operators/scan.html) — apply a function to each item emitted by an Observable, sequentially, and emit each successive value
- [**`Window`**](https://reactivex.io/documentation/operators/window.html) — periodically subdivide items from an Observable into Observable windows and emit these windows rather than emitting the items one at a time

## *Filtering Observables*

Operators that selectively emit items from a source Observable.

- [**`Debounce`**](https://reactivex.io/documentation/operators/debounce.html) — only emit an item from an Observable if a particular timespan has passed without it emitting another item
- [**`Distinct`**](https://reactivex.io/documentation/operators/distinct.html) — suppress duplicate items emitted by an Observable
- [**`ElementAt`**](https://reactivex.io/documentation/operators/elementat.html) — emit only item *n* emitted by an Observable
- [**`Filter`**](https://reactivex.io/documentation/operators/filter.html) — emit only those items from an Observable that pass a predicate test
- [**`First`**](https://reactivex.io/documentation/operators/first.html) — emit only the first item, or the first item that meets a condition, from an Observable
- [**`IgnoreElements`**](https://reactivex.io/documentation/operators/ignoreelements.html) — do not emit any items from an Observable but mirror its termination notification
- [**`Last`**](https://reactivex.io/documentation/operators/last.html) — emit only the last item emitted by an Observable
- [**`Sample`**](https://reactivex.io/documentation/operators/sample.html) — emit the most recent item emitted by an Observable within periodic time intervals
- [**`Skip`**](https://reactivex.io/documentation/operators/skip.html) — suppress the first *n* items emitted by an Observable
- [**`SkipLast`**](https://reactivex.io/documentation/operators/skiplast.html) — suppress the last *n* items emitted by an Observable
- [**`Take`**](https://reactivex.io/documentation/operators/take.html) — emit only the first *n* items emitted by an Observable
- [**`TakeLast`**](https://reactivex.io/documentation/operators/takelast.html) — emit only the last *n* items emitted by an Observable

## *Combining Observables*

Operators that work with multiple source Observables to create a single Observable

- [**`And`/`Then`/`When`**](https://reactivex.io/documentation/operators/and-then-when.html) — combine sets of items emitted by two or more Observables by means of `Pattern` and `Plan` intermediaries
- [**`CombineLatest`**](https://reactivex.io/documentation/operators/combinelatest.html) — when an item is emitted by either of two Observables, combine the latest item emitted by each Observable via a specified function and emit items based on the results of this function
- [**`Join`**](https://reactivex.io/documentation/operators/join.html) — combine items emitted by two Observables whenever an item from one Observable is emitted during a time window defined according to an item emitted by the other Observable
- [**`Merge`**](https://reactivex.io/documentation/operators/merge.html) — combine multiple Observables into one by merging their emissions
- [**`StartWith`**](https://reactivex.io/documentation/operators/startwith.html) — emit a specified sequence of items before beginning to emit the items from the source Observable
- [**`Switch`**](https://reactivex.io/documentation/operators/switch.html) — convert an Observable that emits Observables into a single Observable that emits the items emitted by the most-recently-emitted of those Observables
- [**`Zip`**](https://reactivex.io/documentation/operators/zip.html) — combine the emissions of multiple Observables together via a specified function and emit single items for each combination based on the results of this function

## *Error Handling Operators*

Operators that help to recover from error notifications from an Observable

- [**`Catch`**](https://reactivex.io/documentation/operators/catch.html) — recover from an `onError` notification by continuing the sequence without error
- [**`Retry`**](https://reactivex.io/documentation/operators/retry.html) — if a source Observable sends an `onError` notification, resubscribe to it in the hopes that it will complete without error

## *Observable Utility Operators*

A toolbox of useful Operators for working with Observables

- [**`Delay`**](https://reactivex.io/documentation/operators/delay.html) — shift the emissions from an Observable forward in time by a particular amount
- [**`Do`**](https://reactivex.io/documentation/operators/do.html) — register an action to take upon a variety of Observable lifecycle events
- [**`Materialize`/`Dematerialize`**](https://reactivex.io/documentation/operators/materialize-dematerialize.html) — represent both the items emitted and the notifications sent as emitted items, or reverse this process
- [**`ObserveOn`**](https://reactivex.io/documentation/operators/observeon.html) — specify the scheduler on which an observer will observe this Observable
- [**`Serialize`**](https://reactivex.io/documentation/operators/serialize.html) — force an Observable to make serialized calls and to be well-behaved
- [**`Subscribe`**](https://reactivex.io/documentation/operators/subscribe.html) — operate upon the emissions and notifications from an Observable
- [**`SubscribeOn`**](https://reactivex.io/documentation/operators/subscribeon.html) — specify the scheduler an Observable should use when it is subscribed to
- [**`TimeInterval`**](https://reactivex.io/documentation/operators/timeinterval.html) — convert an Observable that emits items into one that emits indications of the amount of time elapsed between those emissions
- [**`Timeout`**](https://reactivex.io/documentation/operators/timeout.html) — mirror the source Observable, but issue an error notification if a particular period of time elapses without any emitted items
- [**`Timestamp`**](https://reactivex.io/documentation/operators/timestamp.html) — attach a timestamp to each item emitted by an Observable
- [**`Using`**](https://reactivex.io/documentation/operators/using.html) — create a disposable resource that has the same lifespan as the Observable

## *Conditional and Boolean Operators*

Operators that evaluate one or more Observables or items emitted by Observables

- [**`All`**](https://reactivex.io/documentation/operators/all.html) — determine whether all items emitted by an Observable meet some criteria
- [**`Amb`**](https://reactivex.io/documentation/operators/amb.html) — given two or more source Observables, emit all of the items from only the first of these Observables to emit an item
- [**`Contains`**](https://reactivex.io/documentation/operators/contains.html) — determine whether an Observable emits a particular item or not
- [**`DefaultIfEmpty`**](https://reactivex.io/documentation/operators/defaultifempty.html) — emit items from the source Observable, or a default item if the source Observable emits nothing
- [**`SequenceEqual`**](https://reactivex.io/documentation/operators/sequenceequal.html) — determine whether two Observables emit the same sequence of items
- [**`SkipUntil`**](https://reactivex.io/documentation/operators/skipuntil.html) — discard items emitted by an Observable until a second Observable emits an item
- [**`SkipWhile`**](https://reactivex.io/documentation/operators/skipwhile.html) — discard items emitted by an Observable until a specified condition becomes false
- [**`TakeUntil`**](https://reactivex.io/documentation/operators/takeuntil.html) — discard items emitted by an Observable after a second Observable emits an item or terminates
- [**`TakeWhile`**](https://reactivex.io/documentation/operators/takewhile.html) — discard items emitted by an Observable after a specified condition becomes false

## *Mathematical and Aggregate Operators*

Operators that operate on the entire sequence of items emitted by an Observable

- [**`Average`**](https://reactivex.io/documentation/operators/average.html) — calculates the average of numbers emitted by an Observable and emits this average
- [**`Concat`**](https://reactivex.io/documentation/operators/concat.html) — emit the emissions from two or more Observables without interleaving them
- [**`Count`**](https://reactivex.io/documentation/operators/count.html) — count the number of items emitted by the source Observable and emit only this value
- [**`Max`**](https://reactivex.io/documentation/operators/max.html) — determine, and emit, the maximum-valued item emitted by an Observable
- [**`Min`**](https://reactivex.io/documentation/operators/min.html) — determine, and emit, the minimum-valued item emitted by an Observable
- [**`Reduce`**](https://reactivex.io/documentation/operators/reduce.html) — apply a function to each item emitted by an Observable, sequentially, and emit the final value
- [**`Sum`**](https://reactivex.io/documentation/operators/sum.html) — calculate the sum of numbers emitted by an Observable and emit this sum

## *Backpressure Operators*

如何形象的描述反应式编程中的背压(Backpressure)机制？ - 扔物线的回答 - 知乎
https://www.zhihu.com/question/49618581/answer/237078934

### 什么是backpressure

> **在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出，这种现象就叫做 Backpressure 出现。**需要强调的是：这句话的重点不在于「上游生产速度大于下游消费速度」，而在于**「Buffer 溢出」**。

### backpressure算子的使用

## *Connectable Observable Operators*

Specialty Observables that have more precisely-controlled subscription dynamics

- [**`Connect`**](https://reactivex.io/documentation/operators/connect.html) — instruct a connectable Observable to begin emitting items to its subscribers
- [**`Publish`**](https://reactivex.io/documentation/operators/publish.html) — convert an ordinary Observable into a connectable Observable
- [**`RefCount`**](https://reactivex.io/documentation/operators/refcount.html) — make a Connectable Observable behave like an ordinary Observable
- [**`Replay`**](https://reactivex.io/documentation/operators/replay.html) — ensure that all observers see the same sequence of emitted items, even if they subscribe after the Observable has begun emitting items

## *Operators to Convert Observables*

- [**`To`**](https://reactivex.io/documentation/operators/to.html) — convert an Observable into another object or data structure

# 自定义算子