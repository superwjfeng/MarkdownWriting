# Linux发展史 & 标准

## *UNIX*

### UNIX的定义

* 指通过 SUS, Single UNIX Specification 所规范的官方一致性测试,且由OPEN GROUP（UNIX 商标的持有者）正式授权冠以“UNIX”的操作系统
* 运作方式类似于经典 UNIX 系统的操作系统

### UNIX & C的早期历史

1. 1960年代初：1969年，由美国贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等计算机科学家创建。最初的UNIX系统是为PDP-7和PDP-11等小型计算机设计的，旨在提供一个多用户、多任务的操作系统，用于支持科学和研究计算

2. 1970年代：在70年代初，UNIX系统逐渐发展壮大， Dennis Ritchie 设计并实现出了C编程语言，这成为后来UNIX系统的主要编程语言。C语言的设计受到了汇编语言和BCPL语言的影响，它具有直接的硬件访问能力、高效的内存管理和丰富的控制结构，使其非常适合系统编程。

   实现C语言的初衷就是为了实现 UNIX 内核及其相关软件而开发一种高层语言。这也是为什么C/C++成为了系统编程的首要语言。C的出现在当时填补了系统编程方面的语言空白

3. 1973年：UNIX操作系统的第一个正式版本被称为UNIX第四版（UNIX Version 4），这个版本是用C语言编写的。这标志着C语言与UNIX系统的密切结合，使得UNIX能够更容易地在不同的硬件平台上移植，因为C语言具有可移植性

   UNIX 因此也一变而为最早以高级语言开发而成的操作系统之一

4. 1975 年 3 月发布的第六版UNIX是在 AT&T 之外广泛使用的首个 UNIX 版本

## *UNIX家族*

1980年代：UNIX系统分化出了多个不同的分支，包括AT&T的System III和System V，以及 UC Berkeley 的BSD, Berkeley Software Distribution。这些分支在功能和特性上有所不同，但它们都继承了UNIX的核心思想，并继续使用C语言进行开发和扩展

<img src="UNIX时间线.png">

Source: Wikipedia https://en.wikipedia.org/wiki/History_of_Unix

### BSD家族

受母校 UC Berkeley 之邀， Ken Thompson 于 1975/1976 学年曾担任该校的客座教授。在此期间，他与研究生们一起为 UNIX 开发了许多新特性和工具。比如说C shell、vi 编辑器、一种改进型的文件系统(伯克利快速文件系统) 、sendmail、Pascal 语言编译器，以及用于新型 Digital V AX 架构的虚拟内存管理机制

1. 1979年12月，诞生了首个完整的 UNIX 发布版 3BSD
2. 1983年的4.2BSD：这是BSD家族的第一个重要版本，于1983年发布。它引入了许多重要的功能，如完整的TCP/IP网络协议栈实现、虚拟内存系统和套接字编程接口。4.2BSD对互联网的发展产生了深远的影响，并成为后来BSD版本的基础

BSD的著名版本，基本都是开源软件

1. FreeBSD：FreeBSD是BSD家族中最著名和广泛使用的实现之一。它注重性能和可用性，广泛应用于服务器环境和大规模应用。FreeBSD具有强大的网络功能和可扩展性，还支持Jails技术，允许虚拟化多个独立的操作系统环境
2. OpenBSD：OpenBSD专注于安全性和代码审查，其目标是创建最安全的操作系统。它具有强大的网络安全功能和默认启用的安全设置。OpenBSD还维护了OpenSSH项目，这是一种用于加密远程通信的开源工具
3. NetBSD：NetBSD是一个注重可移植性的BSD分支，其目标是在各种硬件平台上运行。它的主要特点之一是广泛的硬件支持，使其成为嵌入式系统和各种设备的首选操作系统。NetBSD还注重代码的清晰性和可维护性
4. DragonFly BSD：DragonFly BSD是一个专注于多处理器 SMP 系统的BSD分支，它的目标是提供高性能的多核心支持。它采用了一种全新的虚拟内存系统，以提高系统的扩展性和性能

### System V家族

在BSD蓬勃发展的同时，由于AT&T受到反垄断法的拆分，随着其在电话系统市场垄断地位的丧失，AT&T 也因而获准销售 UNIX

1. System III 由 AT&T 所属的 UNIX 支撑团队 UNIX Support Group, USG 研发, 该团队雇佣了数以百计的研发人员来从事 UNIX 系统的增强以及应用开发（尤其针对文档预备软件包和软件开发工具）
2. 1983 年，System V 的首个发布版发布。在经过一系列发布后，USG 最终于 1989 年推出了 System V Release 4(SVR4) ，此时的 System V 吸收了 BSD 的诸多特性，比如说联网能力。AT&T 将 System V 授权给不同厂商，这些厂商又将其作为自身 UNIX 实现的基础

System V的著名版本，基本都是商业软件

1. AT&T UNIX System V：AT&T UNIX System V是System V的官方实现，起源于贝尔实验室。它是System V操作系统的基础版本，后来的System V版本都是从它分支出来的
2. IBM AIX：IBM的AIX操作系统是基于System V的UNIX实现，旨在运行IBM的大型服务器和工作站。它具有强大的企业级特性和可扩展性
3. HP-UX：惠普（Hewlett-Packard）的HP-UX是另一种基于System V的UNIX实现，用于HP的服务器和工作站。它提供了高性能的计算和可靠性
4. Solaris：Solaris是Sun Microsystems（后来被Oracle收购）开发的UNIX操作系统。它基于System V Release 4（SVR4），具有强大的网络和存储功能。Solaris曾经是企业级UNIX操作系统的领先选择

## *GNU & Linux内核*

### GNU & Linux

GNU, GNU's Not Unix 是一个自由软件项目，它是一个由 Richard Stallman 于1983年发起的计算机操作系统项目，旨在创建一个自由、开源的类UNIX操作系统。GNU项目的目标是提供一个完全自由的操作系统，使用户可以自由运行、复制、分发、学习、修改和改进软件

以下是关于GNU项目的一些重要信息：

1. 自由软件：GNU强调自由软件的理念，即用户应该具有运行、研究、分享和修改软件的自由。为了保护这些自由，GNU采用了GNU通用公共许可证（GNU General Public License，GPL）等自由软件许可协议，确保软件的自由性不受侵犯
2. 工具和应用：GNU项目不仅涉及操作系统内核的开发，还包括了一系列工具、库和应用程序的开发。其中一些著名的GNU工具包括GNU C编译器（GCC）、GNU调试器（GDB）、GNU文本编辑器（Emacs）等
3. GNU/Linux：虽然GNU项目开发了大部分操作系统组件，但在早期，还缺少一个称为内核的关键组件。因此，Richard Stallman 与 Linus Torvalds 合作，将Linux内核与GNU工具和应用程序相结合，创造了GNU/Linux操作系统，也被简称为Linux。这个组合成为了开源社区中最流行的操作系统之一
4. GNU自由文档许可证：GNU项目还为文档和教育资料提供了自由文档许可证（GNU Free Documentation License，GFDL），以保护用户对于文档的自由使用和分发
5. 社区参与：GNU项目鼓励开发者和用户积极参与，为自由软件的开发和改进做出贡献。社区支持和合作在GNU项目的成功中起到了关键作用

### Linux版本号

1. Linux 0.01（1991年）：这是Linux内核的首个公开发布版本，由 Linus Torvalds 发布。它只包含了约10,000行代码，仅支持Intel 386处理器
2. Linux 0.95（1992年）：这个版本引入了虚拟文件系统（Virtual File System，VFS），这是一个允许Linux支持多种文件系统的重要组件
3. Linux 1.0（1994年）：这是Linux内核的首个正式稳定版本，标志着Linux成熟为可用于生产环境的操作系统
4. Linux 2.0（1996年）：这个版本引入了对Symmetric Multiprocessing（SMP）的支持，使Linux能够在多处理器系统上运行。此外，它还增加了对新的硬件设备的支持
5. Linux 2.2（1999年）：这个版本带来了TCP/IP栈的性能改进，使Linux成为一个更好的网络服务器。它还增加了对USB设备的支持
6. Linux 2.4（2001年）：这个版本进一步改进了SMP支持、网络性能和硬件兼容性。它引入了防火墙功能（Netfilter/Iptables）
7. **Linux 2.6（2003年）：这个版本引入了动态调度器、完善的电源管理、内存管理改进以及更好的性能和稳定性。2.6内核系列维持了很长时间，成为许多发行版的基础**
8. Linux 3.x（2011年）：这个版本引入了很多新的硬件支持和性能优化，同时也改进了文件系统和虚拟化支持
9. Linux 4.x（2015年）：这个版本继续增加了新硬件的支持，改进了内存管理、文件系统、安全性和性能
10. Linux 5.x（2019年）：这个版本引入了许多新功能，包括实时内核调度、I/O性能优化、显著改进的网络性能以及新的文件系统特性
11. Linux 6.x（预期）：未来的Linux内核版本将继续演进，以满足新的硬件和应用需求，增加新的功能和改进性能、安全性等方面的特性

Linux内核版本号在2.6之前确实采用了x.y.z（主版本号、次版本号和修订号）的格式

### Linux发行版

准确来说，Linux指的是Linus Torvalds及社区开发的Linux内核，不过也可以指Linux的软件包（工具和库），这些软件包可以被商业化形成不同的发行版 Linux distribution

发行版的目的是为了简化Linux操作系统的安装、配置和维护，以满足不同用户的需求和用途。每个发行版都可以有自己的特点和目标受众

* Ubuntu：用户友好、易用性强、大量的软件包、广泛社区支持。适用于桌面、服务器和云计算
* Debian：稳定性强、广泛的软件包支持、强调自由软件。适用于桌面、服务器和嵌入式系统
* CentOS（现在称为CentOS Stream）：稳定性强、面向企业、与Red Hat Enterprise Linux, RHEL 兼容。适用于：企业服务器和工作站
* Fedora：先进的软件、最新技术、社区驱动。适用于：桌面和开发者
* Red Hat Enterprise Linux, RHEL：企业级支持、长期支持（LTS）、面向企业客户。适用于：大型企业和数据中心
* SUSE Linux Enterprise Server, SLES：企业级支持、高可用性、面向企业客户。适用于：大型企业和数据中心
* Arch Linux：滚动更新、高度可定制、面向高级用户
* Manjaro：用户友好的Arch Linux分支、易用性强
* Slackware：古老而稳定、简单、面向高级用户

### License

下面是一些常见的开源许可证

* MIT许可证：
   * 允许用户在几乎任何情况下自由使用、修改、复制和分发项目
   * 要求在项目中包含原始许可证和版权声明
   * MIT许可证非常宽松，允许其他人在几乎不受限制的情况下使用代码
* BSD许可证：
   * 有多个变种，如2-Clause BSD、3-Clause BSD等
   * 允许几乎不受限制地使用、修改和分发代码，类似于MIT许可证
   * 通常只要求在源代码中包含原始许可证和版权声明
* GNU通用公共许可证（GPL）：
   * 分为GPLv2和GPLv3两个主要版本，其中GPLv3具有更多的保护措施和约束
   * 强制要求所有派生作品也必须采用相同的GPL许可证，以保持开源性
   * 用于确保开源项目的自由和共享，但可能对商业应用产生一些限制
* Apache许可证：
   * 允许用户使用、修改、分发和用于商业目的
   * 对专利权有一些附加规定，以确保贡献者不会通过专利权来限制其他人的使用
   * 适用于需要保护知识产权并允许广泛使用的项目
* GNU较宽松公共许可证（LGPL）：
   * 允许将LGPL许可的代码链接到封闭源码项目中，而不会强制整个项目采用LGPL
   * 通常用于开发库或组件，使其在广泛的应用程序中可用
* Creative Commons许可证：
   * 主要用于非代码内容，如文档、图像、音频和视频
   * 允许创建者定义一系列条件，如是否允许商业用途、是否要求署名等

## *UNIX标准化*

### POSIX & SUS

<img src="UNIX标准时间表.png" width="50%">

* IEEE 的 POSIX 标准
  * POSIX, Portable Operating System Interface 可移植操作系统 最初由IEEE制定，以确保UNIX操作系统在不同系统上的可移植性。POSIX定义了一系列API（应用程序编程接口）和命令行工具，包括文件操作、进程管理、信号处理、线程控制、网络编程和 Shell 命令等。POSIX标准的目标是使开发人员能够编写在不同UNIX系统上可移植的应用程序
  * POSIX大致可以分为POSIX.1和POSIX.2（对UNIX中的shell和各种工具定义了标准），最新的标准是POSIX.1-2017
* The Open Group 的 SUS 标准
  * 1996年，X/Open 与 Open Software Foundation, OSF 开放软件基金会合并，成立了 The Open Group。几乎每家与UNIX 系统有关的公司或组织都是 The Open Group 的会员，该组织持续着对 API 标准的开发
  * SUS, Single UNIX Specification 由The Open Group制定和维护，它包括了UNIX操作系统的核心和可选组件
* 统一POSIX和SUS
  * 1999 年开始，出于修订并加强 POSIX 标准和 SUS 规范的目的，IEEE、The Open Group 以及 ISO/IEC 联合技术委员会共同成立了奥斯丁公共标准修订工作组 The Austin Common Standards Revision Group, CSRG
  * 2001 年 12 月，该工作组正式批准了 POSIX 1003.1-2001，有时也简称为 POSIX.1-2001。随后又获批为 ISO 标准：ISO/IEC 9945:2002)
  * POSIX 1003.1-2001 是具有里程碑意义的UNIX标准，它取代了 SUSv2、POSIX.1、POSIX.2 以及大批的早期 POSIX 标准。有时, 人们也将该标准称为SUSv3。通过 SUSv3 认证的 UNIX 实现可被称为 UNIX 03
  * 2008年，Austin CSRG又推出了 POSIX.1-2008/SUSv4

### ABI

ABI, Application Binary Interface 应用程序二进制接口相比于语言层面的API更加严格和难以实现，定义了编程语言编译器和操作系统之间的接口规范，从而实现一次编译成型后在不同的ISA上都可以运行

ABI没有提供显式接口，而是由内核和工具链 toolchain 定义和实现的

ABI包括了以下方面的规范：

* 数据表示：定义了数据类型的表示方式，包括整数、浮点数、字符等。它规定了数据的字节顺序、对齐方式以及数据在内存中的布局
* 函数调用约定：规定了函数的参数传递方式、寄存器的使用规则、栈的管理方式以及函数调用的返回值处理方法。不同的架构和操作系统可能有不同的函数调用约定
* 寄存器使用：定义了哪些寄存器是可用的、用于哪些目的、以及在函数调用时如何保存和恢复寄存器的值
* 异常处理：规定了异常、中断和系统调用的处理方式，包括如何触发和响应这些事件，以及如何传递异常信息
* 系统调用：定义了操作系统提供的服务和函数调用接口，包括如何通过系统调用访问操作系统功能，例如文件系统、进程管理、网络通信等
* 共享库：规定了共享库（也称为动态链接库）的格式、加载方式以及运行时链接过程，以便不同程序可以共享和重用代码

# 系统调用

## *系统调用的封装 & 使用*

### 封装流程

<img src="系统调用封装流程.drawio.png" width="70%">

1. 用户层的函数调用：在用户层，系统调用通常通过标准库函数（如 glibc）提供的封装接口调用。例如，当在 C 程序中调用 `read()` 或 `write()` 时，实际上是在调用封装了系统调用的标准库函数
2. 封装和转换：这些标准库函数内部会进行一些参数的封装和转换，准备好用于系统调用。它们使用 `syscall` 函数（或类似机制）来发起实际的系统调用。**`syscall` 函数负责将系统调用的编号和参数放到正确的寄存器中**
3. 触发系统调用：接下来，`syscall` 函数会执行一个特殊的指令（如 `int 0x80` 或 `syscall`），这个指令触发一个模式切换从用户模式跳转到内核模式，并将控制权传递给操作系统
4. 系统调用入口点：在内核中，有一个系统调用入口点（通常是一些汇编代码），它根据系统调用的编号将执行流程转发到相应的内核服务函数。这个入口点负责从寄存器中读取系统调用的参数（如果有的话），并将其传递给相应的内核函数
5. 执行系统调用：内核中的系统调用处理函数（如 `sys_read` 或 `sys_write`）接下来执行实际的工作。这可能涉及文件操作、网络通信、进程管理等
6. 返回结果：一旦系统调用处理函数完成，结果和任何输出参数都会被放回到寄存器中。然后控制权返回到系统调用入口点，该入口点接着返回到用户空间
7. 用户空间恢复执行：最后，控制权回到用户空间的 `syscall` 函数，它从寄存器中获取返回值，并将其返回给原始的库函数调用。随后，库函数将这个返回值传递回应用程序
8. 应用程序继续执行：应用程序接收到从库函数返回的系统调用结果，并继续其执行流程

### 以open为例说明封装

以open的封装为例来厘清 C标准库、glibc 运行时库、系统调用和Linux内核之间的关系

首先C标准库是一套标准，而不是一种具体的实现。glibc 动态库（运行时库）是GNU项目的一部分，它是C标准库的一个具体实现

C函数 `fopen`，系统调用 `open`，系统调用 `__libc_open` （glibc/sysdeps/unix/sysv/linux/open.c）和Linux内核 `sys_open` （/fs/open.c），这些是在 C 和 Linux 系统中用于打开文件的函数，它们之间的关系如下：

1. 当应用程序调用 `fopen` 函数时，实际上是调用由 glibc 所提供的一个包装函数 wrapper function（包装函数就是封装了其他函数的函数）。这个包装函数对传递给 `fopen` 的参数进行了一些额外的处理，然后调用 `__fopen_internal` 函数
2. `__fopen_internal` 是 glibc 的内部函数，它实现了实际的文件打开逻辑。它会根据使用的 glibc 版本调用 `open` 或 `__libc_open` 函数
3. `open` 和 `__libc_open` 都是用于打开文件的函数。`open` 是 Linux 内核提供的系统调用，而 `__libc_open` 是 glibc 的内部函数，提供了更灵活的打开文件接口。根据使用的 glibc 版本，`__fopen_internal` 可能会调用 `open` 或 `__libc_open`
4. `sys_open` 是 Linux 内核提供的系统调用，由 `open` 或 `__libc_open` 调用，用于实际打开文件并返回文件描述符，这个文件描述符可用于后续的读写操作

因此，它们之间的调用顺序可以总结如下

1. 应用程序调用 `fopen` 函数
2. glibc 库的包装函数处理参数并调用 `__fopen_internal`
3. `__fopen_internal` 根据使用的 C 库版本调用 `open` 或 `__libc_open`
4. `open` 或 `__libc_open` 调用系统调用 `sys_open` 来打开文件并返回文件描述符
5. `sys_open` 打开文件并返回文件描述符
6. `open` 或 `__libc_open` 将文件描述符返回给 `__fopen_internal`
7. `__fopen_internal` 将 FILE 指针返回给 C 库的包装函数
8. 包装函数将 FILE 指针返回给应用程序

总结一下

* Glibc 是纯语言级别的库，它里面有大量wrapper，涉及到系统的函数会去封装系统调用
* 系统调用是OS封装好暴露出接口交给用户使用的库，system call的时候会发生陷入内核
* Linux内核函数是最底层的库，完全由系统使用，用户无法接触到

### 系统调用的使用方式

* 使用C运行时库

* 使用 `syscall` 函数来调用

  ```c
  syscall(SYS_write, fd, buffer, nbytes);
  ```

  当需要执行没有直接库函数封装的系统调用，或者需要绕过标准库对某个系统调用的特定行为时

  ```c
  #include <unistd.h>
  #include <sys/syscall.h>   /* For SYS_xxx definitions */
  long syscall(long number, ...);
  ```

  * 参数
    * sysno是系统调用号，唯一标识系统调用号，详见 sys/syscall.h
    * `...` 为剩余可变长的参数，为系统调用所带的参数，根据系统调用的不同，可带0~5个不等的参数。若超过特定系统调用能带的参数，多余的参数会被忽略
  * 返回值：该函数返回值为特定系统调用的返回值，在系统调用成功之后可以将该返回值转化为特定的类型，若系统调用失败则返回 -1，错误代码存放在errno中

  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <sys/syscall.h>
  #include <errno.h>
  
  int main() {
      int rc;
      rc = syscall(SYS_chmod, "/etc/passwd", S_IROTH | S_IRGRP | S_IRUSR);
      if (rc == -1) fprintf(stderr, "chmod failed, errno = %d\n", errno);
      else printf("chmod succeess!\n");
      return 0;
  }
  ```

  存在移植性问题：不同系统上的系统调用号可能是不同的，用syscall取调用的话不方便

* 低级访问，直接使用软件中断：这种方式极少使用

  这种方法涉及直接在程序中使用汇编代码，或使用特殊的编译器内置功能来触发系统调用。在x86架构上，这通常通过执行 `int 0x80` 指令（旧的方法）或 `syscall` 指令（较新的方法）完成

  极少数情况下会使用，通常用于深度系统编程或操作系统开发。对于应用程序开发者来说，这种方法通常是不必要的，且难以维护

## *内核空间的实现*

### 系统调用表

系统调用表本质上是一个函数指针数组，每个元素对应一个系统调用处理函数。当用户空间的程序发起一个系统调用时，操作系统使用这个表来查找并调用相应的内核函数。这个表是内核如何处理各种不同系统调用的基础。下面是一种可能的声明

```c
asmlinkage long (*sys_call_table[])(void);
```

当一个程序执行系统调用时（比如通过 `syscall` 指令），系统调用的编号会被传递给内核。内核使用这个编号作为索引到系统调用表中，找到对应的函数指针，然后执行相应的函数

系统编号一般被定义在 asm/unistd.h 中，它就是所有系统调用的宏定义。比如说

```c
#define __NR_restart_SYScall           (__NR_SYSCALL_BASE+   0)
#define __NR_exit                      (__NR_SYSCALL_BASE+   1)
#define __NR_fork                      (__NR_SYSCALL_BASE+   2)
#define __NR_read                      (__NR_SYSCALL_BASE+   3)
#define __NR_write                     (__NR_SYSCALL_BASE+   4)
#define __NR_open                      (__NR_SYSCALL_BASE+   5)
#define __NR_close                     (__NR_SYSCALL_BASE+   6)
```

例如，如果一个程序执行 `read()` 系统调用，操作系统将使用与 `read` 对应的编号在系统调用表中查找，然后调用 `sys_read` 函数

在某些情况下，比如在开发某些类型的内核模块时，可能需要修改系统调用表。这是一个高风险操作，因为不正确的修改可能导致系统不稳定或不安全。在现代的Linux内核中，系统调用表通常是只读的，以防止恶意软件更改

### asmlinkage

`asmlinkage` 是一个在 Linux 内核源代码中经常出现的关键字，它在 C 语言函数和汇编代码之间的接口中扮演了重要的角色

在许多操作系统中，特别是在使用 C 语言编写的系统中，当一个函数被调用时，它的参数通常是通过寄存器或者堆栈传递的。不同的编译器和架构可能有不同的约定来决定使用哪种方式

当执行系统调用时，参数是通过寄存器传递给操作系统的。这是因为系统调用通常是通过特殊的指令（如在 x86 架构上的 `int 0x80` 或 `syscall`）来实现的，这些指令不会像标准的函数调用那样使用堆栈传递参数

`asmlinkage` 标记用于告诉编译器，被标记的函数的所有参数都应该从堆栈中获取，而不是寄存器。这对于系统调用非常重要，因为它们的参数实际上是由用户空间的程序放在堆栈上的，然后由系统调用的入口代码（通常是汇编写的）从堆栈上获取并放入寄存器。内核中相应的系统调用处理函数然后使用 `asmlinkage` 来从堆栈上恢复这些参数

一个带有 `asmlinkage` 的函数定义可能看起来像下面这样，这表示 `sys_my_syscall` 函数期望其参数从堆栈上获取，而不是从寄存器中

```c
asmlinkage long sys_my_syscall(int arg1, char *arg2, ...);
```

## *运行时库*

### 系统调用 System Call 和函数库

* 在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口称为系统调用
* 系统调用在使用上，功能比较基础，对用户的要求相对也比较高。因此开发者会对部分系统调用进行二次开发和适度封装，形成一个供上层开发者使用的库

### glibc wrapper

Wrapper 或 外壳函数 通常是指一个包装或封装另一个函数的函数。这种技术通常用于修改或扩展原始函数的行为，同时保持原始函数的API不变。glibc中的wrapper一般都会调用syscall来陷入内核执行系统调用

标准C语言函数库的实现随UNIX的实现而异。glibc 是 Linux 下使用的开源的标准C库，用于支持Unix-like操作系统的开发。glibc 是 GNU 发布的libc 库，即运行时库。glibc提供了一组标准的C函数和头文件，使程序员能够编写跨平台的C代码，并与操作系统进行交互，执行各种系统级操作

Glibc 实现操作系统提供的系统服务，即系统调用的封装。每个特定的系统调用对应了至少一个 glibc 封装的库函数。多个 API 也可能只对应同一个系统调用

返回值-1在多数情况下表示内核不能满足进程的请求，Libc中定义的errno变量包含特定的出错码

### 确定glibc的版本

* 查看共享库版本号

  ```cmd
  $ ldd main | grep libc
  	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff395ef7000)
  ```

* `gnu_get_libc_version()`

* `confstr()`

## *系统调用的性能*

# 系统设置

## *用户和组*

### 用户

系统的每个用户都拥有唯一的登录名 login name（用户名 username）和与之相对应的整数型用户 ID User ID, UID

系统密码文件 /etc/passwd 为每个用户都定义有一行记录，每行都包含 7 个字段，每个字段之间用冒号分隔

```
用户名 username:经过加密的密码:UID:GID:注释:主目录$HOME:登陆shell$SHELL
wjfeng:x:1002:1002:,,,:/home/wjfeng:/bin/zsh
```

关于密码：要是启用了 shadow 密码（这是常规做法）的话，系统将会不解析该字段。这时 /etc/passwd 中的密码字段通常会包含字母“x” （当然也可以是任何非空字串），而经过加密处理的密码实际上却存储到 shadow 密码文件中。若 /etc/passwd 中密码字段为空，则该账户登录时无需密码

### shadow密码

UNIX 一直在 /etc/passwd 中维护所有的用户信息，这其中就包括经过加密处理的密码，但这会引发安全问题。因为密码是很多非内核程序也需要用到的，所以也需要提供权限给这些程序，这就给密码破解留下了机会

作为一种反制措施，shadow 密码文件 /etc/shadow shadow 单独维护密码文件，仅供具有特权的程序读取

UNIX 系统采用单向加密算法对密码进行加密，需要用下面的 crypt 库函数来进行验证。使用 crypt 时要在编译程序时需开启–lcrypt 选项,以便程序链接 crypt 库

```c
#include <crypt.h>
char *crypt (const char *hey, const char *salt);
			// Returns pointer to statically alocated string containing
			// encrypted password on success, or NULL on error
```

crypt采用DES算法来加密，其中 key 是最长可达 8 字符的密钥，salt 则是一个两字符的字符串，用来扰动 DES 算法

### 组

将用户分组主要是出于便于管理的目的，尤其是为了控制对文件和其他资源的访问

每个用户组都对应着系统组文件 /etc/group 中的一行记录

```
组名:经过加密的密码:GID:用户列表
sudo:x:27:ubuntu,wjfeng
```

### 添加sudo信任

root的UID是0

## *系统限制*

## *获取系统和进程信息*

## *时间*

# 通用文件IO

## *Helper*

### Reminder：C文件接口

* 当前路径：当一个进程运行起来的时候，每个进程都会记录自己当前所处的工作路径

* C/Cpp程序 默认会打开三个文件流：标准输入 `FILE *stdin`、标准输出 `FILE *stdout`、标准错误 `FILE *stderr`

* C语言接口

  * C语言打开文件 fopen：r, r+, w（在fwrite前就清空）, w+, a（追加）, a+

  * C语言按行读取文件：fgets

  * C语言写文件：fwirte, fprintf, fputs

  * 简单模拟实现cat命令

    ```c
    #include <stdio.h>    
    #include <unistd.h>    
    #include <string.h>    
    
    int main(int argc, char *argv[]) {    
        if (argc != 2) {    
            printf("argv error\n");    
            return 1;    
        }    
        FILE *fp = fopen(argv[1], "r");
        if (fp == NULL) {    
            perror("fopen");    
            return 2;    
        }    
        // 按行读取    
        char line[64];    
        // fgets是C语言的接口来取string，因此会自动在字符结尾添加\0    
        while (fgets(line, sizeof(line), fp) != NULL) {    
            // printf("%s", line);    
            fprintf(stdout, "%s", line);    
        }    
        return 0;    
    }    
    ```

### 补充：位图的使用

bitmap 位图：将选项#define为不同的比特位，通过输入形参的不同组合来达到选择或同时输入多个参数的目的

```c
#include <stdio.h>    
#include <unistd.h>    
#include <string.h>    
    
// 用int中的不重复的一个bit，就可以表示一种状态    
#define ONE 0x1   // 0000 0001    
#define TWO 0x2   // 0000 0010    
#define THREE 0x4 // 0000 0100    
    
void show(int flags) {    
    if (flags & ONE)    
        printf("hello one\n");    
    if (flags & TWO)    
        printf("hello two\n");    
    if (flags & THREE)    
        printf("hello three\n");    
}    
    
int main() {    
    show(ONE);    
    printf("-------------------------\n");    
    show(TWO);    
    printf("-------------------------\n");    
    show(ONE | TWO);    
    printf("-------------------------\n");    
    show(ONE | TWO | THREE);    
    printf("-------------------------\n");
    
    show(ONE | THREE);    
    return 0;    
}    
```

## *打开、关闭、读写*

### 打开、关闭文件

打开文件用open

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
				// Returns file descriptor on success, or -1 on error
```

* flags 是一种bitmap选项
  * 三种互斥的文件访问模式标志，不能同时使用。其中任意一种可以与其他 flags 进行 `|` 操作
    * O_RDONLY 以只读方式打开文件
    * O_WRONLY 以只写方式打开文件
    * O_RDWR 以可读写方式打开文件
  * O_CREAT 若欲打开的文件不存在则自动建立该文件
  * O_EXCL（exclude）提供保证进程是打开文件的创建者的机制，即独占机制
    * 若O_CREAT 也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误
    * 若O_CREAT 与O_EXCL 同时设置， 并且欲打开的文件为符号连接，则会打开文件失败
  * O_NOCTTY 如果欲打开的文件为终端机设备时，则不会将该终端机当成进程控制终端机
  * O_TRUNC 若文件存在并且以可写的方式打开时，该 flag 会令文件长度清为0，而原来存于该文件的内容也会消失
  * O_APPEND 当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面
  * O_NONBLOCK/O_NDELAY 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中
  * O_SYNC 以同步的方式打开文件
  * O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接，则会令打开文件失败
  * O_DIRECTORY 如果参数pathname 所指的文件并非为一目录，则会令打开文件失败。此为 Linux2.2 以后特有的旗标，以避免一些系统安全问题
* mode 选择文件权限，只有在创建文件的时候才起作用。注意：新建文件的访问权限不仅仅依赖于参数 mode，而且还受到进程的 umask 值和（可能存在的）父目录的默认访问控制列表影响。具体可以看手册或interface

在早期的 UNIX 实现中，`open()` 没有mode参数，无法用来创建新文件，而是使用 `creat()` 系统调用来创建并打开一个新文件。create完全等价于下面的open调用，如果文件已存在会清空文件

```c
fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)；
```

关闭文件用close

```c
#include <unistd.h>
int close(int fd);
			// Returns O on success, or -1 on error
```

### write

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
			// Returns number of bytes written, or -l on error
```

* 参数
  * fd 是要操作的文件
  * buf 是计划写入的缓冲区，缓冲区至少要有count个size_t的大小
  * count 要写的**字节数**
* 返回写入的字节数，若遇到文件结尾 EOF 则返回0

参数和read一样。返回读到的字节数，若读到的是0，则意味着文件结束了，注意：换行和回车也是有效字符，不为0！

### read

```c
#include <unistd.h>
ssize_t read (int fd, void *buf, size_t count); 
			// Returns number of bytes read, 0 on EOF, or -1 on error
```

* 参数
  * fd是要操作的文件
  * buf 是计划写入的缓冲区，缓冲区至少要有count个size_t的大小
  * count 要写的字节数
* 返回写入的字节数，若遇到文件结尾 EOF 则返回0

read没有在 `printf()` 函数打印的字符串尾部添加一个表示终止的空字符

## *文件指针相关操作*

有些接口用到了文件指针，即 `struct file` 中的 `loff_t f_pos;` 来控制在文件的某个位置操作

### lseek

> `lseek()`调用名中的 `l` 源于这样一个事实：offset 参数和调用返回值的类型起初都是 long 型。早期的 UNIX 系统还提供了 `seek()` 系统调用，当时这两个值的类型为 int 型。 -- The Linux Programming Interface

```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
			// Returns new file offset if successful, or -1 on error
```

* offset 参数指定了一个以字节为单位的数值。 SUSv3 规定 `off_t` 数据类型为有符号整型数

* whence 参数表示应参照哪个基点来解释 offset 参数，应为下列其中之一

  <img src="lseek.drawio.png" width="70%">

  * SEEK_SET 将文件偏移量设置为**从文件头部起始点开始**的 offset 个字节
  * SEEK_CUR 相对于**当前文件偏移量**，将文件偏移量调整 offset 个字节
  * SEEK_END 将文件偏移量设置为**起始于文件尾部**的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起

### 在文件特定偏移量处的IO

```c
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
			// Returns number of bytes read, 0 on EOF, or -1 on error
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
			// Returns number of bytes written, or -1 on error
```

Pread/pwrite会在 offset 参数所指定的位置进行文件IO操作，而非始于文件的当前偏移量处

Pread/pwrite = `lseek(fd, offset, SEEK_CUR)` + read/write。不过区别在于**read/write会改变文件指针，但pread/pwrite不会改变**

Pread64/pwrite64是把offset扩大为64位的

### 文件空洞

从文件结尾后到新写入数据间的这段空间被称为文件空洞 file holes。这段空间用read去读取的会返回全0填充的缓冲区

文件空洞不占用任何磁盘空间，知道后续某个时间点在文件空洞中写入了数据时，文件系统才会为它分配磁盘快

原生的UNIX系统一般都支持文件空洞。不支持文件空洞的OS会显式地将空字节写入文件

### 文件截断

```c
#include <unistd.h>
#include <sys/types.h>
int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);
			// Both retur O on success, or -1 on error
```

注意：虽然叫做truncate，但是这个系统调用并不是只能把大file size截断为小file size，而是可以将file调整为给定的任意大小的length

若文件当前长度大于参数 length，调用将丢弃超出部分；若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞（SUSv3标准）

Truncate 通过文件路径字符串来指定要操作的文件，而fruncate则通过fd来指定文件

## *修改文件状态*

### fcntl

```c
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* arg */ );
			// Return on success depends on cnd, or -1 on error
```

`fcntl()`（file control）是一个Unix和Unix-like操作系统中的系统调用，用于对fd进行各种控制操作。它可以用于执行多种文件操作，包括但不限于以下几种：

* 文件锁定 file locking：fcntl 可以用来设置和释放文件锁定，以防止多个进程同时访问或修改同一个文件。这对于协调多个进程之间的文件访问非常有用，以避免竞态条件和数据损坏
* 修改文件属性：通过 fcntl 可以修改文件的各种属性，如文件的访问模式、文件的所有者和组、文件的时间戳等
* 获取和设置文件状态标志 file status flags：fcntl 可以用于获取和修改fd的状态标志，如非阻塞标志、同步标志等
* 获取和设置文件偏移量 file offset：fcntl 可以用于获取和设置文件描述符的当前文件偏移量，从而实现对文件的随机访问
* 复制fd：fcntl 可以用于复制一个fd，以便在不同的进程或线程之间共享文件描述符
* 获取fd的属性：fcntl 可以用于获取有关fd的信息，如文件类型、文件状态、文件锁定信息等
* 发送信号：在某些情况下，fcntl 可以用于向指定的进程发送信号

### dup\* 复制fd

```c
#include <unistd.h>
int dup(int oldfd);
			// Returns (new)file descriptor on success, or -1 on error
int dup2(int oldfd, int newfd);
			// Returns (new)file descriptor on success, or -l on error

#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
int dup3(int oldfd, int newfd, int flags);
			// Returns (new)file descriptor on success, or -l on error
```

* `dup` （Duplicate File Descriptor）用于复制一个fd，并返回一个新的fd，该新描述符指向与原始文件描述符相同的文件或资源。新的fd是通过寻找fd表中的最小未使用的fd来创建的

* `dup2`（Duplicate to Specified File Descriptor）用于将一个fd复制到另一个指定的fd，而不是创建一个新的fd。如果指定的文件描述符已经被使用，那么 `dup2` 将关闭该fd，然后将其复制为指定的fd

* `dup3` 是Linux特有的系统调用，它类似于 `dup2`，但提供了更多的选项，包括指定文件描述符的标志位（flags）。这使得 `dup3` 更加灵活，并允许在复制文件描述符时设置更多的选项

  ```c
  int fd1 = open("file1.txt", O_RDONLY);
  int fd2 = open("file2.txt", O_WRONLY | O_CREAT, 0644);
  dup3(fd1, 0, O_CLOEXEC); // 将标准输入复制为 fd1，并设置新文件描述符的关闭-on-exec标志
  ```

## *目录 & 链接*

```c
#include <unistd.h>
int unlink(const char *pathname);
			// Returns O on success, or -1 on error

#include <fcntl.h>           /* Definition of AT_* constants */
#include <unistd.h>
int unlinkat(int dirfd, const char *pathname, int flags);
```



```c
#include <stdio.h>
int remove(const char *pathname);
			// Returs O on success, or -1 on error
```

remove 库函数移除一个文件或一个空目录

* 若 pathname 是一文件，那么 remove 调用 unlink
* 若 pathname 为一目录，那么 remove 调用 rmdir



## *特殊的文件操作*

### 大文件操作

32位系统中 off_t 被实现为一个32位的有符号整型，因此它最大能表示一个2GB的文件

调用 open64，相当于在调用 open 的时候在flags里加上了O_LARGEFILE标志。若调用 open 时未指定此标志，且与打开的文件大小是大于2GB的，那么调用将会返回错误

### /dev/fd

### 临时文件



# 缓冲

使用 `sync(int fd)` 立即将脏数据 dirty data 落盘

<img src="IO缓冲小结.png" width="50%">

系统中一共有两种级别的缓冲区：语言级别的用户空间缓冲区和内核级别的缓冲区。以C语言和Linux OS为例，分别为stdio库的缓冲区和Page Cache机制

系统调用不会自动创建缓冲区，使用者必须要预先创建、分配好缓冲区。而语言级别的wrapper则往往会自己创建好缓冲区

### 缓冲区基础

* 为什么要有缓冲区？ -- Cache写方法，提高系统效率
* 缓冲区的刷新策略
  * 立即刷新
  * 行刷新/行缓冲 `\n`：一般是显示器采用这种刷新策略
  * 满刷新/全缓冲：缓冲区满了才刷新，一般是磁盘文件考虑效率采用这种刷新策略 
  * 特殊情况
    * 用户强制刷新 `fflush`
    * 进程退出时若没有被 `close(fd)` 的话就强制刷新
  * 所有设备处于效率考量都倾向于使用全缓冲。这是因为在和外部设备IO的过程中，数据量的大小不是主要矛盾，OS和外设预备IO的的过程才是最耗费时间的，全缓冲可以有更少次的IO，从而提高了效率。其他刷新策略是结合具体情况做的妥协，如显示器是因为给用户看的，需要同时考虑到效率和用户体验
* 缓冲区的位置

### 语言级别的缓冲区：stdio缓冲区试验

<img src="缓冲区试验.png" width="60%">

* 现象：同样的一个程序，向显示器打印时只输出4行文本，但向磁盘上的普通文件重定向打印时就变成了7行，其中C的IO接口打印了2次，而系统接口则和向显示器上打印一样只打印了一次
* 原因：直接调用是写给stdout，策略是行缓冲；后来重定向到文件中，对于磁盘上的文件刷新策略是全缓冲，父进程产生的数据还保留在它的PCB上下文数据中，父子进程退出的时候一并刷新
* 函数退出的时候强制刷新缓冲区，这是一个将数据写给OS的过程，即发生了写时拷贝
* 从试验结果可以看到，缓冲区的刷新策略改变并不会影响系统调用，这说明缓冲区是由语言层面维护的，而非系统层面

### 分散输入和集中输出

分散输入和集中输出 Scatter-Gather IO：`*readv*()` 和 `*writev*()` 分别实现了分散输入和集中输出的功能

```c
#include <sys/uio.h>
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
			// Returns number of bytes read, 0 on EOF, or -1 on error
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
			// Returs number of bytes written, or -1 on error
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
              off_t offset);
ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
               off_t offset);
ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
               off_t offset, int flags);
ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
                off_t offset, int flags);
```

这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据

* 数组 iov 定义了一组用来传输数据的缓冲区。iov数组 中的每个成员都是如下形式的数据结构

  ```c
  struct iovec {
  	void *iov_base;    /* Start address of buffer */
  	size_t iov_len;    /* Number of bytes to transfer to/from buffer */
  };
  ```

* iovcnt 则指定了 iov 的成员个数

# 文件属性

## *文件信息*

### stat系统调用

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
			// All return O on success, or -1 on error
```

上面3个系统调用之间仅有的区别在于对文件的描述方式不同 

* `stat()` 会返回所命名文件的相关信息
* `lstat()` 与 `stat()` 类似，区别在于如果文件属于符号链接，那么所返回的信息针对的是符号链接自身，而非符号链接所指向的文件
* `fstat()` 则会返回由某个打开fd所指代文件的相关信息

`*stat()` 会在缓冲区中返回一个由statbuf指向的stat结构

```c
struct stat {
	dev_t     st_dev;        /* IDs of device on which file resides */
	ino_t     st_ino;        /* I-node number of file */
	mode_t    st_mode;       /* File type and permissions */
	nlink_t   st_nlink;      /* Number of (hard) links to file */
	uid_t     st_uid;        /* User ID of file owner */
	gid_t     st_gid;        /* Group ID of file ouner */
	dev_t     st_rdev;       /* IDs for device special files */
	off_t     st_size;       /* Total file size (bytes) */
	blksize_t st_blksize;    /* Optimal block size for I/O (bytes) */
	blkcnt_t  st_blocks;     /* Number of (512B) blocks allocated */
	time_t    st_atime;      /* Time of last file access */
	time_t    st_mtime;      /* Time of last file modification */
	time_t    st_ctime;      /* Time of last status change */
};
```

### 时间戳



### 文件从属

### 文件权限

## *扩展属性 EA*

## *ACL*

访问控制列表 Access Control List, ACL

## *监控文件*

# 进程属性

```c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
			// Always successfully returns process ID of caller and process ID of the parent process
```



## *进程凭证*

### 分类

每个进程都有一套用数字表示的UID和GID，有时也将这些 ID 称之为进程凭证 process credentials，它们是用于标识和管理进程身份和权限的一组属性。可以分为

* 实际 read UID & GID：确定了进程所属的用户和组
* 有效 effective UID & GID
  * 当进程尝试执行各种操作（即系统调用）时，联通辅助GID来一起确定授予进程的权限
  * 内核还会使用有效UID 来决定一个进程是否能向另一个进程发送信号
* 保存的 set-user-ID (saved set-user-ID) & GID
* 文件系统用户 ID file-system UID & GID，Linux 专有
* 辅助组 ID supplementary GID

### 获取和修改API

## *进程优先级*

* 为什么要有优先级？CPU资源有限，而进程太多，需要通过某种方式竞争资源
* CPU资源分配的先后顺序，就是指进程的优先权

### 查看系统进程 `ps -la`

<img src="PRI_NI.png">

* UID：代表执行者的身份
* PRI：代表这个进程可被执行的优先级，其值越小越早被执行，系统默认优先级为80
* NI：代表这个进程的nice值，表示进程可被执行的优先级的修正数值，取值范围为 `-20~19`
* 优先级 = 老的优先级 + nice值，因此当nice值为负数时，优先值变小，优先级提高
* 为什么优先级的范围是在 `60~99` 内波动？OS的设计理念并不是让某一个程序最优先，而是均衡地分配资源，所以优先级的差距不宜过大，否则可能会有恶意进程通过提高自己的优先级而导致CPU在调度时总是先调度该恶意程序，导致其他进程得不到调度，将会导致一系列其他问题
* 用 `top` 命令更改已存在进程的nice：`top->r->输入PID->输入nice值`

## *环境变量使用*

### 环境变量的获取方式

Remainder：环境变量是通过进程的环境表 Environment List组织的。environ 指向一个以 NULL 结尾的指针列表，每个指针又指向一个以空字节终止的字符串

<img src="环境列表.drawio.png" width="40%">

* 通过代码

  * main函数有三个参数 `int main(int argc, char* argc[], char* env[]);`
    * `argv` 是命令行参数指针数组， `argc` 是有几个命令行参数
    * 第三个参数char指针数组就是用来接收父进程继承的环境表的
  * 利用第三方变量 `extern char** environ;`
* 通过系统调用或设置环境变量

### main的参数argc和argv

## *进程资源*

# 进程控制

进程控制的核心在于4个系统调用：fork、exit、wait、execve。可以用下面这张图来总结（也是shell执行一条命令所历经的步骤）。具体的可以看各节

<img src="进程控制核心系统调用.png">

## *创建进程*

### fork

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
			// In parent: returns process ID of child on success, or -l on error；
			// in successfully created child: always returns 0
```

Fork 可以从父进程创建出一个新的进程（子进程)）。具体做法是：新的子进程几近于对父进程的翻版，子进程获得父进程的栈、数据段、堆和执行文本段的拷贝

* **共享代码段**：子进程通常与父进程共享代码段，这意味着它们执行相同的程序。这样可以节省内存，并且对于许多用途非常有用

* **独立数据段 & 写时拷贝**

  * 尽管子进程共享代码段，但它们有独立的数据段和堆栈，因此它们可以在没有互相干扰的情况下操作自己的数据

  * 不过要注意的时，为了减少内存占用，一开始父子进程仍然是共享数据段的，只有当需要修改数据段时，才会发生数据段的写时拷贝，写时拷贝的本质是一种延时申请

    <img src="COW.png">

  * 文件共享：子进程会获得父进程所有文件描述符的副本（fd均指向相同的打开文件句柄），从而实现了文件共享。这些副本的创建方式类似于dup。需要使用wait在进程之间同步，从而确保输出不会随意混杂在一起

Fork 调用失败的原因

* 系统中有太多的进程
* 实际用户 real UID 的进程数超过了限制 RLIMIT_NPROC

### vfork

```c
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);
			// In parent: returns process ID of child on success, or -l on error；
			// in successfully created child: always returns 0
```

在早期的 BSD 实现中，fork 会对父进程的数据段、堆和栈施行严格的复制。为了规避这种高消耗引入了 vfork。vfork的特点是

* 无需为子进程复制虚拟内存页或页表。相反子进程共享父进程的内存，直至其成功执行了 exec 或是调用 \_exit 退出 
* 在子进程调用 exe 或 \_exit 之前，将暂停执行父进程

因为现代UNIX系统中在执行fork的时候都会采用写时拷贝，所以vfork失去了用武之地也很少被使用了。此外 vfork 的怪异语义可能会导致一些难以察觉的bug，所以尽量不要使用vfork

### fork之后的竞态条件

调用 fork()之后,系统将率先“垂青”于哪个进程(即调度其使用 CPU) ,是无法确定的

## *clone*

```c
#define _GNU_SOURCE
#include <sched.h>
int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
         /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
```



## *进程退出*

### exit

```c
#include <unistd.h>
void _exit(int status);

```

库函数 exit(status)终止一进程,将进程占用的所有资源(内存、文件描述符等)归还内核,交其进行再次分配。参数 status 为一整型变量,表示进程的退出状态。父进程可使用系统调用 wait()来获取该状态

```c
#include <stdlib.h>
void exit(int status);
```

exit()会执行的动作如下。 
?  调用退出处理程序(通过 atexit()和 on_exit()注册的函数) ,其执行顺序与注册顺序相反(见 25.3 节) 。 
?  刷新 stdio 流缓冲区。 
?  使用由 status 提供的值执行_exit()系统调用。

## *Wait*

## *程序的执行*

系统调用 execve(pathname,argv,envp)加载一个新程序(路径名为 pathname,参数列表为 argv, 环境变量列表为 envp) 到当前进程的内存。 这将丢弃现存的程序文本段, 并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行(execing)一个新程序。稍后会介绍构建于 execve()之上的多个库函数,每种都为编程接口提供了实用的变体。在彼此差异无关宏旨的场合,循例会将此类函数统称为 exec(),尽管实际上并没有以之命名的系统调用或者库函数。



## *进程组和作业*

## *进程资源*

## *能力*

能力 capabilities

把授予给超级用户的特权划分为若干不同单元，且能独立启用和禁用这些单元

# IPC

## *管道*

# System V IPC

System V通信是指一组在System V UNIX操作系统中用于进程间通信的机制和API。这些通信机制允许不同的进程在同一系统上进行数据交换和协作。System V通信包括以下几种主要的形式：

1. **消息队列（Message Queues）：** 消息队列允许进程通过在消息队列中发送和接收消息来进行通信。每个消息都有一个类型，进程可以选择接收特定类型的消息。消息队列通常用于进程之间的异步通信，其中一个进程将消息发送到队列，而另一个进程则可以在需要时从队列中读取消息。
2. **信号量（Semaphores）：** 信号量是一种计数器，它用于同步多个进程的操作。进程可以执行P（Wait）和V（Signal）操作来控制信号量的值。信号量通常用于解决竞争条件和进程同步问题。
3. **共享内存（Shared Memory）：** 共享内存允许多个进程访问同一块物理内存，这使得它们可以高效地共享数据。共享内存通常用于需要快速数据传输的应用程序，但也需要谨慎处理，以避免数据一致性问题。

这些System V通信机制都是底层的，需要开发人员自行管理进程间的同步和互斥。它们为不同的进程提供了一种可靠的方式来进行进程间通信，以便协作完成任务。这些通信机制通常用于复杂的多进程或多线程应用程序中，以确保数据的一致性和协调工作。

System V通信机制在Linux中也有支持和实现。Linux支持System V IPC，以便与传统的UNIX系统和应用程序兼容。因此，在Linux上，你可以使用System V消息队列、信号量和共享内存来进行进程间通信，就像在其他UNIX系统上一样。

# POSIX IPC

# 内存映射

## *Intro*

内存映射 Memory mapping 是指将一个文件或者其他设备的内容映射到进程的虚拟地址空间，使得这部分内容可以被当作内存一样在相应的内存区域中操作字节来访问文件内容。进程可以通过读写这个区域来实现对文件或设备的操作，而不需要使用传统的文件读写接口或设备访问接口，比如缓慢的 read、write 等

内存映射可以通过操作系统提供的系统调用，如 `mmap()` 来实现，它将文件或设备映射到进程的地址空间，并在内核中建立相应的映射关系。一旦内存映射建立，进程就可以直接读写映射区域的内容，而OS会负责将这些操作转换为实际的文件读写或设备访问操作

### 发生场景

一个进程的映射中的内存可以与其他进程中的映射共享，即各个进程的页表条目指向 RAM 中相同分页

* 当两个进程映射了一个文件的同一个区域时它们会共享物理内存的相同分页
* 通过 fork 创建的子进程会继承其父进程的映射的副本，并且这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同

当两个及以上的进程共享相同分页时，是否能看到其他进程对分页作出的变更取决于共享分页的类型

* 私有/写时复制映射 MAP_PRIVATE：在映射内容上发生的变更对其他进程不可见，当一个进程要修改分页时，该分页会被写时拷贝成一个新的分页
* 共享映射 MAP_SHARED：在映射内容上发生的变更对所有共享同一个映射的其他进程都可见。对于文件映射来讲，变更将会发生在底层的文件上

### 内存映射分类

* 文件映射 file mapping：将文件的一部分直接映射到调用进程的虚拟内存中，映射完成后进程可以通过读写这个区域来实现对文件或设备的操作，进程可以在内存区域中操作字节来访问文件内容
* 匿名映射 anonymous mapping：一个匿名映射没有对应的文件。相反，这种映射的分页会被初始化为 0

与上面的私有/共享映射相组合后可以得到4中内存映射类型

* 私有文件映射：主要用途是使用一个文件的内容来初始化一块内存区域
* 私有匿名映射：主要用途是为一个进程分配新（用 0 填充）的内存，比如在分配大块内存（大于128KB）时 malloc 会为此而使用 mmap 而不是 brk
* 共享文件映射：主要用于替代缓慢的read、write，以加快IO速度（零拷贝），以及用于无关进程之间的IPC
* 共享匿名映射：主要用于相关进程之间的IPC

### 安全性

以下是一些可能的安全问题：

1. 内存访问越界：如果进程在内存映射区域之外进行读写操作，可能会导致内存访问越界的问题，例如读取或修改未映射的内存内容，或者覆盖其他重要数据
2. 潜在的漏洞利用：内存映射可以使恶意用户或程序能够读取或修改敏感数据，例如密码、私钥等。如果对映射区域的权限控制不严格或存在安全漏洞，攻击者可能利用这些漏洞来获取敏感信息
3. 共享对象的安全性：内存映射允许多个进程共享同一个文件的内容。如果共享对象不受适当的保护或验证，可能会导致一个进程对共享对象的恶意修改影响其他进程的安全性

为了确保内存映射的安全性，应该采取以下措施：

1. 权限控制：确保只有授权的进程或用户可以访问映射区域，并且限制他们对映射区域的读写权限。适当的权限控制可以防止未经授权的访问和恶意操作
2. 内存保护：使用内存保护机制，如设置合适的访问权限和内存保护位，以防止越界访问和非法操作
3. 数据验证和加密：对于包含敏感数据的内存映射区域，可以采用数据验证和加密的方法来保护数据的完整性和机密性，以防止未经授权的读取或篡改
4. 共享对象的安全性：对于共享对象，应该实施适当的验证和完整性检查，确保在共享过程中不会被恶意篡改

## *API*

### 创建、销毁mapping

<img src="mmap.png">

```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
			// Returns starting address of mapping on success, Or MAP_FAILED on error
int munmap(void *addr, size_t length); 
			// Returns 0 on success, or -1 on error
```

* 参数
  * addr：用户进程中要映射的用户空间的起始地址，通常为NULL，表示由内核来指定一个合适的地址。addr 参数在指定了 MAP_FIXED 的情况下必须要与分页对齐
  * length：要映射的内存区域的大小。API没有强制要求length是一页大小的整数倍，但会被自动向上提升为页的最小整数倍
  * prot：期望的内存保护标志。若违反了保护位，内核会向该进程发送一个 SIGSEGV 信号
    * PROT_EXEC  Pages may be executed
    * PROT_READ  Pages may be read
    * PROT_WRITE Pages may be written
    * PROT_NONE  Pages may not be accessed
  * flags：指定映射对象的类型
    * MP_PRIVATE 创建一个私有映射
    * MP_SHARED 创建一个共享映射
  * fd：文件描述符（由open函数返回）
  * offset：设置映射在文件中的起点，例如文件的偏移量，大小必须为PAGE_SIZE的整数倍，用于对齐。要映射整个文件就需要将 offset 指定为 0 并且将 length 指定为文件大小
* 返回值
  * 成功时 `mmap()` 返回被映射区的指针，该指针就是需要映射的内核空间在用户空间的虚拟地址
  * 失败时根据SUSv3标准返回 `MAP_FAILED == ((void *)-1)` 常量

### msync

```c
int msync(void *addr, size_t length, int flags);
			// Returs O on success, or -1 on error
```

msync 系统调用可以让程序显式控制何时完成共享映射与映射文件之间的同步

* MS_SYNC 同步：调用后等到更新完成之后才返回
* MS_ASYNC 异步：调用后立即返回，不会等待更新的完成
* MS_INVALIDATE：使映射数据的缓存副本失效
* 成功返回0，失败返回-1

### mremap

Linux提供了不可移植的 `mremap()` 系统调用来执行映射区域变更（扩容或缩容）

```c
void *mremap(void *old_address, size_t old_size,
                    size_t new_size, int flags, ... /* void *new_address */);
			// Returns starting address of remapped region on success，or MAP_FAILED on error
```

* addr：上一次已映射到进程空间的地址
* old_size：旧空间的大小，地址必须是分页对齐的。通常是一个由之前的 mmap 调用返回的值
* new_size：重新映射指定的新空间大小
* flags
  * 0代表不允许内核移动映射区域，只能原地扩，如果原地扩失败了就报错
  * MREMAP_MAYMOVE：表示内核可以根据实际情况移动映射区域以找到一个符合new_size大小要求的内存区域

在 Linux 上，realloc 使用 mremap 来高效地为 malloc 之前使用 MAP_ANONYMOUS（私有匿名映射）分配的大内存块重新指定位置

## *匿名映射*

### 创建匿名映射的方式

* 在flags中指定 MAP_ANONYMOUS 并将 fd 指定为-1
* 打开/dev/zero设备文件并将得到的fd传递给mmap

## *其他的mmap flags*

* MAP_LOCKED：将映射分页锁进内存（自 Linux 2.6 起）
* MAP_HUGETLB：创建一个使用巨页的映射（自 Linux 2.6.32 起）
* MAP_POPULATE：填充一个映射的分页（自 Linux 2.6 起）
* MAP_UNINITIALIZED：不清除匿名映射（自 Linux 2.6.33 起）

### MMAP_FIXED

### MAP_NORESERVE

# 虚拟内存

## *虚拟内存操作*

# 线程

## *API*

### fork-join 模型

<img src="fork-join model.drawio.png" width="70%">

### pthread

因为Linux本质上是没有实现多线程（只是轻量化进程），所以Linux本身并不提供线程的系统调用接口。但是提供了创建轻量级进程的接口，即子进程与父进程共享一个地址空间的 `vfork` 和 `clone`，问题是这些接口用起来很麻烦，需要用户自定义线程保护等操作

为了实现多线程的控制，Linux社区提供了pthread这个用户层的第三方原生线程库，头文件是 `pthread.h`。虽然说是第三方的库，但它和Linux系统强相关，在每一个Linux OS都要被预置

其中最常用的是POSIX版线程库。当然语言层上，如C++、python等语言也提供了语言级别的线程库，但这些库基本上就是对用户层原生线程库的封装

### 线程创建

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
//Compile and link with -pthread.
```

* 参数
  * `pthread_t *thread` 线程id
  * `attr` 线程的属性：设置栈大小、关于该线程调度优先级的信息等
  * `start_routine` 线程要执行的回调函数的函数指针
  * `arg` 是要喂给回调函数的参数
* 创建成功返回0，失败返回errno

### 线程终止

```c
#include <pthread.h>
void pthread_exit(void *retval); //pthread_exit比较常用
int pthread_cancel(pthread_t thread);
```

* 线程的控制流 `start_routine` 内
  * 正常退出 return
  * `pthread_exit`
* 主线程内 `pthread_cancel` 取消分支线程
* 进程分离后main thread不再关心被分离thread的状态，相当于是一种延后退出

### 线程等待

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
```

* `void** retval` 是进程退出时的退出码，比如返回 `(void*)10`，它是一个二级指针输出型参数

* 线程退出时没必要像进程退出时输出32位的退出码，因为线程就是进程，线程异常整个进程退出，因此直接交给进程退出码来处理

* ```cpp
  //输出型参数
  void* ret = nullptr;
  pthread_join(tid, &ret);
  cout << "main thread join success, *ret: " << (long long)(ret) << endl;
  ```

`pthread_join` 的作用类似于进程等待 `wait`。线程退出的时候，一般必须要进行join。若不进行join，就会造成类似于进程那样的内存泄漏问题，但没有“僵尸线程”这种说法

调用该函数的线程将挂起等待，直到id为thread的线程终止。thread以不同的方法终止，通过 `pthread_join` 得到的终止状态是不同的

### 线程分离

默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行 `pthread_join` 操作，否则无法释放资源，因而造成系统泄漏

若不关心线程的返回值，join是一种负担，此时可以通过进程分离来告诉系统，当线程退出时，自动释放线程资源

```c
#include <pthread.h>
int pthread_detach(pthread_t thread);
pthread_detach(pthread_self()); //对自己进程分离
```

可以是对线程组内其他线程的其他目标线程进行线程分离，也可以对自己线程分离，只要用`pthread_self()` 来获取tid就行。joinable和分离是冲突的，一个线程不能既是joinable又是分离的，会报22号错误 Invalid argument

进程分离，对应的main thread一般是不退出的，在死循环中常驻内存

## *Pthread实现*

### LinuxThread

### NLT