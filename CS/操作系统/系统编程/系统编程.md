# Linux发展史 & 标准

## *UNIX*

### UNIX的定义

* 指通过 SUS, Single UNIX Specification 所规范的官方一致性测试,且由OPEN GROUP（UNIX 商标的持有者）正式授权冠以“UNIX”的操作系统
* 运作方式类似于经典 UNIX 系统的操作系统

### UNIX & C的早期历史

1. 1960年代初：1969年，由美国贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等计算机科学家创建。最初的UNIX系统是为PDP-7和PDP-11等小型计算机设计的，旨在提供一个多用户、多任务的操作系统，用于支持科学和研究计算

2. 1970年代：在70年代初，UNIX系统逐渐发展壮大， Dennis Ritchie 设计并实现出了C编程语言，这成为后来UNIX系统的主要编程语言。C语言的设计受到了汇编语言和BCPL语言的影响，它具有直接的硬件访问能力、高效的内存管理和丰富的控制结构，使其非常适合系统编程。

   实现C语言的初衷就是为了实现 UNIX 内核及其相关软件而开发一种高层语言。这也是为什么C/C++成为了系统编程的首要语言。C的出现在当时填补了系统编程方面的语言空白

3. 1973年：UNIX操作系统的第一个正式版本被称为UNIX第四版（UNIX Version 4），这个版本是用C语言编写的。这标志着C语言与UNIX系统的密切结合，使得UNIX能够更容易地在不同的硬件平台上移植，因为C语言具有可移植性

   UNIX 因此也一变而为最早以高级语言开发而成的操作系统之一

4. 1975 年 3 月发布的第六版UNIX是在 AT&T 之外广泛使用的首个 UNIX 版本

## *UNIX家族*

1980年代：UNIX系统分化出了多个不同的分支，包括AT&T的System III和System V，以及 UC Berkeley 的BSD, Berkeley Software Distribution。这些分支在功能和特性上有所不同，但它们都继承了UNIX的核心思想，并继续使用C语言进行开发和扩展

<img src="UNIX时间线.png">

Source: Wikipedia https://en.wikipedia.org/wiki/History_of_Unix

### BSD家族

受母校 UC Berkeley 之邀， Ken Thompson 于 1975/1976 学年曾担任该校的客座教授。在此期间，他与研究生们一起为 UNIX 开发了许多新特性和工具。比如说C shell、vi 编辑器、一种改进型的文件系统(伯克利快速文件系统) 、sendmail、Pascal 语言编译器，以及用于新型 Digital V AX 架构的虚拟内存管理机制

1. 1979年12月，诞生了首个完整的 UNIX 发布版 3BSD
2. 1983年的4.2BSD：这是BSD家族的第一个重要版本，于1983年发布。它引入了许多重要的功能，如完整的TCP/IP网络协议栈实现、虚拟内存系统和套接字编程接口。4.2BSD对互联网的发展产生了深远的影响，并成为后来BSD版本的基础

BSD的著名版本，基本都是开源软件

1. FreeBSD：FreeBSD是BSD家族中最著名和广泛使用的实现之一。它注重性能和可用性，广泛应用于服务器环境和大规模应用。FreeBSD具有强大的网络功能和可扩展性，还支持Jails技术，允许虚拟化多个独立的操作系统环境
2. OpenBSD：OpenBSD专注于安全性和代码审查，其目标是创建最安全的操作系统。它具有强大的网络安全功能和默认启用的安全设置。OpenBSD还维护了OpenSSH项目，这是一种用于加密远程通信的开源工具
3. NetBSD：NetBSD是一个注重可移植性的BSD分支，其目标是在各种硬件平台上运行。它的主要特点之一是广泛的硬件支持，使其成为嵌入式系统和各种设备的首选操作系统。NetBSD还注重代码的清晰性和可维护性
4. DragonFly BSD：DragonFly BSD是一个专注于多处理器 SMP 系统的BSD分支，它的目标是提供高性能的多核心支持。它采用了一种全新的虚拟内存系统，以提高系统的扩展性和性能

### System V家族

在BSD蓬勃发展的同时，由于AT&T受到反垄断法的拆分，随着其在电话系统市场垄断地位的丧失，AT&T 也因而获准销售 UNIX

1. System III 由 AT&T 所属的 UNIX 支撑团队 UNIX Support Group, USG 研发, 该团队雇佣了数以百计的研发人员来从事 UNIX 系统的增强以及应用开发（尤其针对文档预备软件包和软件开发工具）
2. 1983 年，System V 的首个发布版发布。在经过一系列发布后，USG 最终于 1989 年推出了 System V Release 4(SVR4) ，此时的 System V 吸收了 BSD 的诸多特性，比如说联网能力。AT&T 将 System V 授权给不同厂商，这些厂商又将其作为自身 UNIX 实现的基础

System V的著名版本，基本都是商业软件

1. AT&T UNIX System V：AT&T UNIX System V是System V的官方实现，起源于贝尔实验室。它是System V操作系统的基础版本，后来的System V版本都是从它分支出来的
2. IBM AIX：IBM的AIX操作系统是基于System V的UNIX实现，旨在运行IBM的大型服务器和工作站。它具有强大的企业级特性和可扩展性
3. HP-UX：惠普（Hewlett-Packard）的HP-UX是另一种基于System V的UNIX实现，用于HP的服务器和工作站。它提供了高性能的计算和可靠性
4. Solaris：Solaris是Sun Microsystems（后来被Oracle收购）开发的UNIX操作系统。它基于System V Release 4（SVR4），具有强大的网络和存储功能。Solaris曾经是企业级UNIX操作系统的领先选择

## *GNU & Linux内核*

### GNU & Linux

GNU, GNU's Not Unix 是一个自由软件项目，它是一个由 Richard Stallman 于1983年发起的计算机操作系统项目，旨在创建一个自由、开源的类UNIX操作系统。GNU项目的目标是提供一个完全自由的操作系统，使用户可以自由运行、复制、分发、学习、修改和改进软件

以下是关于GNU项目的一些重要信息：

1. 自由软件：GNU强调自由软件的理念，即用户应该具有运行、研究、分享和修改软件的自由。为了保护这些自由，GNU采用了GNU通用公共许可证（GNU General Public License，GPL）等自由软件许可协议，确保软件的自由性不受侵犯
2. 工具和应用：GNU项目不仅涉及操作系统内核的开发，还包括了一系列工具、库和应用程序的开发。其中一些著名的GNU工具包括GNU C编译器（GCC）、GNU调试器（GDB）、GNU文本编辑器（Emacs）等
3. GNU/Linux：虽然GNU项目开发了大部分操作系统组件，但在早期，还缺少一个称为内核的关键组件。因此，Richard Stallman 与 Linus Torvalds 合作，将Linux内核与GNU工具和应用程序相结合，创造了GNU/Linux操作系统，也被简称为Linux。这个组合成为了开源社区中最流行的操作系统之一
4. GNU自由文档许可证：GNU项目还为文档和教育资料提供了自由文档许可证（GNU Free Documentation License，GFDL），以保护用户对于文档的自由使用和分发
5. 社区参与：GNU项目鼓励开发者和用户积极参与，为自由软件的开发和改进做出贡献。社区支持和合作在GNU项目的成功中起到了关键作用

### Linux版本号

1. Linux 0.01（1991年）：这是Linux内核的首个公开发布版本，由 Linus Torvalds 发布。它只包含了约10,000行代码，仅支持Intel 386处理器
2. Linux 0.95（1992年）：这个版本引入了虚拟文件系统（Virtual File System，VFS），这是一个允许Linux支持多种文件系统的重要组件
3. Linux 1.0（1994年）：这是Linux内核的首个正式稳定版本，标志着Linux成熟为可用于生产环境的操作系统
4. Linux 2.0（1996年）：这个版本引入了对Symmetric Multiprocessing（SMP）的支持，使Linux能够在多处理器系统上运行。此外，它还增加了对新的硬件设备的支持
5. Linux 2.2（1999年）：这个版本带来了TCP/IP栈的性能改进，使Linux成为一个更好的网络服务器。它还增加了对USB设备的支持
6. Linux 2.4（2001年）：这个版本进一步改进了SMP支持、网络性能和硬件兼容性。它引入了防火墙功能（Netfilter/Iptables）
7. **Linux 2.6（2003年）：这个版本引入了动态调度器、完善的电源管理、内存管理改进以及更好的性能和稳定性。2.6内核系列维持了很长时间，成为许多发行版的基础**
8. Linux 3.x（2011年）：这个版本引入了很多新的硬件支持和性能优化，同时也改进了文件系统和虚拟化支持
9. Linux 4.x（2015年）：这个版本继续增加了新硬件的支持，改进了内存管理、文件系统、安全性和性能
10. Linux 5.x（2019年）：这个版本引入了许多新功能，包括实时内核调度、I/O性能优化、显著改进的网络性能以及新的文件系统特性
11. Linux 6.x（预期）：未来的Linux内核版本将继续演进，以满足新的硬件和应用需求，增加新的功能和改进性能、安全性等方面的特性

Linux内核版本号在2.6之前确实采用了x.y.z（主版本号、次版本号和修订号）的格式

### Linux发行版

准确来说，Linux指的是Linus Torvalds及社区开发的Linux内核，不过也可以指Linux的软件包（工具和库），这些软件包可以被商业化形成不同的发行版 Linux distribution

发行版的目的是为了简化Linux操作系统的安装、配置和维护，以满足不同用户的需求和用途。每个发行版都可以有自己的特点和目标受众

* Ubuntu：用户友好、易用性强、大量的软件包、广泛社区支持。适用于桌面、服务器和云计算
* Debian：稳定性强、广泛的软件包支持、强调自由软件。适用于桌面、服务器和嵌入式系统
* CentOS（现在称为CentOS Stream）：稳定性强、面向企业、与Red Hat Enterprise Linux, RHEL 兼容。适用于：企业服务器和工作站
* Fedora：先进的软件、最新技术、社区驱动。适用于：桌面和开发者
* Red Hat Enterprise Linux, RHEL：企业级支持、长期支持（LTS）、面向企业客户。适用于：大型企业和数据中心
* SUSE Linux Enterprise Server, SLES：企业级支持、高可用性、面向企业客户。适用于：大型企业和数据中心
* Arch Linux：滚动更新、高度可定制、面向高级用户
* Manjaro：用户友好的Arch Linux分支、易用性强
* Slackware：古老而稳定、简单、面向高级用户

### License

下面是一些常见的开源许可证

* MIT许可证：
   * 允许用户在几乎任何情况下自由使用、修改、复制和分发项目
   * 要求在项目中包含原始许可证和版权声明
   * MIT许可证非常宽松，允许其他人在几乎不受限制的情况下使用代码
* BSD许可证：
   * 有多个变种，如2-Clause BSD、3-Clause BSD等
   * 允许几乎不受限制地使用、修改和分发代码，类似于MIT许可证
   * 通常只要求在源代码中包含原始许可证和版权声明
* GNU通用公共许可证（GPL）：
   * 分为GPLv2和GPLv3两个主要版本，其中GPLv3具有更多的保护措施和约束
   * 强制要求所有派生作品也必须采用相同的GPL许可证，以保持开源性
   * 用于确保开源项目的自由和共享，但可能对商业应用产生一些限制
* Apache许可证：
   * 允许用户使用、修改、分发和用于商业目的
   * 对专利权有一些附加规定，以确保贡献者不会通过专利权来限制其他人的使用
   * 适用于需要保护知识产权并允许广泛使用的项目
* GNU较宽松公共许可证（LGPL）：
   * 允许将LGPL许可的代码链接到封闭源码项目中，而不会强制整个项目采用LGPL
   * 通常用于开发库或组件，使其在广泛的应用程序中可用
* Creative Commons许可证：
   * 主要用于非代码内容，如文档、图像、音频和视频
   * 允许创建者定义一系列条件，如是否允许商业用途、是否要求署名等

## *标准化*

### POSIX & SUS

POSIX, Portable Operating System Interface 可移植操作系统 最初由IEEE制定，以确保UNIX操作系统在不同系统上的可移植性。POSIX定义了一系列API（应用程序编程接口）和命令行工具，包括文件操作、进程管理、信号处理、线程控制、网络编程和 Shell 命令等。POSIX标准的目标是使开发人员能够编写在不同UNIX系统上可移植的应用程序。

SUS, Single UNIX Specification 由The Open Group制定和维护，它包括了UNIX操作系统的核心和可选组件

### ABI

ABI, Application Binary Interface 应用程序二进制接口相比于语言层面的API更加严格和难以实现，定义了编程语言编译器和操作系统之间的接口规范，从而实现一次编译成型后在不同的ISA上都可以运行

ABI没有提供显式接口，而是由内核和工具链 toolchain 定义和实现的

ABI包括了以下方面的规范：

* 数据表示：定义了数据类型的表示方式，包括整数、浮点数、字符等。它规定了数据的字节顺序、对齐方式以及数据在内存中的布局
* 函数调用约定：规定了函数的参数传递方式、寄存器的使用规则、栈的管理方式以及函数调用的返回值处理方法。不同的架构和操作系统可能有不同的函数调用约定
* 寄存器使用：定义了哪些寄存器是可用的、用于哪些目的、以及在函数调用时如何保存和恢复寄存器的值
* 异常处理：规定了异常、中断和系统调用的处理方式，包括如何触发和响应这些事件，以及如何传递异常信息
* 系统调用：定义了操作系统提供的服务和函数调用接口，包括如何通过系统调用访问操作系统功能，例如文件系统、进程管理、网络通信等
* 共享库：规定了共享库（也称为动态链接库）的格式、加载方式以及运行时链接过程，以便不同程序可以共享和重用代码

# 系统调用

系统调用表


# 通用IO模型

# 文件IO

## *C语言和系统级别的调用接口*

### 接口的封装关系

以open的封装为例说C标准库、glibc 运行时库、系统调用和Linux内核的关系

C函数 `fopen`，系统调用 `open`，系统调用 `__libc_open` （glibc/sysdeps/unix/sysv/linux/open.c）和Linux内核 `sys_open` （/fs/open.c）是在 C 和 Linux 系统中用于打开文件的函数，它们之间的关系如下：

1. 当应用程序调用 `fopen` 函数时，实际上是调用由 C 库提供的一个包装函数 wrapper function（包装函数就是封装了其他函数的函数）。这个包装函数对传递给 `fopen` 的参数进行了一些额外的处理，然后调用 `__fopen_internal` 函数
2. `__fopen_internal` 是 C 库的内部函数，它实现了实际的文件打开逻辑。它会根据使用的 C 库版本调用 `open` 或 `__libc_open` 函数
3. `open` 和 `__libc_open` 都是用于打开文件的函数。`open` 是 Linux 内核提供的系统调用，而 `__libc_open` 是 C 库的内部函数，提供了更灵活的打开文件接口。根据使用的 C 库版本，`__fopen_internal` 可能会调用 `open` 或 `__libc_open`
4. `sys_open` 是 Linux 内核提供的系统调用，由 `open` 或 `__libc_open` 调用，用于实际打开文件并返回文件描述符，这个文件描述符可用于后续的读写操作

因此，它们之间的调用顺序可以总结如下

1. 应用程序调用 `fopen` 函数
2. C 库的包装函数处理参数并调用 `__fopen_internal`
3. `__fopen_internal` 根据使用的 C 库版本调用 `open` 或 `__libc_open`
4. `open` 或 `__libc_open` 调用系统调用 `sys_open` 来打开文件并返回文件描述符
5. `sys_open` 打开文件并返回文件描述符
6. `open` 或 `__libc_open` 将文件描述符返回给 `__fopen_internal`
7. `__fopen_internal` 将 FILE 指针返回给 C 库的包装函数
8. 包装函数将 FILE 指针返回给应用程序

总结一下

* C函数是纯语言级别的库，涉及到系统的函数会去封装系统调用
* 系统调用是OS封装好暴露出接口交给用户使用的库，system call的时候会发生陷入内核
* Linux内核函数是最底层的库，完全由系统使用，用户无法接触到

### C语言文件接口

* 当前路径：当一个进程运行起来的时候，每个进程都会记录自己当前所处的工作路径

* C/Cpp程序 默认会打开三个文件流：标准输入 `FILE *stdin`、标准输出 `FILE *stdout`、标准错误 `FILE *stderr`

* C语言接口

  * C语言打开文件 fopen：r, r+, w（在fwrite前就清空）, w+, a（追加）, a+

  * C语言按行读取文件：fgets

  * C语言写文件：fwirte, fprintf, fputs

  * 实现cat命令

    ```c
    #include <stdio.h>    
    #include <unistd.h>    
    #include <string.h>    
    
    int main(int argc, char *argv[]) {    
        if (argc != 2) {    
            printf("argv error\n");    
            return 1;    
        }    
        FILE *fp = fopen(argv[1], "r");                                                                             
        if (fp == NULL) {    
            perror("fopen");    
            return 2;    
        }    
        // 按行读取    
        char line[64];    
        // fgets是C语言的接口来取string，因此会自动在字符结尾添加\0    
        while (fgets(line, sizeof(line), fp) != NULL) {    
            // printf("%s", line);    
            fprintf(stdout, "%s", line);    
        }    
        return 0;    
    }    
    ```

### 系统调用接口

* 系统调用接口有 `open, close, read, write`，C语言对应的封装函数为 `fopen, fclose, fread, fwrite`

* 补充知识：bitmap 位图：将选项#define为不同的比特位，通过输入形参的不同组合来达到选择或同时输入多个参数的目的

  ```c
  #include <stdio.h>    
  #include <unistd.h>    
  #include <string.h>    
      
  // 用int中的不重复的一个bit，就可以表示一种状态    
  #define ONE 0x1 // 0000 0001    
  #define TWO 0x2 // 0000 0010    
  #define THREE 0x4 // 0000 0100    
      
  void show(int flags) {    
      if (flags & ONE)    
          printf("hello one\n");    
      if (flags & TWO)    
          printf("hello two\n");    
      if (flags & THREE)    
          printf("hello three\n");    
  }    
      
  int main() {    
      show(ONE);    
      printf("-------------------------\n");    
      show(TWO);    
      printf("-------------------------\n");    
      show(ONE | TWO);    
      printf("-------------------------\n");    
      show(ONE | TWO | THREE);    
      printf("-------------------------\n");                                                              
      show(ONE | THREE);    
      return 0;    
  }    
  ```
  
* 以 `open` 为例，查看open的手册，`man 2 open`

  <img src="man2open.png">

  * `flags` 是一种bitmap选项，`mode` 则是选择文件权限
  * `int fd = open("log.txt", O_WRONLY|O_CREAT|O_TRUNC, 0666)`：添加了权限码，用来创建文件，通过该种bitmap组合实现了 fopen w的效果
  * `int fd = open("log.txt", O_WRONLY|O_CREAT|O_APPEND, 0666)`：通过该种bitmap组合实现了 fopen a 的效果
  * `int fd = open("log.txt", O_RDONLY)`：不添加权限码，默认文件已经存在，会受umask的影响

* `close`

  ```c
  #include <unistd.h>
  int close(int fd);
  ```

* `write`

  ```c
  #include <unistd.h>
  ssize_t write(int fd, const void *buf, size_t count);
  ```

  * `buf` 计划写入的缓冲区
  * `count` 要写的字节数
  * 返回写入的字节数

* `read`

  ```c
  #include <unistd.h>
  ssize_t read(int fd, void *buf, size_t count);
  ```

  * 参数和write一样
  * 返回读到的字节数，若读到的是0，则意味着文件结束了，注意：换行和回车也是有效字符，不为0！

* 使用 `sync(int fd)` 立即将脏数据 dirty data 落盘



Pread/pwrite = lseek + read/write。不过区别在于read/write会改变文件指针，但pread/pwrite不会改变

Pread64/pwrite64是把offset扩大为64位的


# 进程

# IPC

# System V IPC

System V通信是指一组在System V UNIX操作系统中用于进程间通信的机制和API。这些通信机制允许不同的进程在同一系统上进行数据交换和协作。System V通信包括以下几种主要的形式：

1. **消息队列（Message Queues）：** 消息队列允许进程通过在消息队列中发送和接收消息来进行通信。每个消息都有一个类型，进程可以选择接收特定类型的消息。消息队列通常用于进程之间的异步通信，其中一个进程将消息发送到队列，而另一个进程则可以在需要时从队列中读取消息。
2. **信号量（Semaphores）：** 信号量是一种计数器，它用于同步多个进程的操作。进程可以执行P（Wait）和V（Signal）操作来控制信号量的值。信号量通常用于解决竞争条件和进程同步问题。
3. **共享内存（Shared Memory）：** 共享内存允许多个进程访问同一块物理内存，这使得它们可以高效地共享数据。共享内存通常用于需要快速数据传输的应用程序，但也需要谨慎处理，以避免数据一致性问题。

这些System V通信机制都是底层的，需要开发人员自行管理进程间的同步和互斥。它们为不同的进程提供了一种可靠的方式来进行进程间通信，以便协作完成任务。这些通信机制通常用于复杂的多进程或多线程应用程序中，以确保数据的一致性和协调工作。

System V通信机制在Linux中也有支持和实现。Linux支持System V IPC，以便与传统的UNIX系统和应用程序兼容。因此，在Linux上，你可以使用System V消息队列、信号量和共享内存来进行进程间通信，就像在其他UNIX系统上一样。

# POSIX IPC

# 虚拟内存

## *虚拟内存操作*

## *内存映射*

### mmap API

内存映射 Memory mapping 是指将一个文件或者其他设备的内容映射到进程的虚拟地址空间，使得这部分内容可以被当作内存一样进行读写操作。进程可以通过读写这个区域来实现对文件或设备的操作，而不需要使用传统的文件读写接口或设备访问接口，比如缓慢的 read、write 等

内存映射可以通过操作系统提供的系统调用，如 `mmap()` 来实现，它将文件或设备映射到进程的地址空间，并在内核中建立相应的映射关系。一旦内存映射建立，进程就可以直接读写映射区域的内容，而OS会负责将这些操作转换为实际的文件读写或设备访问操作

<img src="/Users/wjfeng/Desktop/Notes/CS/操作系统/系统编程/mmap-9966190.png">

```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
int munmap(void *addr, size_t length); // 删除内存映射
```

* 参数
  * addr：用户进程中要映射的用户空间的起始地址，通常为NULL（由内核来指定）
  * length：要映射的内存区域的大小
  * prot：期望的内存保护标志
    * PROT_EXEC  Pages may be executed
    * PROT_READ  Pages may be read
    * PROT_WRITE Pages may be written
    * PROT_NONE  Pages may not be accessed
  * flags：指定映射对象的类型
    * MP_PRIVATE 创建一个私有映射
    * MP_SHARED 创建一个共享映射
  * fd：文件描述符（由open函数返回）
  * offset：设置在内核空间中已经分配好的的内存区域中的偏移，例如文件的偏移量，大小为PAGE_SIZE的整数倍。用于对齐
* 返回值
  * 成功时 `mmap()` 返回被映射区的指针，该指针就是需要映射的内核空间在用户空间的虚拟地址
  * 失败时根据SUSv3标准返回 `MAP_FAILED == ((void *)-1)` 常量


### mmap的原理

<https://nieyong.github.io/wiki_cpu/mmap详解.html>

<https://www.cnblogs.com/huxiao-tee/p/4660352.html>

<img src="/Users/wjfeng/Desktop/Notes/CS/操作系统/系统编程/mmap原理-9966190.png">

管理虚拟进程空间的mm_struct结构体中有mmap指向 vm_area_struct，用于管理每一个虚拟内存段

mmap内存映射的实现过程，大致可以分为三个阶段

1. **进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域**

   1. 进程在用户空间发起系统调用接口mmap
   2. 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址
   3. 为此虚拟区分配一个vm_area_struct结构，并对这个结构的各个域进行初始化
   4. 将新建的虚拟区结构 vm_area_struct 插入进程的虚拟地址区域链表或树中

2. **调用内核空间的系统调用函数mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系**

   1. 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息
   2. 通过该文件的文件结构体，链接到file_operations模块，调用内核函数 sys_mmap
   3. sys_mmap 通过虚拟文件系统的inode定位到文件磁盘物理地址
   4. 通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中

3. **进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝**

   前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时

   1. 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常
   2. 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程
   3. 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中
   4. 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程

注意：修改过的脏页并不会立即更新回文件中，而是有一段时间的延迟，可以调用 `msync()` 来强制同步, 这样所写的内容就能立即保存到文件里了

### mmap的应用

* 通信 <https://blog.csdn.net/augfun/article/details/113667932>
* 实现零拷贝 IO，不过主要目的还是为了通信，可以看 *高并发.md*
* malloc分配大于128KB时会调用 `mmap()` 而不是 `brk()`

### 安全性

以下是一些可能的安全问题：

1. 内存访问越界：如果进程在内存映射区域之外进行读写操作，可能会导致内存访问越界的问题，例如读取或修改未映射的内存内容，或者覆盖其他重要数据
2. 潜在的漏洞利用：内存映射可以使恶意用户或程序能够读取或修改敏感数据，例如密码、私钥等。如果对映射区域的权限控制不严格或存在安全漏洞，攻击者可能利用这些漏洞来获取敏感信息
3. 共享对象的安全性：内存映射允许多个进程共享同一个文件的内容。如果共享对象不受适当的保护或验证，可能会导致一个进程对共享对象的恶意修改影响其他进程的安全性

为了确保内存映射的安全性，应该采取以下措施：

1. 权限控制：确保只有授权的进程或用户可以访问映射区域，并且限制他们对映射区域的读写权限。适当的权限控制可以防止未经授权的访问和恶意操作
2. 内存保护：使用内存保护机制，如设置合适的访问权限和内存保护位，以防止越界访问和非法操作
3. 数据验证和加密：对于包含敏感数据的内存映射区域，可以采用数据验证和加密的方法来保护数据的完整性和机密性，以防止未经授权的读取或篡改
4. 共享对象的安全性：对于共享对象，应该实施适当的验证和完整性检查，确保在共享过程中不会被恶意篡改

## *匿名映射*



### msync

```c
 int msync(void *addr, size_t length, int flags);
```

`msync()` 系统调用可以让程序显式控制何时完成共享映射与映射文件之间的同步

* MS_SYNC 同步：调用后等到更新完成之后才返回
* MS_ASYNC 异步：调用后立即返回，不会等待更新的完成
* 成功返回0，失败返回-1

### mremap

Linux提供了不可移植的 `mremap()` 系统调用来执行映射区域变更（扩容或缩容）

```c
void *mremap(void *old_address, size_t old_size,
                    size_t new_size, int flags, ... /* void *new_address */);
```

* addr：上一次已映射到进程空间的地址
* old_size：旧空间的大小
* new_size：重新映射指定的新空间大小
* flags
	* 0，0代表不允许内核移动映射区域，只能原地扩，如果原地扩失败了就报错
	* MREMAP_MAYMOVE，MREMAP_MAYMOVE则表示内核可以根据实际情况移动映射区域以找到一个符合new_size大小要求的内存区域