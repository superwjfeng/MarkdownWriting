# Linux发展史 & 标准

## *UNIX*

### UNIX的定义

* 指通过 SUS, Single UNIX Specification 所规范的官方一致性测试,且由OPEN GROUP（UNIX 商标的持有者）正式授权冠以“UNIX”的操作系统
* 运作方式类似于经典 UNIX 系统的操作系统

### UNIX & C的早期历史

1. 1960年代初：1969年，由美国贝尔实验室的 Ken Thompson 和 Dennis Ritchie 等计算机科学家创建。最初的UNIX系统是为PDP-7和PDP-11等小型计算机设计的，旨在提供一个多用户、多任务的操作系统，用于支持科学和研究计算

2. 1970年代：在70年代初，UNIX系统逐渐发展壮大， Dennis Ritchie 设计并实现出了C编程语言，这成为后来UNIX系统的主要编程语言。C语言的设计受到了汇编语言和BCPL语言的影响，它具有直接的硬件访问能力、高效的内存管理和丰富的控制结构，使其非常适合系统编程。

   实现C语言的初衷就是为了实现 UNIX 内核及其相关软件而开发一种高层语言。这也是为什么C/C++成为了系统编程的首要语言。C的出现在当时填补了系统编程方面的语言空白

3. 1973年：UNIX操作系统的第一个正式版本被称为UNIX第四版（UNIX Version 4），这个版本是用C语言编写的。这标志着C语言与UNIX系统的密切结合，使得UNIX能够更容易地在不同的硬件平台上移植，因为C语言具有可移植性

   UNIX 因此也一变而为最早以高级语言开发而成的操作系统之一

4. 1975 年 3 月发布的第六版UNIX是在 AT&T 之外广泛使用的首个 UNIX 版本

## *UNIX家族*

1980年代：UNIX系统分化出了多个不同的分支，包括AT&T的System III和System V，以及 UC Berkeley 的BSD, Berkeley Software Distribution。这些分支在功能和特性上有所不同，但它们都继承了UNIX的核心思想，并继续使用C语言进行开发和扩展

<img src="UNIX时间线.png">

Source: Wikipedia https://en.wikipedia.org/wiki/History_of_Unix

### BSD家族

受母校 UC Berkeley 之邀， Ken Thompson 于 1975/1976 学年曾担任该校的客座教授。在此期间，他与研究生们一起为 UNIX 开发了许多新特性和工具。比如说C shell、vi 编辑器、一种改进型的文件系统(伯克利快速文件系统) 、sendmail、Pascal 语言编译器，以及用于新型 Digital V AX 架构的虚拟内存管理机制

1. 1979年12月，诞生了首个完整的 UNIX 发布版 3BSD
2. 1983年的4.2BSD：这是BSD家族的第一个重要版本，于1983年发布。它引入了许多重要的功能，如完整的TCP/IP网络协议栈实现、虚拟内存系统和套接字编程接口。4.2BSD对互联网的发展产生了深远的影响，并成为后来BSD版本的基础

BSD的著名版本，基本都是开源软件

1. FreeBSD：FreeBSD是BSD家族中最著名和广泛使用的实现之一。它注重性能和可用性，广泛应用于服务器环境和大规模应用。FreeBSD具有强大的网络功能和可扩展性，还支持Jails技术，允许虚拟化多个独立的操作系统环境
2. OpenBSD：OpenBSD专注于安全性和代码审查，其目标是创建最安全的操作系统。它具有强大的网络安全功能和默认启用的安全设置。OpenBSD还维护了OpenSSH项目，这是一种用于加密远程通信的开源工具
3. NetBSD：NetBSD是一个注重可移植性的BSD分支，其目标是在各种硬件平台上运行。它的主要特点之一是广泛的硬件支持，使其成为嵌入式系统和各种设备的首选操作系统。NetBSD还注重代码的清晰性和可维护性
4. DragonFly BSD：DragonFly BSD是一个专注于多处理器 SMP 系统的BSD分支，它的目标是提供高性能的多核心支持。它采用了一种全新的虚拟内存系统，以提高系统的扩展性和性能

### System V家族

在BSD蓬勃发展的同时，由于AT&T受到反垄断法的拆分，随着其在电话系统市场垄断地位的丧失，AT&T 也因而获准销售 UNIX

1. System III 由 AT&T 所属的 UNIX 支撑团队 UNIX Support Group, USG 研发, 该团队雇佣了数以百计的研发人员来从事 UNIX 系统的增强以及应用开发（尤其针对文档预备软件包和软件开发工具）
2. 1983 年，System V 的首个发布版发布。在经过一系列发布后，USG 最终于 1989 年推出了 System V Release 4(SVR4) ，此时的 System V 吸收了 BSD 的诸多特性，比如说联网能力。AT&T 将 System V 授权给不同厂商，这些厂商又将其作为自身 UNIX 实现的基础

System V的著名版本，基本都是商业软件

1. AT&T UNIX System V：AT&T UNIX System V是System V的官方实现，起源于贝尔实验室。它是System V操作系统的基础版本，后来的System V版本都是从它分支出来的
2. IBM AIX：IBM的AIX操作系统是基于System V的UNIX实现，旨在运行IBM的大型服务器和工作站。它具有强大的企业级特性和可扩展性
3. HP-UX：惠普（Hewlett-Packard）的HP-UX是另一种基于System V的UNIX实现，用于HP的服务器和工作站。它提供了高性能的计算和可靠性
4. Solaris：Solaris是Sun Microsystems（后来被Oracle收购）开发的UNIX操作系统。它基于System V Release 4（SVR4），具有强大的网络和存储功能。Solaris曾经是企业级UNIX操作系统的领先选择

## *GNU & Linux内核*

### GNU & Linux

GNU, GNU's Not Unix 是一个自由软件项目，它是一个由 Richard Stallman 于1983年发起的计算机操作系统项目，旨在创建一个自由、开源的类UNIX操作系统。GNU项目的目标是提供一个完全自由的操作系统，使用户可以自由运行、复制、分发、学习、修改和改进软件

以下是关于GNU项目的一些重要信息：

1. 自由软件：GNU强调自由软件的理念，即用户应该具有运行、研究、分享和修改软件的自由。为了保护这些自由，GNU采用了GNU通用公共许可证（GNU General Public License，GPL）等自由软件许可协议，确保软件的自由性不受侵犯
2. 工具和应用：GNU项目不仅涉及操作系统内核的开发，还包括了一系列工具、库和应用程序的开发。其中一些著名的GNU工具包括GNU C编译器（GCC）、GNU调试器（GDB）、GNU文本编辑器（Emacs）等
3. GNU/Linux：虽然GNU项目开发了大部分操作系统组件，但在早期，还缺少一个称为内核的关键组件。因此，Richard Stallman 与 Linus Torvalds 合作，将Linux内核与GNU工具和应用程序相结合，创造了GNU/Linux操作系统，也被简称为Linux。这个组合成为了开源社区中最流行的操作系统之一
4. GNU自由文档许可证：GNU项目还为文档和教育资料提供了自由文档许可证（GNU Free Documentation License，GFDL），以保护用户对于文档的自由使用和分发
5. 社区参与：GNU项目鼓励开发者和用户积极参与，为自由软件的开发和改进做出贡献。社区支持和合作在GNU项目的成功中起到了关键作用

### Linux版本号

1. Linux 0.01（1991年）：这是Linux内核的首个公开发布版本，由 Linus Torvalds 发布。它只包含了约10,000行代码，仅支持Intel 386处理器
2. Linux 0.95（1992年）：这个版本引入了虚拟文件系统（Virtual File System，VFS），这是一个允许Linux支持多种文件系统的重要组件
3. Linux 1.0（1994年）：这是Linux内核的首个正式稳定版本，标志着Linux成熟为可用于生产环境的操作系统
4. Linux 2.0（1996年）：这个版本引入了对Symmetric Multiprocessing（SMP）的支持，使Linux能够在多处理器系统上运行。此外，它还增加了对新的硬件设备的支持
5. Linux 2.2（1999年）：这个版本带来了TCP/IP栈的性能改进，使Linux成为一个更好的网络服务器。它还增加了对USB设备的支持
6. Linux 2.4（2001年）：这个版本进一步改进了SMP支持、网络性能和硬件兼容性。它引入了防火墙功能（Netfilter/Iptables）
7. **Linux 2.6（2003年）：这个版本引入了动态调度器、完善的电源管理、内存管理改进以及更好的性能和稳定性。2.6内核系列维持了很长时间，成为许多发行版的基础**
8. Linux 3.x（2011年）：这个版本引入了很多新的硬件支持和性能优化，同时也改进了文件系统和虚拟化支持
9. Linux 4.x（2015年）：这个版本继续增加了新硬件的支持，改进了内存管理、文件系统、安全性和性能
10. Linux 5.x（2019年）：这个版本引入了许多新功能，包括实时内核调度、I/O性能优化、显著改进的网络性能以及新的文件系统特性
11. Linux 6.x（预期）：未来的Linux内核版本将继续演进，以满足新的硬件和应用需求，增加新的功能和改进性能、安全性等方面的特性

Linux内核版本号在2.6之前确实采用了x.y.z（主版本号、次版本号和修订号）的格式

### Linux发行版

准确来说，Linux指的是Linus Torvalds及社区开发的Linux内核，不过也可以指Linux的软件包（工具和库），这些软件包可以被商业化形成不同的发行版 Linux distribution

发行版的目的是为了简化Linux操作系统的安装、配置和维护，以满足不同用户的需求和用途。每个发行版都可以有自己的特点和目标受众

* Ubuntu：用户友好、易用性强、大量的软件包、广泛社区支持。适用于桌面、服务器和云计算
* Debian：稳定性强、广泛的软件包支持、强调自由软件。适用于桌面、服务器和嵌入式系统
* CentOS（现在称为CentOS Stream）：稳定性强、面向企业、与Red Hat Enterprise Linux, RHEL 兼容。适用于：企业服务器和工作站
* Fedora：先进的软件、最新技术、社区驱动。适用于：桌面和开发者
* Red Hat Enterprise Linux, RHEL：企业级支持、长期支持（LTS）、面向企业客户。适用于：大型企业和数据中心
* SUSE Linux Enterprise Server, SLES：企业级支持、高可用性、面向企业客户。适用于：大型企业和数据中心
* Arch Linux：滚动更新、高度可定制、面向高级用户
* Manjaro：用户友好的Arch Linux分支、易用性强
* Slackware：古老而稳定、简单、面向高级用户

### License

下面是一些常见的开源许可证

* MIT许可证：
   * 允许用户在几乎任何情况下自由使用、修改、复制和分发项目
   * 要求在项目中包含原始许可证和版权声明
   * MIT许可证非常宽松，允许其他人在几乎不受限制的情况下使用代码
* BSD许可证：
   * 有多个变种，如2-Clause BSD、3-Clause BSD等
   * 允许几乎不受限制地使用、修改和分发代码，类似于MIT许可证
   * 通常只要求在源代码中包含原始许可证和版权声明
* GNU通用公共许可证（GPL）：
   * 分为GPLv2和GPLv3两个主要版本，其中GPLv3具有更多的保护措施和约束
   * 强制要求所有派生作品也必须采用相同的GPL许可证，以保持开源性
   * 用于确保开源项目的自由和共享，但可能对商业应用产生一些限制
* Apache许可证：
   * 允许用户使用、修改、分发和用于商业目的
   * 对专利权有一些附加规定，以确保贡献者不会通过专利权来限制其他人的使用
   * 适用于需要保护知识产权并允许广泛使用的项目
* GNU较宽松公共许可证（LGPL）：
   * 允许将LGPL许可的代码链接到封闭源码项目中，而不会强制整个项目采用LGPL
   * 通常用于开发库或组件，使其在广泛的应用程序中可用
* Creative Commons许可证：
   * 主要用于非代码内容，如文档、图像、音频和视频
   * 允许创建者定义一系列条件，如是否允许商业用途、是否要求署名等

## *UNIX标准化*

### POSIX & SUS

<img src="UNIX标准时间表.png" width="50%">

* IEEE 的 POSIX 标准
  * POSIX, Portable Operating System Interface 可移植操作系统 最初由IEEE制定，以确保UNIX操作系统在不同系统上的可移植性。POSIX定义了一系列API（应用程序编程接口）和命令行工具，包括文件操作、进程管理、信号处理、线程控制、网络编程和 Shell 命令等。POSIX标准的目标是使开发人员能够编写在不同UNIX系统上可移植的应用程序
  * POSIX大致可以分为POSIX.1和POSIX.2（对UNIX中的shell和各种工具定义了标准），最新的标准是POSIX.1-2017
* The Open Group 的 SUS 标准
  * 1996年，X/Open 与 Open Software Foundation, OSF 开放软件基金会合并，成立了 The Open Group。几乎每家与UNIX 系统有关的公司或组织都是 The Open Group 的会员，该组织持续着对 API 标准的开发
  * SUS, Single UNIX Specification 由The Open Group制定和维护，它包括了UNIX操作系统的核心和可选组件
* 统一POSIX和SUS
  * 1999 年开始，出于修订并加强 POSIX 标准和 SUS 规范的目的，IEEE、The Open Group 以及 ISO/IEC 联合技术委员会共同成立了奥斯丁公共标准修订工作组 The Austin Common Standards Revision Group, CSRG
  * 2001 年 12 月，该工作组正式批准了 POSIX 1003.1-2001，有时也简称为 POSIX.1-2001。随后又获批为 ISO 标准：ISO/IEC 9945:2002)
  * POSIX 1003.1-2001 是具有里程碑意义的UNIX标准，它取代了 SUSv2、POSIX.1、POSIX.2 以及大批的早期 POSIX 标准。有时, 人们也将该标准称为SUSv3。通过 SUSv3 认证的 UNIX 实现可被称为 UNIX 03
  * 2008年，Austin CSRG又推出了 POSIX.1-2008/SUSv4

### ABI

ABI, Application Binary Interface 应用程序二进制接口相比于语言层面的API更加严格和难以实现，定义了编程语言编译器和操作系统之间的接口规范，从而实现一次编译成型后在不同的ISA上都可以运行

ABI没有提供显式接口，而是由内核和工具链 toolchain 定义和实现的

ABI包括了以下方面的规范：

* 数据表示：定义了数据类型的表示方式，包括整数、浮点数、字符等。它规定了数据的字节顺序、对齐方式以及数据在内存中的布局
* 函数调用约定：规定了函数的参数传递方式、寄存器的使用规则、栈的管理方式以及函数调用的返回值处理方法。不同的架构和操作系统可能有不同的函数调用约定
* 寄存器使用：定义了哪些寄存器是可用的、用于哪些目的、以及在函数调用时如何保存和恢复寄存器的值
* 异常处理：规定了异常、中断和系统调用的处理方式，包括如何触发和响应这些事件，以及如何传递异常信息
* 系统调用：定义了操作系统提供的服务和函数调用接口，包括如何通过系统调用访问操作系统功能，例如文件系统、进程管理、网络通信等
* 共享库：规定了共享库（也称为动态链接库）的格式、加载方式以及运行时链接过程，以便不同程序可以共享和重用代码

# 系统调用

## *系统调用的封装 & 使用*

### 封装流程

<img src="系统调用封装流程.drawio.png" width="70%">

1. 用户层的函数调用：在用户层，系统调用通常通过标准库函数（如 glibc）提供的封装接口调用。例如，当在 C 程序中调用 `read()` 或 `write()` 时，实际上是在调用封装了系统调用的标准库函数
2. 封装和转换：这些标准库函数内部会进行一些参数的封装和转换，准备好用于系统调用。它们使用 `syscall` 函数（或类似机制）来发起实际的系统调用。**`syscall` 函数负责将系统调用的编号和参数放到正确的寄存器中**
3. 触发系统调用：接下来，`syscall` 函数会执行一个特殊的指令（如 `int 0x80` 或 `syscall`），这个指令触发一个模式切换从用户模式跳转到内核模式，并将控制权传递给操作系统
4. 系统调用入口点：在内核中，有一个系统调用入口点（通常是一些汇编代码），它根据系统调用的编号将执行流程转发到相应的内核服务函数。这个入口点负责从寄存器中读取系统调用的参数（如果有的话），并将其传递给相应的内核函数
5. 执行系统调用：内核中的系统调用处理函数（如 `sys_read` 或 `sys_write`）接下来执行实际的工作。这可能涉及文件操作、网络通信、进程管理等
6. 返回结果：一旦系统调用处理函数完成，结果和任何输出参数都会被放回到寄存器中。然后控制权返回到系统调用入口点，该入口点接着返回到用户空间
7. 用户空间恢复执行：最后，控制权回到用户空间的 `syscall` 函数，它从寄存器中获取返回值，并将其返回给原始的库函数调用。随后，库函数将这个返回值传递回应用程序
8. 应用程序继续执行：应用程序接收到从库函数返回的系统调用结果，并继续其执行流程

### 以open为例说明封装

以open的封装为例来厘清 C标准库、glibc 运行时库、系统调用和Linux内核之间的关系

首先C标准库是一套标准，而不是一种具体的实现。glibc 动态库（运行时库）是GNU项目的一部分，它是C标准库的一个具体实现

C函数 `fopen`，系统调用 `open`，系统调用 `__libc_open` （glibc/sysdeps/unix/sysv/linux/open.c）和Linux内核 `sys_open` （/fs/open.c），这些是在 C 和 Linux 系统中用于打开文件的函数，它们之间的关系如下：

1. 当应用程序调用 `fopen` 函数时，实际上是调用由 glibc 所提供的一个包装函数 wrapper function（包装函数就是封装了其他函数的函数）。这个包装函数对传递给 `fopen` 的参数进行了一些额外的处理，然后调用 `__fopen_internal` 函数
2. `__fopen_internal` 是 glibc 的内部函数，它实现了实际的文件打开逻辑。它会根据使用的 glibc 版本调用 `open` 或 `__libc_open` 函数
3. `open` 和 `__libc_open` 都是用于打开文件的函数。`open` 是 Linux 内核提供的系统调用，而 `__libc_open` 是 glibc 的内部函数，提供了更灵活的打开文件接口。根据使用的 glibc 版本，`__fopen_internal` 可能会调用 `open` 或 `__libc_open`
4. `sys_open` 是 Linux 内核提供的系统调用，由 `open` 或 `__libc_open` 调用，用于实际打开文件并返回文件描述符，这个文件描述符可用于后续的读写操作

因此，它们之间的调用顺序可以总结如下

1. 应用程序调用 `fopen` 函数
2. glibc 库的包装函数处理参数并调用 `__fopen_internal`
3. `__fopen_internal` 根据使用的 C 库版本调用 `open` 或 `__libc_open`
4. `open` 或 `__libc_open` 调用系统调用 `sys_open` 来打开文件并返回文件描述符
5. `sys_open` 打开文件并返回文件描述符
6. `open` 或 `__libc_open` 将文件描述符返回给 `__fopen_internal`
7. `__fopen_internal` 将 FILE 指针返回给 C 库的包装函数
8. 包装函数将 FILE 指针返回给应用程序

总结一下

* Glibc 是纯语言级别的库，它里面有大量wrapper，涉及到系统的函数会去封装系统调用
* 系统调用是OS封装好暴露出接口交给用户使用的库，system call的时候会发生陷入内核
* Linux内核函数是最底层的库，完全由系统使用，用户无法接触到

### 系统调用的使用方式

* 使用C运行时库

* 使用 `syscall` 函数来调用

  ```c
  syscall(SYS_write, fd, buffer, nbytes);
  ```

  当需要执行没有直接库函数封装的系统调用，或者需要绕过标准库对某个系统调用的特定行为时

  ```c
  #include <unistd.h>
  #include <sys/syscall.h>   /* For SYS_xxx definitions */
  long syscall(long number, ...);
  ```

  * 参数
    * sysno是系统调用号，唯一标识系统调用号，详见 sys/syscall.h
    * `...` 为剩余可变长的参数，为系统调用所带的参数，根据系统调用的不同，可带0~5个不等的参数。若超过特定系统调用能带的参数，多余的参数会被忽略
  * 返回值：该函数返回值为特定系统调用的返回值，在系统调用成功之后可以将该返回值转化为特定的类型，若系统调用失败则返回 -1，错误代码存放在errno中

  ```c
  #include <stdio.h>
  #include <unistd.h>
  #include <sys/syscall.h>
  #include <errno.h>
  
  int main() {
      int rc;
      rc = syscall(SYS_chmod, "/etc/passwd", S_IROTH | S_IRGRP | S_IRUSR);
      if (rc == -1) fprintf(stderr, "chmod failed, errno = %d\n", errno);
      else printf("chmod succeess!\n");
      return 0;
  }
  ```

  存在移植性问题：不同系统上的系统调用号可能是不同的，用syscall取调用的话不方便

* 低级访问，直接使用软件中断：这种方式极少使用

  这种方法涉及直接在程序中使用汇编代码，或使用特殊的编译器内置功能来触发系统调用。在x86架构上，这通常通过执行 `int 0x80` 指令（旧的方法）或 `syscall` 指令（较新的方法）完成

  极少数情况下会使用，通常用于深度系统编程或操作系统开发。对于应用程序开发者来说，这种方法通常是不必要的，且难以维护

## *内核空间的实现*

### 系统调用表

系统调用表本质上是一个函数指针数组，每个元素对应一个系统调用处理函数。当用户空间的程序发起一个系统调用时，操作系统使用这个表来查找并调用相应的内核函数。这个表是内核如何处理各种不同系统调用的基础。下面是一种可能的声明

```c
asmlinkage long (*sys_call_table[])(void);
```

当一个程序执行系统调用时（比如通过 `syscall` 指令），系统调用的编号会被传递给内核。内核使用这个编号作为索引到系统调用表中，找到对应的函数指针，然后执行相应的函数

系统编号一般被定义在 asm/unistd.h 中，它就是所有系统调用的宏定义。比如说

```c
#define __NR_restart_SYScall           (__NR_SYSCALL_BASE+   0)
#define __NR_exit                      (__NR_SYSCALL_BASE+   1)
#define __NR_fork                      (__NR_SYSCALL_BASE+   2)
#define __NR_read                      (__NR_SYSCALL_BASE+   3)
#define __NR_write                     (__NR_SYSCALL_BASE+   4)
#define __NR_open                      (__NR_SYSCALL_BASE+   5)
#define __NR_close                     (__NR_SYSCALL_BASE+   6)
```

例如，如果一个程序执行 `read()` 系统调用，操作系统将使用与 `read` 对应的编号在系统调用表中查找，然后调用 `sys_read` 函数

在某些情况下，比如在开发某些类型的内核模块时，可能需要修改系统调用表。这是一个高风险操作，因为不正确的修改可能导致系统不稳定或不安全。在现代的Linux内核中，系统调用表通常是只读的，以防止恶意软件更改

### asmlinkage

`asmlinkage` 是一个在 Linux 内核源代码中经常出现的关键字，它在 C 语言函数和汇编代码之间的接口中扮演了重要的角色

在许多操作系统中，特别是在使用 C 语言编写的系统中，当一个函数被调用时，它的参数通常是通过寄存器或者堆栈传递的。不同的编译器和架构可能有不同的约定来决定使用哪种方式

当执行系统调用时，参数是通过寄存器传递给操作系统的。这是因为系统调用通常是通过特殊的指令（如在 x86 架构上的 `int 0x80` 或 `syscall`）来实现的，这些指令不会像标准的函数调用那样使用堆栈传递参数

`asmlinkage` 标记用于告诉编译器，被标记的函数的所有参数都应该从堆栈中获取，而不是寄存器。这对于系统调用非常重要，因为它们的参数实际上是由用户空间的程序放在堆栈上的，然后由系统调用的入口代码（通常是汇编写的）从堆栈上获取并放入寄存器。内核中相应的系统调用处理函数然后使用 `asmlinkage` 来从堆栈上恢复这些参数

一个带有 `asmlinkage` 的函数定义可能看起来像下面这样，这表示 `sys_my_syscall` 函数期望其参数从堆栈上获取，而不是从寄存器中

```c
asmlinkage long sys_my_syscall(int arg1, char *arg2, ...);
```

## *运行时库*

### 系统调用 System Call 和函数库

* 在开发角度，操作系统对外会表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口称为系统调用
* 系统调用在使用上，功能比较基础，对用户的要求相对也比较高。因此开发者会对部分系统调用进行二次开发和适度封装，形成一个供上层开发者使用的库

### glibc wrapper

Wrapper 或 外壳函数 通常是指一个包装或封装另一个函数的函数。这种技术通常用于修改或扩展原始函数的行为，同时保持原始函数的API不变。glibc中的wrapper一般都会调用syscall来陷入内核执行系统调用

标准C语言函数库的实现随UNIX的实现而异。glibc 是 Linux 下使用的开源的标准C库，用于支持Unix-like操作系统的开发。glibc 是 GNU 发布的libc 库，即运行时库。glibc提供了一组标准的C函数和头文件，使程序员能够编写跨平台的C代码，并与操作系统进行交互，执行各种系统级操作

Glibc 实现操作系统提供的系统服务，即系统调用的封装。每个特定的系统调用对应了至少一个 glibc 封装的库函数。多个 API 也可能只对应同一个系统调用

返回值-1在多数情况下表示内核不能满足进程的请求，Libc中定义的errno变量包含特定的出错码

### 确定glibc的版本

* 查看共享库版本号

  ```cmd
  $ ldd main | grep libc
  	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007ff395ef7000)
  ```

* `gnu_get_libc_version()`

* `confstr()`

## *系统调用的性能*

# 系统设置

## *用户和组*

### 用户

系统的每个用户都拥有唯一的登录名 login name（用户名 username）和与之相对应的整数型用户 ID User ID, UID

系统密码文件 /etc/passwd 为每个用户都定义有一行记录，每行都包含 7 个字段，每个字段之间用冒号分隔

```
用户名 username:经过加密的密码:UID:GID:注释:主目录$HOME:登陆shell$SHELL
wjfeng:x:1002:1002:,,,:/home/wjfeng:/bin/zsh
```

关于密码：要是启用了 shadow 密码（这是常规做法）的话，系统将会不解析该字段。这时 /etc/passwd 中的密码字段通常会包含字母“x” （当然也可以是任何非空字串），而经过加密处理的密码实际上却存储到 shadow 密码文件中。若 /etc/passwd 中密码字段为空，则该账户登录时无需密码

### shadow密码

UNIX 一直在 /etc/passwd 中维护所有的用户信息，这其中就包括经过加密处理的密码，但这会引发安全问题。因为密码是很多非内核程序也需要用到的，所以也需要提供权限给这些程序，这就给密码破解留下了机会

作为一种反制措施，shadow 密码文件 /etc/shadow shadow 单独维护密码文件，仅供具有特权的程序读取

UNIX 系统采用单向加密算法对密码进行加密，需要用下面的 crypt 库函数来进行验证。使用 crypt 时要在编译程序时需开启–lcrypt 选项,以便程序链接 crypt 库

```c
#include <crypt.h>
char *crypt (const char *hey, const char *salt);
			// Returns pointer to statically alocated string containing
			// encrypted password on success, or NULL on error
```

crypt采用DES算法来加密，其中 key 是最长可达 8 字符的密钥，salt 则是一个两字符的字符串，用来扰动 DES 算法

### 组

将用户分组主要是出于便于管理的目的，尤其是为了控制对文件和其他资源的访问

每个用户组都对应着系统组文件 /etc/group 中的一行记录

```
组名:经过加密的密码:GID:用户列表
sudo:x:27:ubuntu,wjfeng
```

### 添加sudo信任

root的UID是0

## *系统限制*

## *获取系统和进程信息*

## *时间*

### 日历时间

### 时间转换函数

### 时区 & 地区

```c
#include <locale.h>
char *setlocale(int category, const char *locale);
			// Returns pointer to a (usually statically allocated) string identifying
			// the new or current locale on success, or NULL on error
```

### 进程时间

进程时间是进程创建后使用的 CPU 时间数量，它分为用户CPU时间和进程CPU时间

* 用户 CPU 时间是在用户模式下执行所耗费的时间，也称为虚拟时间 virtual time
* 系统 CPU 时间是在内核模式中执行系统调用所耗费的时间

```c
#include <sys/times.h>
clock_t times(struct tms *buf);
			// Returns number of clock ticks (sysconf(_SC_CLK_TCK)) since
			// “arbitrary" time in past on success, or (clock_t)-1 on crror
```

结果通过 buf 指向的结构体返回

```c
struct tms {
	clock_t tms_utime;  /* User CPU time used by Caller */
	clock_t tms_stime;  /* System CPU time used by caller */
	clock_t tms_cutime; /* User CPU time of all (waited for) children */
	clock_t tms_cstime; /* System CPU time of all (waited for) children */
};
```

tms 结构体的前两个字段返回调用进程到目前为止使用的用户和系统组件的 CPU 时间。后两个字段返回的信息是父进程（比如 times 的调用者）执行了 wait 的所有已经终止的子进程使用的 CPU 时

```c
#include <time.h>
clock_t clock(void);
			// Returns total CPU time used by calling process measured in
			// CLOCKS_PER_SEC, Or (clock_t)-1 on error
```

返回一个值描述了调用进程使用的总的 CPU 时间（包括用户和系统）

# 通用文件IO

## *Helper*

### Reminder：C文件接口

* 当前路径：当一个进程运行起来的时候，每个进程都会记录自己当前所处的工作路径

* C/Cpp程序 默认会打开三个文件流：标准输入 `FILE *stdin`、标准输出 `FILE *stdout`、标准错误 `FILE *stderr`

* C语言接口

  * C语言打开文件 fopen：r, r+, w（在fwrite前就清空）, w+, a（追加）, a+

  * C语言按行读取文件：fgets

  * C语言写文件：fwirte, fprintf, fputs

  * 简单模拟实现cat命令

    ```c
    #include <stdio.h>    
    #include <unistd.h>    
    #include <string.h>    
    
    int main(int argc, char *argv[]) {    
        if (argc != 2) {    
            printf("argv error\n");    
            return 1;    
        }    
        FILE *fp = fopen(argv[1], "r");
        if (fp == NULL) {    
            perror("fopen");    
            return 2;    
        }    
        // 按行读取    
        char line[64];    
        // fgets是C语言的接口来取string，因此会自动在字符结尾添加\0    
        while (fgets(line, sizeof(line), fp) != NULL) {    
            // printf("%s", line);    
            fprintf(stdout, "%s", line);    
        }    
        return 0;    
    }    
    ```

### 补充：位图的使用

bitmap 位图：将选项#define为不同的比特位，通过输入形参的不同组合来达到选择或同时输入多个参数的目的

```c
#include <stdio.h>    
#include <unistd.h>    
#include <string.h>    
    
// 用int中的不重复的一个bit，就可以表示一种状态    
#define ONE 0x1   // 0000 0001    
#define TWO 0x2   // 0000 0010    
#define THREE 0x4 // 0000 0100    
    
void show(int flags) {    
    if (flags & ONE)    
        printf("hello one\n");    
    if (flags & TWO)    
        printf("hello two\n");    
    if (flags & THREE)    
        printf("hello three\n");    
}    
    
int main() {    
    show(ONE);    
    printf("-------------------------\n");    
    show(TWO);    
    printf("-------------------------\n");    
    show(ONE | TWO);    
    printf("-------------------------\n");    
    show(ONE | TWO | THREE);    
    printf("-------------------------\n");
    
    show(ONE | THREE);    
    return 0;    
}    
```

## *打开、关闭、读写*

### 打开、关闭文件

打开文件用open

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
int creat(const char *pathname, mode_t mode);
				// Returns file descriptor on success, or -1 on error
```

* flags 是一种bitmap选项
  * 三种互斥的文件访问模式标志，不能同时使用。其中任意一种可以与其他 flags 进行 `|` 操作
    * O_RDONLY 以只读方式打开文件
    * O_WRONLY 以只写方式打开文件
    * O_RDWR 以可读写方式打开文件
  * O_CREAT 若欲打开的文件不存在则自动建立该文件
  * O_EXCL（exclude）提供保证进程是打开文件的创建者的机制，即独占机制
    * 若O_CREAT 也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误
    * 若O_CREAT 与O_EXCL 同时设置， 并且欲打开的文件为符号连接，则会打开文件失败
  * O_NOCTTY 如果欲打开的文件为终端机设备时，则不会将该终端机当成进程控制终端机
  * O_TRUNC 若文件存在并且以可写的方式打开时，该 flag 会令文件长度清为0，而原来存于该文件的内容也会消失
  * O_APPEND 当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面
  * O_NONBLOCK/O_NDELAY 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中
  * O_SYNC 以同步的方式打开文件
  * O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接，则会令打开文件失败
  * O_DIRECTORY 如果参数pathname 所指的文件并非为一目录，则会令打开文件失败。此为 Linux2.2 以后特有的旗标，以避免一些系统安全问题
* mode 选择文件权限，只有在创建文件的时候才起作用。注意：新建文件的访问权限不仅仅依赖于参数 mode，而且还受到进程的 umask 值和（可能存在的）父目录的默认访问控制列表影响。具体可以看手册或interface

在早期的 UNIX 实现中，`open()` 没有mode参数，无法用来创建新文件，而是使用 `creat()` 系统调用来创建并打开一个新文件。create完全等价于下面的open调用，如果文件已存在会清空文件

```c
fd = open(pathname, O_WRONLY | O_CREAT | O_TRUNC, mode)；
```

关闭文件用close

```c
#include <unistd.h>
int close(int fd);
			// Returns O on success, or -1 on error
```

### write

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
			// Returns number of bytes written, or -l on error
```

* 参数
  * fd 是要操作的文件
  * buf 是计划写入的缓冲区，缓冲区至少要有count个size_t的大小
  * count 要写的**字节数**
* 返回写入的字节数，若遇到文件结尾 EOF 则返回0

参数和read一样。返回读到的字节数，若读到的是0，则意味着文件结束了，注意：换行和回车也是有效字符，不为0！

### read

```c
#include <unistd.h>
ssize_t read (int fd, void *buf, size_t count); 
			// Returns number of bytes read, 0 on EOF, or -1 on error
```

* 参数
  * fd是要操作的文件
  * buf 是计划写入的缓冲区，缓冲区至少要有count个size_t的大小
  * count 要写的字节数
* 返回写入的字节数，若遇到文件结尾 EOF 则返回0

read没有在 `printf()` 函数打印的字符串尾部添加一个表示终止的空字符

## *文件指针相关操作*

有些接口用到了文件指针，即 `struct file` 中的 `loff_t f_pos;` 来控制在文件的某个位置操作

### lseek

> `lseek()`调用名中的 `l` 源于这样一个事实：offset 参数和调用返回值的类型起初都是 long 型。早期的 UNIX 系统还提供了 `seek()` 系统调用，当时这两个值的类型为 int 型。 -- The Linux Programming Interface

```c
#include <sys/types.h>
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
			// Returns new file offset if successful, or -1 on error
```

* offset 参数指定了一个以字节为单位的数值。 SUSv3 规定 `off_t` 数据类型为有符号整型数

* whence 参数表示应参照哪个基点来解释 offset 参数，应为下列其中之一

  <img src="lseek.drawio.png" width="70%">

  * SEEK_SET 将文件偏移量设置为**从文件头部起始点开始**的 offset 个字节
  * SEEK_CUR 相对于**当前文件偏移量**，将文件偏移量调整 offset 个字节
  * SEEK_END 将文件偏移量设置为**起始于文件尾部**的 offset 个字节。也就是说，offset 参数应该从文件最后一个字节之后的下一个字节算起

### 在文件特定偏移量处的IO

```c
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t count, off_t offset);
			// Returns number of bytes read, 0 on EOF, or -1 on error
ssize_t pwrite(int fd, const void *buf, size_t count, off_t offset);
			// Returns number of bytes written, or -1 on error
```

Pread/pwrite会在 offset 参数所指定的位置进行文件IO操作，而非始于文件的当前偏移量处

Pread/pwrite = `lseek(fd, offset, SEEK_CUR)` + read/write。不过区别在于**read/write会改变文件指针，但pread/pwrite不会改变**

Pread64/pwrite64是把offset扩大为64位的

### 文件空洞

从文件结尾后到新写入数据间的这段空间被称为文件空洞 file holes。这段空间用read去读取的会返回全0填充的缓冲区

文件空洞不占用任何磁盘空间，知道后续某个时间点在文件空洞中写入了数据时，文件系统才会为它分配磁盘快

原生的UNIX系统一般都支持文件空洞。不支持文件空洞的OS会显式地将空字节写入文件

### 文件截断

```c
#include <unistd.h>
#include <sys/types.h>
int truncate(const char *path, off_t length);
int ftruncate(int fd, off_t length);
			// Both retur O on success, or -1 on error
```

注意：虽然叫做truncate，但是这个系统调用并不是只能把大file size截断为小file size，而是可以将file调整为给定的任意大小的length

若文件当前长度大于参数 length，调用将丢弃超出部分；若小于参数 length，调用将在文件尾部添加一系列空字节或是一个文件空洞（SUSv3标准）

Truncate 通过文件路径字符串来指定要操作的文件，而fruncate则通过fd来指定文件

## *修改文件状态*

### fcntl

```c
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* arg */ );
			// Return on success depends on cnd, or -1 on error
```

`fcntl()`（file control）是一个Unix和Unix-like操作系统中的系统调用，用于对fd进行各种控制操作。它可以用于执行多种文件操作，包括但不限于以下几种：

* 文件锁定 file locking：fcntl 可以用来设置和释放文件锁定，以防止多个进程同时访问或修改同一个文件。这对于协调多个进程之间的文件访问非常有用，以避免竞态条件和数据损坏
* 修改文件属性：通过 fcntl 可以修改文件的各种属性，如文件的访问模式、文件的所有者和组、文件的时间戳等
* 获取和设置文件状态标志 file status flags：fcntl 可以用于获取和修改fd的状态标志，如非阻塞标志、同步标志等
* 获取和设置文件偏移量 file offset：fcntl 可以用于获取和设置文件描述符的当前文件偏移量，从而实现对文件的随机访问
* 复制fd：fcntl 可以用于复制一个fd，以便在不同的进程或线程之间共享文件描述符
* 获取fd的属性：fcntl 可以用于获取有关fd的信息，如文件类型、文件状态、文件锁定信息等
* 发送信号：在某些情况下，fcntl 可以用于向指定的进程发送信号

### dup\* 复制fd

```c
#include <unistd.h>
int dup(int oldfd);
			// Returns (new)file descriptor on success, or -1 on error
int dup2(int oldfd, int newfd);
			// Returns (new)file descriptor on success, or -l on error

#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
int dup3(int oldfd, int newfd, int flags);
			// Returns (new)file descriptor on success, or -l on error
```

* `dup` （Duplicate File Descriptor）用于复制一个fd，并返回一个新的fd，该新描述符指向与原始文件描述符相同的文件或资源。新的fd是通过寻找fd表中的最小未使用的fd来创建的

* `dup2`（Duplicate to Specified File Descriptor）用于将一个fd复制到另一个指定的fd，而不是创建一个新的fd。如果指定的文件描述符已经被使用，那么 `dup2` 将关闭该fd，然后将其复制为指定的fd

* `dup3` 是Linux特有的系统调用，它类似于 `dup2`，但提供了更多的选项，包括指定文件描述符的标志位（flags）。这使得 `dup3` 更加灵活，并允许在复制文件描述符时设置更多的选项

  ```c
  int fd1 = open("file1.txt", O_RDONLY);
  int fd2 = open("file2.txt", O_WRONLY | O_CREAT, 0644);
  dup3(fd1, 0, O_CLOEXEC); // 将标准输入复制为 fd1，并设置新文件描述符的关闭-on-exec标志
  ```

## *目录 & 链接*

```c
#include <unistd.h>
int unlink(const char *pathname);
			// Returns O on success, or -1 on error

#include <fcntl.h>           /* Definition of AT_* constants */
#include <unistd.h>
int unlinkat(int dirfd, const char *pathname, int flags);
```



```c
#include <stdio.h>
int remove(const char *pathname);
			// Returs O on success, or -1 on error
```

remove 库函数移除一个文件或一个空目录

* 若 pathname 是一文件，那么 remove 调用 unlink
* 若 pathname 为一目录，那么 remove 调用 rmdir



## *特殊的文件操作*

### 大文件操作

32位系统中 off_t 被实现为一个32位的有符号整型，因此它最大能表示一个2GB的文件

调用 open64，相当于在调用 open 的时候在flags里加上了O_LARGEFILE标志。若调用 open 时未指定此标志，且与打开的文件大小是大于2GB的，那么调用将会返回错误

### /dev/fd

### 临时文件



# 缓冲

使用 `sync(int fd)` 立即将脏数据 dirty data 落盘

<img src="IO缓冲小结.png" width="50%">

系统中一共有两种级别的缓冲区：语言级别的用户空间缓冲区和内核级别的缓冲区。以C语言和Linux OS为例，分别为stdio库的缓冲区和Page Cache机制

系统调用不会自动创建缓冲区，使用者必须要预先创建、分配好缓冲区。而语言级别的wrapper则往往会自己创建好缓冲区

### 缓冲区基础

* 为什么要有缓冲区？ -- Cache写方法，提高系统效率
* 缓冲区的刷新策略
  * 立即刷新
  * 行刷新/行缓冲 `\n`：一般是显示器采用这种刷新策略
  * 满刷新/全缓冲：缓冲区满了才刷新，一般是磁盘文件考虑效率采用这种刷新策略 
  * 特殊情况
    * 用户强制刷新 `fflush`
    * 进程退出时若没有被 `close(fd)` 的话就强制刷新
  * 所有设备处于效率考量都倾向于使用全缓冲。这是因为在和外部设备IO的过程中，数据量的大小不是主要矛盾，OS和外设预备IO的的过程才是最耗费时间的，全缓冲可以有更少次的IO，从而提高了效率。其他刷新策略是结合具体情况做的妥协，如显示器是因为给用户看的，需要同时考虑到效率和用户体验
* 缓冲区的位置

### 语言级别的缓冲区：stdio缓冲区试验

<img src="缓冲区试验.png" width="60%">

* 现象：同样的一个程序，向显示器打印时只输出4行文本，但向磁盘上的普通文件重定向打印时就变成了7行，其中C的IO接口打印了2次，而系统接口则和向显示器上打印一样只打印了一次
* 原因：直接调用是写给stdout，策略是行缓冲；后来重定向到文件中，对于磁盘上的文件刷新策略是全缓冲，父进程产生的数据还保留在它的PCB上下文数据中，父子进程退出的时候一并刷新
* 函数退出的时候强制刷新缓冲区，这是一个将数据写给OS的过程，即发生了写时拷贝
* 从试验结果可以看到，缓冲区的刷新策略改变并不会影响系统调用，这说明缓冲区是由语言层面维护的，而非系统层面

### 分散输入和集中输出

分散输入和集中输出 Scatter-Gather IO：`*readv*()` 和 `*writev*()` 分别实现了分散输入和集中输出的功能

```c
#include <sys/uio.h>
ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
			// Returns number of bytes read, 0 on EOF, or -1 on error
ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
			// Returs number of bytes written, or -1 on error
ssize_t preadv(int fd, const struct iovec *iov, int iovcnt,
              off_t offset);
ssize_t pwritev(int fd, const struct iovec *iov, int iovcnt,
               off_t offset);
ssize_t preadv2(int fd, const struct iovec *iov, int iovcnt,
               off_t offset, int flags);
ssize_t pwritev2(int fd, const struct iovec *iov, int iovcnt,
                off_t offset, int flags);
```

这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据

* 数组 iov 定义了一组用来传输数据的缓冲区。iov数组 中的每个成员都是如下形式的数据结构

  ```c
  struct iovec {
  	void *iov_base;    /* Start address of buffer */
  	size_t iov_len;    /* Number of bytes to transfer to/from buffer */
  };
  ```

* iovcnt 则指定了 iov 的成员个数

# 文件属性

## *文件信息*

### stat系统调用

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);
			// All return O on success, or -1 on error
```

上面3个系统调用之间仅有的区别在于对文件的描述方式不同 

* `stat()` 会返回所命名文件的相关信息
* `lstat()` 与 `stat()` 类似，区别在于如果文件属于符号链接，那么所返回的信息针对的是符号链接自身，而非符号链接所指向的文件
* `fstat()` 则会返回由某个打开fd所指代文件的相关信息

`*stat()` 会在缓冲区中返回一个由statbuf指向的stat结构

```c
struct stat {
	dev_t     st_dev;        /* IDs of device on which file resides */
	ino_t     st_ino;        /* I-node number of file */
	mode_t    st_mode;       /* File type and permissions */
	nlink_t   st_nlink;      /* Number of (hard) links to file */
	uid_t     st_uid;        /* User ID of file owner */
	gid_t     st_gid;        /* Group ID of file ouner */
	dev_t     st_rdev;       /* IDs for device special files */
	off_t     st_size;       /* Total file size (bytes) */
	blksize_t st_blksize;    /* Optimal block size for I/O (bytes) */
	blkcnt_t  st_blocks;     /* Number of (512B) blocks allocated */
	time_t    st_atime;      /* Time of last file access */
	time_t    st_mtime;      /* Time of last file modification */
	time_t    st_ctime;      /* Time of last status change */
};
```

### 时间戳



### 文件从属

### 文件权限

## *扩展属性 EA*

## *ACL*

访问控制列表 Access Control List, ACL

## *监控文件*

# 进程属性

```c
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
			// Always successfully returns process ID of caller and process ID of the parent process
```



## *进程凭证*

### 分类

每个进程都有一套用数字表示的UID和GID，有时也将这些 ID 称之为进程凭证 process credentials，它们是用于标识和管理进程身份和权限的一组属性。可以分为

* 实际 read UID & GID：确定了进程所属的用户和组
* 有效 effective UID & GID
  * 当进程尝试执行各种操作（即系统调用）时，联通辅助GID来一起确定授予进程的权限
  * 内核还会使用有效UID 来决定一个进程是否能向另一个进程发送信号
* 保存的 set-user-ID (saved set-user-ID) & GID
* 文件系统用户 ID file-system UID & GID，Linux 专有
* 辅助组 ID supplementary GID

### 获取和修改API

## *进程优先级*

* 为什么要有优先级？CPU资源有限，而进程太多，需要通过某种方式竞争资源
* CPU资源分配的先后顺序，就是指进程的优先权

### 查看系统进程 `ps -la`

<img src="PRI_NI.png">

* UID：代表执行者的身份
* PRI：代表这个进程可被执行的优先级，其值越小越早被执行，系统默认优先级为80
* NI：代表这个进程的nice值，表示进程可被执行的优先级的修正数值，取值范围为 `-20~19`
* 优先级 = 老的优先级 + nice值，因此当nice值为负数时，优先值变小，优先级提高
* 为什么优先级的范围是在 `60~99` 内波动？OS的设计理念并不是让某一个程序最优先，而是均衡地分配资源，所以优先级的差距不宜过大，否则可能会有恶意进程通过提高自己的优先级而导致CPU在调度时总是先调度该恶意程序，导致其他进程得不到调度，将会导致一系列其他问题
* 用 `top` 命令更改已存在进程的nice：`top->r->输入PID->输入nice值`

## *环境变量使用*

### 环境变量的获取方式

Remainder：环境变量是通过进程的环境表 Environment List组织的。environ 指向一个以 NULL 结尾的指针列表，每个指针又指向一个以空字节终止的字符串

<img src="环境列表.drawio.png" width="40%">

* 通过代码

  * main函数有三个参数 `int main(int argc, char* argc[], char* env[]);`
    * `argv` 是命令行参数指针数组， `argc` 是有几个命令行参数
    * 第三个参数char指针数组就是用来接收父进程继承的环境表的
  * 利用第三方变量 `extern char** environ;`
* 通过系统调用或设置环境变量

### main的参数argc和argv

## *进程资源*

# 进程控制

进程控制的核心在于4个系统调用：fork、exit、wait、execve。可以用下面这张图来总结（也是shell执行一条命令所历经的步骤）。具体的可以看各节

<img src="进程控制核心系统调用.png">

## *创建进程*

### fork

```c
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
			// In parent: returns process ID of child on success, or -l on error；
			// in successfully created child: always returns 0
```

Fork 可以从父进程创建出一个新的进程（子进程)）。具体做法是：新的子进程几近于对父进程的翻版，子进程获得父进程的栈、数据段、堆和执行文本段的拷贝

* **共享代码段**：子进程通常与父进程共享代码段，这意味着它们执行相同的程序。这样可以节省内存，并且对于许多用途非常有用

* **独立数据段 & 写时拷贝**

  * 尽管子进程共享代码段，但它们有独立的数据段和堆栈，因此它们可以在没有互相干扰的情况下操作自己的数据

  * 不过要注意的时，为了减少内存占用，一开始父子进程仍然是共享数据段的，只有当需要修改数据段时，才会发生数据段的写时拷贝，写时拷贝的本质是一种延时申请

    <img src="COW.png">

  * 文件共享：子进程会获得父进程所有文件描述符的副本（fd均指向相同的打开文件句柄），从而实现了文件共享。这些副本的创建方式类似于dup。需要使用wait在进程之间同步，从而确保输出不会随意混杂在一起

Fork 调用失败的原因

* 系统中有太多的进程
* 实际用户 real UID 的进程数超过了限制 RLIMIT_NPROC

### vfork

```c
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);
			// In parent: returns process ID of child on success, or -l on error；
			// in successfully created child: always returns 0
```

在早期的 BSD 实现中，fork 会对父进程的数据段、堆和栈施行严格的复制。为了规避这种高消耗引入了 vfork。vfork的特点是

* 无需为子进程复制虚拟内存页或页表。相反子进程共享父进程的内存，直至其成功执行了 exec 或是调用 \_exit 退出 
* 在子进程调用 exe 或 \_exit 之前，将暂停执行父进程

因为现代UNIX系统中在执行fork的时候都会采用写时拷贝，所以vfork失去了用武之地也很少被使用了。此外 vfork 的怪异语义可能会导致一些难以察觉的bug，所以尽量不要使用vfork

### fork之后的竞态条件

调用 fork()之后,系统将率先“垂青”于哪个进程(即调度其使用 CPU) ,是无法确定的

## *进程终止*

### 进程退出时，OS做了什么？

释放进程申请的相关内核数据结构和对应的数据和代码。本质就是释放系统资源

* 查找需要终止的进程的 PCB
* 如果处于执行状态，则立即终止该进程的执行，然后将 CPU 资源分配给其他进程
* 如果其还有子进程，则应将该进程的子进程交给 1 号进程接管
* 将该进程所拥有的全部资源都归还给操作系统
* 将其从 PCB 所在队列中删除

### 进程退出场景

* C语言main函数为什么总是return 0？

  * main函数的return值被称为返回码/退出码，返回码被返回给上一级进程，用来评判该进程执行结果

  * return 0意味着代码运行完毕，结果正确；非0则代码运行完完毕，结果不正确

  * 不同的非0值可以标识不同的错误原因。方便定位错误的原因细节

  * 通过 `$ errno -ls` 查看部分错误码

    ```
    EPERM 1 Operation not permitted
    ENOENT 2 No such file or directory
    ESRCH 3 No such process
    EINTR 4 Interrupted system call
    EIO 5 Input/output error
    ENXIO 6 No such device or address
    E2BIG 7 Argument list too long
    ENOEXEC 8 Exec format error
    EBADF 9 Bad file descriptor
    ECHILD 10 No child processes
    EAGAIN 11 Resource temporarily unavailable
    ENOMEM 12 Cannot allocate memory
    EACCES 13 Permission denied
    EFAULT 14 Bad address
    ENOTBLK 15 Block device required
    EBUSY 16 Device or resource busy
    EEXIST 17 File exists
    EXDEV 18 Invalid cross-device link
    ENODEV 19 No such device
    ENOTDIR 20 Not a directory
    ```

* 代码运行完毕，结果正确

* 代码运行完完毕，结果不正确

* 代码异常终止：此时退出码没有意义，一般而言不会执行到return，也就没有退出码

### 常见进程退出方法

<img src="进程终止.drawio.png" width="40%">

* `_exit` 系统调用函数

  ```c
  #include <unistd.h>
  void _exit(int status);
  ```

* `exit` C语言库函数

  ```c
  #include <stdlib.h>
  void exit(int status);
  ```

  库函数 exit 终止一进程，将进程占用的所有资源（内存、文件描述符等）归还内核，交其进行再次分配。参数 status 为一整型变量,表示进程的退出状态。父进程可使用系统调用 wait 来获取该状态

  * exit会执行如下动作
    * 调用退出处理程序（通过 `atexit()` 和 `on_exit()` 注册的函数），其执行顺序与注册顺序相反
    * 刷新 stdio 流缓冲区
    * 使用由 status 提供的值执行 `_exit()` 系统调用
  * 在代码的任何地方调用，都表示直接终止进程。推荐使用 `exit`
  * 通过试验发现，当使用 `exit` 时，会刷新缓冲区内的数据到输出设备上，而 `_exit` 则不会。因此可以从侧面证明，缓冲区是C标准库维护的，这点将会在IO中具体说明

* Remainder：return退出语句，return语句只有在main函数中才是终止进程

### 自定义退出处理程序

glibc 提供两种方式来注册退出处理程序

```c
#include <stdlib.h>
int atexit(void (*function)(void));
```

atexit 将 func 函数指针加到一个函数列表中，当进程终止时会调用该函数列表的所有函数。应将函数 func 定义为不接受任何参数，也无返回值的函数

```c
#include <stdlib.h>
int on_exit(void (*function)(int , void *), void *arg);
```

on_exit接受的函数指针是可以接受参数的

注意：当进程收到信号而终止时,将不会调用退出处理程序，此时最佳的应对方式可能是为可能发送给进程的信号建立信号处理程序

## *Wait*

### 进程等待必要性

* 若子进程退出后无人回收会造成僵尸进程的问题，从而导致内存泄漏。僵尸进程无法被杀死
* 父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息
* 为什么要用wait/waitpid系统函数？因为数据产生写时拷贝，进程具有独立性，因此父进程无法拿到
* wait/waitpid作为系统调用函数，拥有权限读取僵尸进程（如果有的话）残存的PCB信息里保存的退出结果信息

### wait & waitpid

编写多进程的基本写法就是fork+wait/waitpid

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *status);
			// Returns process ID of terminated child, or -1 on error
```

status 是一个输出型参数，用来存储子进程的退出信息。若不关心可以设置成为NULL

<img src="wait.png" width="70%">

试验过程：让子进程运行3秒后终止，但让父进程在5秒后才wait并回收。可以看到，子进程在一开始为运行间隔的S态，终止后由于暂时无人回收而变成Z状态，在父进程wait后被回收

### waitpid

wait存在以下几个问题

* 若父进程已经创建了多个子进程，则使用 wait 将无法等待某个特定子进程的完成，只能是按顺序等待下一个子进程的终止
* 若没有子进程退出，wait 会一直阻塞。有时候会希望执行非阻塞的等待，当有是子进程退出的时候会收到通知
* 使用 wait 只能发现那些已经终止的子进程。对于子进程因某个信号，比如 SIGSTOP 或 SIG TTIN 而停止的，或者是已停止子进程收到 SIGCONT 信号后恢复执行的情况那就无能为力了

waitpid就是为了解决这些问题而设计的

```c
#include <sys/types.h>
#include <sys/wait.h>
pid_t waitpid(pid_t pid, int *status, int options);
			// Returns process ID of child, 0 （see text）， or -1 on error
```

* 参数
  * pid
    * `pid==-1`：等待任一个子进程，`waitpid(-1, &status, 0)` 与 `wait(&status)` 等效
    * `pid>0`：等待其进程ID与pid相等的子进程，也就是等待指定进程
    * `pid==0`：等待与调用进程（父进程）同一个进程组的所有子进程
    * `pid<-1`：等待 PGID 与 pid 绝对值相等的所有子进程
  * status 和 wait 的输出型参数一样，用户可以利用 `status` 选择输出宏 `WIFEXITED(status)` 或者 `WEXITSTATUS(status)`。实现见下方
  * options
    * 默认为0，表示设置父进程为阻塞状态：若子进程还没有返回，则挂起父进程，等子进程返回后从waitpid继续执行，此时父进程什么都干不了
    * WNOHANG 宏，表示设置父进程为非阻塞等待 `#define WNOHANG 1`：若没有子进程返回，waitpid直接返回0，会**不断进行查询访问，直到操作成功**
    * WUNTRACED：除了返回终止子进程的信息外，还返回因信号而停止的子进程信息
    * WCONTINUED：返回那些因收到 SIGCONT 信号而恢复执行的已停止子进程的状态信息
* 返回值
  * 当正常返回的时候waitpid返回收集到的子进程的PID
  * 若设置了选项 `WNOHANG`，而调用中waitpid发现没有已退出的子进程可收集，则返回0
  * 若调用中出错，则返回-1，此时errno会被设置成响应的值以指示错误所在

### 获取子进程status：status是子进程PCB维护的一个数据

<img src="status的不同情况.png" width="70%">

* status数据不能简单的看作一个整形，而是要看作一个32位的位图，**其中高16位我们不关心**

  * 输出 `WIFEXITED(status)` 宏：**`#define WIFEXITED(status) (status>>8)&0xff`**
  * 输出 `WEXITSTATUS(status)` 宏：**`#define WEXITSTATUS(status) status&0x7f`**
  * `WIFSIGNALED (status)` 

* 正常终止：使用高8位作为退出状态码

  * 试验：将退出状态码设为105，即 `exit(105)` 后正常终止

    <img src="正常终止status返回.png">

* 异常状态下被信号杀死，若core dump被设置，那么肯定是异常终止

  * 进程异常退出，或者崩溃，本质OS是在给进程写入信号，然后进程收到信号被终止，此时还会设置core dump位

  * 试验：人为设置一个除0操作，返回的终止信号位8，对应信号SIGFPE：浮点数错误

    <img src="异常终止status返回.png">

### 具体代码实现

* 进程的阻塞等待方式（上面的试验出自该例）

```c
#include <stdio.h>    
#include <unistd.h>    
#include <stdlib.h>    
#include <sys/types.h>    
#include <sys/wait.h>    
    
int main() {    
    pid_t id = fork();    
    if (id<0) {
        perror("fork failed\n");    
        exit(1);    
    }    
    else if (id==0) {
        int cnt = 3;    
        while (cnt) {
            printf("cnt: %d. I am child preocess. PID: %d, PPID: %d\n", cnt, getpid(), getppid());
            sleep(1);    
            //cnt--;    
            //int a = 10;    
            //a /= 0;    
        }                                                                                             
        exit(105); // 直接终止子进程，仅用作测试    
    }    
    else {
        printf("I am father preocess. PID: %d, PPID: %d\n", getpid(), getppid());
        //sleep(5);
        //pid_t ret = wait(NULL); // 阻塞式等待
        int status = 0;
        // 只有子进程退出的时候，父进程才会waitpid函数进行返回，此时父进程还存在
        // waitpid/wait 可以在目前的情况下，让进程退出具有一定的顺序性
        // 将来可以让父进程进行更多的收尾工作                                                             
        pid_t ret = waitpid(id, &status, 0); // 阻塞式等待
        if (ret>0) {
            // 可以不这么二进制处理
            // printf("等待子进程成功。ret：%d，status: %d，子进程收到的低7位信号：%d，子进程退出码: %d\n", ret, status, status&0x7f, (status>>8)&0xff);
            if (WIFEXITED(status))
                // 子进程是正常退出的
                printf("子进程执行完毕，子进程的退出码为：%d\n",WEXITSTATUS(status));
            else
                printf("子进程异常退出：%d\n", WIFEXITED(status));
        }
       // while (1) {
       //     printf("I am father preocess. PID: %d, PPID: %d\n", getpid(), getppid());
       //     sleep(1);
       // }
    }
    return 0;
}
```

* 进程的非阻塞等待方式

### waitid

waitid系统调用提供了waitpid的进一步扩展。该系统调用源于 System V

```c
#include <sys/types.h>
#include <sys/wait.h>
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
			// Returns O on success or if WNOHANG was specified and
			// there were no children to wait for, or -l on crror
```

对于应该等待的子进程事件，waitid 可以更为精确地控制

参数 idtype 和 id 指定需要等待哪些子进程

* idtype 为 P_ALL：等待任何子进程，同时忽略 id 值
* idtype 为 P_PID：等待进程 ID 为 id 进程的子进程
* idtype 为 P_PGID：等待进程组 ID 为 id 各进程的所有子进程

关于oftions和siginfo_t结构体的定义看书

### wait3 & wait4

通过wait3和wait4可以知道等待的子进程的更多资源信息

```c
#include <sys/types.h>
#include <sys/time.h>
#include <sys/resource.h>
#include <sys/wait.h>
pid_t wait3(int *wstatus, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);
			// Both return process ID of child, or -1 on crror
```

wait3 和 wait4 通过参数 rusage 所指向的结构中返回终止子进程的资源使用情况。 其中包括进程使用的 CPU 时间总量以及内存管理的统计数据

wait3 等待的是任意子进程，而 wait4 则可以用于等待选定的一个或多个子进程

### 子进程 `SIGCHLD` 信号捕捉

进程的阻塞和非阻塞等待效率其实都挺低的，实际进程退出是利用信号机制的，即子进程退出后会给父进程发 `SIGCHLD` 信号，父进程在陷入内核后对该信号进行处理，自定义 `SIGCHLD` 的处理动作，即调用 `wait` 清理子进程资源并回收其结果

``` c
void FreeChild(int signo) {
    assert(signo == SIGCHLD);
    pid_t id = waitpid(-1, nullptr, 0);
    if (id > 0) {
        cout << "父进程等待成功，chld pid: " << id << endl;
    }
    cout << "子进程退出，PID: " << signo << getpid() << endl;
}

int main() {
    signal(SIGCHLD, FreeChild);
    pid_t id = fork();
    if (id == 0) {
        int cnt = 10;
        while (cnt--) {
            cout << "子进程，PID：" << getpid() << "，PPID："<< getppid() << 
            "cnt: "<< cnt << endl;
            sleep(1);
        }
        exit(0);
    }
    
    //父进程
    while (true) {
        cout << "父进程，PID：" << getpid() << endl;
        sleep(1);
    }
    return 0;
}
```

上面的代码还需要改进，因为一个父进程可能会有很多很多个子进程。在父进程收到一个子进程的 `SIGCHLD` 并陷入内核处理时，OS会把该信号设置为阻塞，此时若还有其他子进程也在退出，就很有可能会丢失相关信号，从而产生僵尸进程

将 `waitpid` 放到循环里，以避免可能错过的退出码，但是一定要注意用非阻塞等待 `WNOHANG`，否则父进程可能会被卡死在这里

```c
void FreeChild(int signo) {
    assert(signo == SIGCHLD);
        while (true) {
        pid_t id = waitpid(-1, nullptr, WNOHANG); //非阻塞等待，否则父进程可能会卡死在这里
        if (id > 0) {
            cout << "父进程等待成功，chld pid: " << id << endl;
        }
        else if (id == 0) { //还有子进程，但是现在没有退出
            cout << "还有子进程，但是没有退出，父进程要去忙自己的事情" << endl;
            break;
        }
        else {
            cout << "父进程等待子进程结束" << endl;
            break;
        }
    }
}
```

事实上,由于UNIX 的历史原因,要想不产生僵尸进程还有另外一种办法：父进程用 `sigaction` 或 `signal` 函数将SIGCHLD的处理动作置为 `SIG_IGN`，这样fork出来的子进程在终止时会自动清理掉,不会产生僵尸进程，也不会通知父进程。系统默认的忽略动作和用户用 `sigaction` 或 `signal`函数自定义的忽略通常是没有区别的，但系统还是会将自定义动作仍然识别会自定义动作。此方法对于Linux可用,但不保证在其它UNIX系统上都可用

## *程序的执行*

### 替换原理：重新建立映射关系

* 进程替换是让进程（通常是子进程）执行一个全新的程序（类似加载）的过程
* 进程替换的两种方式
  * fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支）
  * 子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替代，从新程序的启动历程开始执行。调用exec并不是创建新进程，所以调用exec前后该进程的PID并不改变

<img src="进程替换原理.png" width="80%">

### 六种exec替换函数

```c
#include <unistd.h>
int execve(const char *pathname, char *const argv[], char *const envp[]);
			// Never returns on success; returns -1 on error
```

`execve(pathname, argv, envp)` 加载一个新程序到当前进程的内存

* 参数
  * pathname 包含准备载入当前进程空间的新程序的路径名，既可以是绝对路径，也可以是相对于调用进程当前工作目录 cwd 的相对路径
  * argv 则指定了传递给新进程的命令行参数。该数组对应于 C 语言 main 函数的第 2 个参数 `char **argv` ,且格式也与之相同:是由字符串指针所组成的列表
  * envp 指定了新程序的环境列表。参数 envp 对应于新程序的 environ 数组
* 返回值：由于是将调用程序取而代之, 对 execve 的成功调用将永不返回，而且也无需检查 execve 的返回值，因为该值总是等于-1

这将丢弃现存的程序文本段，并为新程序重新创建栈、数据段以及堆。通常将这一动作称为执行一个新程序。稍后会介绍构建于 `execve()` 之上的多个C库函数，每种都为编程接口提供了实用的变体。在彼此差异无关紧要的场合，按照惯例会将此类函数统称为 `exec()`,尽管实际上并没有以之命名的系统调用或者库函数

* **`int execve(const char* file, char* const argv[], char* const envp[])`**：这个接口是最特殊的，因为它是直接由OS提供的基本系统调用。之前函数的是经过C库封装的，适合在不同的调用场景下使用的
* `int execl(const char* path, const char* arg, ...);` l(list)：表示参数采用列表。可变参数列表的最后一个参数必须是NULL，用来表示参数传递完毕
* `int execlp(const char* file, const char* arg, ...);` p(path)：有p自动搜索环境变量PATH，可以只提供文件名
* `int execvp(const char* file, char* const argv[]);`
* `int execle(const char* path, const char* arg, ...,char* const envp[]);` e(env)：表示自己维护环境变量
* `int execv(const char* path, char* const argv[]);` v(vector)：参数用指针数组

### 函数解释

* `exec*` 函数本质就是如何加载从硬盘加载到内存的加载函数，其功能就是加载器
* 函数调用成功则加载新的程序，原程序剩余的代码不再执行。从下图试验可以发现，程序只打印了第一次printf和ls -al命令，之后的命令没有被执行
* exec函数只有出错返回-1，成功不会返回
* 当子进程加载新程序的时候，相当于是写入了新代码。此时要分离父子进程的代码，代码和数据都要写时拷贝
* 特殊情况：环境变量不会被替换

<img src="exec示例.png">

### 解释器

所谓解释器 interpreter 就是能够读取并执行文本格式命令的程序。比如各种UNIX shell，以及awk、perl、python和ruby之类的程序都是解释器，它们都可以从脚本 script 文本文件中读取和执行命令

在 *shell脚本和正则..md* 中提供了一个简单shell的实现，里面的过程如下

<img src="解释器的实现.png" width="50%">

同理也可以执行其他的C、C++二进制程序或其他语言的程序

* 无论是任何语言，都是运行在OS上面的，都需要调用类似exec\*的系统接口。因此本质而言Shell就是一个解析用户输入命令并调用exec\*函数的C文件解释器
* C语言、Python和Shell语言都像是软件，编译型的第一次编译之后生成二进制可执行文件，之后再使用都可以直接运行可执行文件，速度非常快。而解释型语言需要每次都将代码文件输入给python或shell解释器逐行解析，因此速度很慢

### system

```c
#include <stdlib.h>
int system(const char *command);
```

`system` 函数允许在一个新的进程中运行命令

参数是一个字符串，表示要执行的命令。它会调用底层的 shell 解释器来执行这个命令，然后等待命令执行完毕。`system` 函数的返回值表示命令的执行结果，通常是命令的退出状态码

```c
#include <stdlib.h>

int main() {
    int result = system("ls -l");
    if (result == -1) {
        // 处理错误
    }
    return 0;
}
```

## *进程组和作业*

进程组和会话是为支持 shell 作业控制而定义的抽象概念

作业 job 和进程组 process group 基本上是同义词

进程组由一个或多个共享同一进程组标识符 PGID 的进程组成

```c
#include <sys/types.h>
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
			// Always successfully returns process group ID of calling process
pid_t getpgid(pid_t pid);
			// Returns O on success, or -1 on error
```

### 进程组与job控制

执行一个程序可能会创建一个或多个进程，这些进程被称为一个进程组 Process group，进程组也叫job。将多个进程划分为一个进程组是为了方便进行统一的管理，说白了就是可以给组内的所有进程同时发信号，这个过程就是job管理/job调度。比如BEAST lab中使用的SLURM 任务调度工具

每个进程组都有一个process group leader，leader的PID就是整个进程组的Process Group ID PGID。Process group leader可以自己退出，不会影响同属于该group的其他进程，其他进程的PGID仍然为原来的PGID，等到进程组中的所有进程都退出后，进程组的周期才结束

job管理

* `jobs` 命令可以查看当前OS中的job
* `&` 符可以让进程在后台运行
* `fg %n` 指定jobID为n的job到前台工作（foreground）
* crtl+z 挂起job，让它的状态变成S
* `bg %n` 指定jobID为n的job到后台工作（background），这个命令可以在job挂起来再使用，而 `&` 必须时在shell中输入命令时就带上

### 会话 Session

守护进程的父进程是系统

同一时刻有且只能有一个前台进程组

自成新进程和新会话的进程称为守护进程

### 前台进程与后台进程

* 当进程状态有一个 `+` 时，表示该任务为前台进程 Foreground process。前台进程意味着会占据Shell界面，其运行时Shell无法进行其他操作
* 若要设置为后台进程 Background process，可以在运行文件时带上 `&`，如 `./myproc &`。这样Shell就不必等待进程结束就可以接收新的命令，启动新的进程
* Shell可以同时运行一个前台进程和任意多个后台进程，只有前台进程才能接收到按键信号
* 前台进程在运行过程中用户随时可以发送如ctrl+c这样的信号，也就是说该进程的用户空间代码执行到任何地方都有可能收到SIGINT信号而终止，所以信号相对于进程的控制流程来说是异步的 asynchronous

## *守护进程 Daemon*

### 形成守护进程的方式

* 自己写（强烈推荐）
* `nohup process &` 默认形成日志 `nohup.out`

### 守护进程编写

守护进程编写就是对服务器的部署，让它的父进程从bash变成1号 kernel_init 进程，这样在bash被关闭后server也能继续运行。守护进程的名字一般以d结尾，比如ssd

必做：必须调用函数 `setsid()` 将调用进程设置称为新的session，但进程组的组长不能调用 `setsid()`，一旦调用会立刻报错，所以一般做法就是fork当前进程，然后让fork出的子进程取调用 `setsid()`

选做

* 和管道控制一样，当server一直在写，而client关闭了，那么server也会收到client发来的SIGPIPE终止信号。若不想要进程退出，就要忽略SIGPIPE信号
* 守护进程一般会放到另一个工作目录下，因此可以通过 `chdir()` 来更改存放地址

选做 || 必做

* 将stdout、stdin、stderr关闭，但为了程序的兼容性问题，很少会有人这么做
* 将stdout、stdin、stderr重定向至Linux的垃圾桶/信息黑洞 /dev/null

## *进程资源*

## *能力*

能力 capabilities

把授予给超级用户的特权划分为若干不同单元，且能独立启用和禁用这些单元

# Pthread

## *clone*

clone是Linux特别提供的系统调用，是Pthread的基础

### clone系统调用

clone 的功能类似于 fork，但相比于 fork 更为灵活，因为它允许创建一个与父进程共享某些资源的子进程

```c
#define _GNU_SOURCE
#include <sched.h>
int clone(int (*fn)(void *), void *stack, int flags, void *arg, ...
         /* pid_t *parent_tid, void *tls, pid_t *child_tid */ );
```

* fn：一个函数指针，指向新进程将要执行的函数。这个函数接受一个参数，类型为 `void *`，并返回一个整数
* child_stack：新进程的栈顶指针，指向分配给新进程的栈的末尾地址
* flags：标志位，用于指定创建新进程的方式。下面只介绍与用于创建线程有关的flags，其他具体的flags可以看书
* arg：传递给新进程的参数，会传递给 fn 函数

除了上述参数之外，clone 还可以接受可选的变长参数，用于传递其他信息

fork、vfork 以及 clone 最终均由同一函数实现，即 kernel/fork.c 中的 `do_fork()`。另外 clone 是由 glibc 对 `sys_clone()` 的封装。对该函数的定义位于 glibc 针对特定架构的汇编源码中，例如 sysdeps/unix/sysv/linux/i386/clone.S 

### clone用于创建线程

Linux中没有真正的线程，或者说线程都是轻量化进程 LWP。不论是进程还是线程都是统一的 **内核调度实体 KSE, kernel scheduling entity**，它们在Linux中的实现上只不过是一些资源的共享程度不同而已

clone 的 flags 是各种位掩码的组合，即 “或”操作

线程组就是共享同一线程组标识 TGID, Thread Group IDentifier 的一组 KSE

Linux中对于Posix 标准线程的两种实现分别是LinuxThreads和NPTL，它们都适用clone来创建线程，但是用到的flags参数不同

* LinuxThreads

  ```c
  flags = CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND
  ```

  * CLONE_VM：共享虚拟内存空间，父子进程共享相同的虚拟内存，对内存的修改在两个进程中都可见
  * CLONE_FILES：共享文件描述符表，父子进程共享相同的文件描述符表，打开或关闭文件描述符会影响到两个进程
  * CLONE_FS：父子进程共享与文件系统相关的信息 file system related information：权限掩码 umask、根目录以及当前工作目录
  * CLONE_SIGHAND：父子进程将共享同一个信号处置表。无论在哪个进程中调用 sigaction 或 signal 来改变对信号处置的设置，都会影响其他进程对信号的处置

* NPTL

  ```c
  CLONE_VM | CLONE_FILES | CLONE_FS | CLONE_SIGHAND | CLONE_THREAD |
  CLONE_SETTLS | CLONE_PARENT_SETTID | CLONE_CHILD_CLEARTID | CLONE_SYSVSEM
  ```

  * CLONE_THREAD：若设置了该标志，则会将子进程置于父进程的线程组中，否则会将子进程置于新的线程组中
  * CLONE_SETTLS：设置子进程的 TLS（Thread Local Storage）指针。子进程中的 TLS 指针会被设置为 `arg` 参数指定的值
  * CLONE_PARENT_SETTID：设置父进程中的 TID（Thread ID）父进程中的 TID 会被设置为 arg 参数指定的值
  * CLONE_CHILD_CLEARTID：在子进程中清除 TID。子进程中的 TID 会被设置为 0
  * CLONE_SYSVSEM：共享 System V 信号量集。父子进程共享相同的 System V 信号量集，允许它们进行进程间同步

另外fork相当于仅设置了SIGCHLD的clone调用，而vfork则相当于设置了 `CLONE_VM | CLONE_VFORK| SIGCHLD` 的系统调用

## *线程操作*

### 线程创建

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                  void *(*start_routine) (void *), void *arg);
			// Returns O on success, or a positive error number on error
```

* `thread`：用于存储新线程的标识符的指针
* `attr`：用于设置线程属性的指针。可以为 `NULL`，表示使用默认属性。pthread_attr_t 数据结构中保存了很多线程相关的属性，比如说线程栈的位置和大小、 线程调度策略、优先级、线程是否处于可join或detach等等
* `start_routine`：是一个指向线程函数的指针，新线程将从这个函数开始执行。新线程通过调用带有参数 arg 的函数 start_routine，即 `start_routine(arg)` 而开始执行。`pthread_create()` 的线程会继续执行该调用之后的语句
* `arg`：是传递给线程函数 `start_routine` 的参数

和fork一样，pthread_create之后是无法确定系统接着会调度哪一个线程来使用 CPU 资源，在多CPU的情况下，甚至无法知道哪一个CPU的哪一个核在运行哪一个线程。因此会产生race condition，如果有执行顺序的需求，需要对其进行同步

### 终止线程

终止线程的方式有如下4种

1. 线程 start 函数执行 return 语句并返回指定值
2. 线程调用 pthread_exit
3. 调用 pthread_cancel 取消线程
4. **任意线程调用了 exit**，或者主线程的main函数执行了 return，都会导致进程中的所有线程立即终止

```c
#include <pthread.h>
void pthread_exit(void *retval);
```

retval 指定了线程的返回值。retval 所指向的内容不应分配于线程栈中，因为线程终止后，将无法确定线程栈的内容是否有效

pthread_exit 终止调用线程后，retval 可由另一线程通过调用 pthread_join 来获取

### 线程id

进程内部的每个线程都有一个唯一标识，称为 thread id 线程id。thread id 会在调用 pthread_create 的时候输出到其参数 `pthread_t *thread` 中

一个线程也可以通过 `thread_self()` 来获取自己的thread id

```c
#include <pthread.h>
pthread_t pthread_self(void);
			// Returns the thread ID of the calling thread
```

**注意区分 thread id和tid**

* thread id 指的是 **pthread 库**定义的 `pthread_t` 这种数据结构，它可以用来创建、操作和标识线程
* `pid_t tid` 则是在一些**系统调用接口**中用于表示线程标识符的整形

```c
#include <pthread.h>
int pthread_equal(pthread_t t1, pthread_t t2);
			// Returns nonzero value if tl and t2 are equal, otherwise 0
```

pthread_equal 可以用来检查两个 thread id 是否相同

### join 连接

<img src="fork-join model.drawio.png" width="70%">

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
			// Returns 0 on success, or a positive error number on error
```

* thread：要等待的线程的标识符
* retval：指向指针的指针，用于存储线程的返回值
  * 如果不关心返回值，可以将其设为 `NULL`
  * 若 retval 为一非空指针，将会保存线程终止时返回值的拷贝

注意：若向 pthread_join 传入一个之前已经 join 过的thred id，将会导致无法预知的行为。并且若线程没有detach，就必须要join，否则会产生类似于僵尸进程的僵尸线程 zombie thread

pthread_create - pthread_join 的功能就和进程的 fork-wait 是一样的，用来回收某个线程的返回值。但是也存在差异

* 线程之间的关系是对等的 peers，进程中的**任意线程**均可以调用 pthread_join 来join该进程的任何其他线程，并不是和线程一样一定要由父进程来wait
* 无法做到join任何其他线程，即类似于 `waitpid(-1, &status, options)`。这样设计的目的是为了让程序应只能连接它所“知道的”线程，比如说一个进程中必然包含很多由C运行时库产生的线程，如果直接join所有线程，那么C运行时库产生的线程无法被本来设计好的线程来join，从而形成僵尸线程
* 不能以非阻塞 nonblocking 方式进行join，使用条件变量可以实现类似的功能

### 线程分离

有时候程序员并不关心线程的返回状态，只是希望系统在线程终止时能够自动清理并移除它，这种情况下应该使用 pthread_detach

```c
#include <pthread.h>
int pthread_detach(pthread_t thread);
			// Returns O on success, or a positive error number on error
```

注意：detach不是一个可逆的过程，一旦线程处于detach状态，就不能再使用 pthread_join 来获取其状态，也无法使其重新回到可以进行join的状态

## *线程取消*

线程取消指的是向线程发送一个请求，要求其立即退出

```c
#include <pthread.h>
int pthread_cancel(pthread_t thread);
			// Returns O on success, or a positive error number on error
```

发出取消请求后，pthread_cancel 会立即返回，不会等待目标线程的退出

### 取消状态及类型

pthread_setcancelstate 和 pthread_setcanceltype 会设定cancel的一些标志，以允许线程对取消请求的响应过程加以控制

```c
#include <pthread.h>
int pthread_setcancelstate(int state, int *oldstate);
int pthread_setcanceltype(int type, int *oldtype);
			// Both return O on success, or a positive error number on error
```

* pthread_setcancelstate 用于设置线程的取消状态，即决定线程是否可以响应取消请求
  * PTHREAD_CANCEL_ENABLE：允许线程响应取消请求
  * PTHREAD_CANCEL_DISABLE：禁止线程响应取消请求
* pthread_setcanceltype 用于设置线程的取消类型，即确定线程是否响应取消请求以及何时响应取消请求
  * PTHREAD_CANCEL_DEFERRED：延迟取消，线程将取消请求挂起，直到到达取消点时才执行取消操作
  * PTHREAD_CANCEL_ASYNCHRONOUS：异步取消，可能会在任何时点（也许是立即取消，但不一定）取消线程

oldstate、oldtype 是可选的指针，用于存储之前的取消状态、类型。若设置为 `NULL`，表示不关心之前的状态

### 取消点

若将线程的取消性的state和type分别置为PTHREAD_CANCEL_ENABLE和PTHREAD_CANCEL_DEFERRED，则仅当线程抵达某个取消点 cancellation point 时取消请求才会起作用。取消点即是对由实现定义的一组函数之一加以调用

### 清理函数

```c
#include <pthread.h>
void pthread_cleanup_push(void (*routine)(void *), void *arg);
void pthread_cleanup_pop(int execute);
```

pthread_cleanup_push 和 pthread_cleanup_pop 分别负责向调用线程的清理函数栈添加和移除清理函数

# 线程同步

## *互斥量*

### 静态分配互斥量

```c
#include <pthread.h>
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //静态分配，不需要destroy
```

互斥量是属于 pthread_mutex_t 类型的变量。在使用之前必须对其初始化。有两种初始化方式，静态分配和动态分配

静态分配只能用于对经由静态分配且携带默认属性的互斥量进行初始化

### 加锁、解锁

```c
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex); //阻塞式上锁
int pthread_mutex_trylock(pthread_mutex_t *mutex); //非阻塞式上锁
int pthread_mutex_unlock(pthread_mutex_t *mutex); //解锁
			// Both return O on success, or a positive error number on error
```

只能对临界区加锁，而且加锁的粒度越细越好。本来线程是并发的，**加锁的本质是让线程临界区代码串行化，串行的代码越少，并发性越强，效率越高**

加锁是一套规范，只要线程通过临界区对临界资源进行访问的时候，就都要加锁，不能一部分加一部分不加

```cpp
int tickets = 10000; //临界资源，可能会造成数据不一致问题
pthread_mutex_t mutex; //全局锁

void *getTickets(void *args) {
    //访问临界资源的代码称为临界区
    pthread_mutex_lock(&mutex); //给临界区加锁
    const char* name = static_cast<const char*>(args);
    while (true) {
        if (tickets > 0) {
            cout << "thread[" << name << "] 抢到了票，票的编号" << tickets << endl;
            tickets--;
            pthread_mutex_unlock(&mutex); //解锁
            //当前线程重新申请锁的成本远低于唤醒其他线程，因此一直在跑这个线程
            //若想要其他线程也来申请，可以在临界区后面用usleep模拟唤醒其他线程
            usleep(123); //休眠微秒
        }
        else {
            cout << "thread[" << name << "] 已经放弃抢票了，因为没票了" << endl;
            pthread_mutex_unlock(&mutex); //解锁
            break;
        }
        //也不能在这里解锁，会造成死锁
        //pthread_mutex_unlock(&mutex); //解锁
    }
    //不能在while循环外面解锁，粒度太高，没人抢得到第一个线程
    //pthread_mutex_unlock(&mutex); //解锁
    return nullptr;
}

int main() {
    pthread_mutex_init(&mutex, nullptr); //初始化锁
    pthread_t tid1;
    pthread_t tid2;
    pthread_create(&tid1, nullptr, getTickets, (void*)"thread1");
    pthread_create(&tid2, nullptr, getTickets, (void*)"thread2");
    pthread_detach(tid1); //让主线程来分离
    pthread_detach(tid2);
    
    pthread_mutex_destroy(&mutex); //释放锁
    return 0;
}
```

在加锁的临界区里面，就没有线程切换了吗？可以有，但新的线程必须进行阻塞申请锁。上锁的临界区代码在运行过程中，被CPU切走，此时绝对不会有其他线程进入临界区，因为这把锁被切走的代码申请走了，此时其他线程必须阻塞等待锁资源，因此尽量不要在临界区里执行特别复杂的程序，否则会效率很低

### 锁原子性的实现

锁保护的是临界区，任何线程执行临界区代码访问临界资源的都必须先申请锁，前提是都必须先看到锁。那么这把锁本身就是临界资源。这个问题在设计锁的时候就解决了，`pthread_mutex_lock` 竞争和申请锁的过程本身就是原子的

那么要如何实现锁的原子性呢？从上面抢票的例子中可以看到 `++i` 或 `i++` 这种操作不是原子性的，因为它在编译过程中会被拆分成多个步骤，在每个步骤都有可能被CPU切走。因此我们只要保证在编译的时候是一条语句，即一个步骤，CPU不可能会拆分一个步骤，必须等它执行完再进行调度，这就保证了原子性

申请锁的原子性是通过将锁资源读入线程的寄存器只有一条汇编语句来实现的。将数据从内存读入寄存器，本质是将数据从共享（锁是全局资源）变成线程私有（寄存器上下文是被每个线程私有的）。也可以通过锁总线来实现

### 动态初始化互斥量

```c
#include <pthread.h>
int pthread_mutex_init(pthread_mutex_t *restrict mutex, 
                       const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
			// Both returns O on success, or a positive error number on error
```

* mutex：指向要初始化的互斥锁的指针
* attr：指向互斥锁属性的指针，可以为 `NULL`，表示使用默认属性。互斥锁属性包含有关互斥锁行为的信息

### 互斥量类型

attr的一个属性之一就是互斥量的类型

* PTHREAD_MUTEX_NORMAL：这是默认的互斥锁类型。它不提供死锁检测或错误检测功能。如果同一线程尝试两次锁定同一互斥锁，会导致死锁
* PTHREAD_MUTEX_ERRORCHECK：递归互斥锁允许同一线程多次锁定同一互斥锁，而不会导致死锁。线程必须在每次成功锁定后对互斥锁进行相应数量的解锁。这种类型的互斥锁提供了嵌套锁定的支持
* PTHREAD_MUTEX_RECURSIVE：错误检查互斥锁在同一线程中对同一互斥锁的多次锁定会导致错误返回，而不是死锁。这样可以在开发和调试阶段更容易地检测到互斥锁使用错误

## *条件变量*

### 条件变量API

通过条件变量（对应的共享资源的状态，需要程序员来判断资源是否满足自己操作的要求），可以使之前的系统自动唤醒线程进行调度或等待，以此来实现同步

条件变量的接口和锁的接口非常相似，因为它们都遵守POSIX统一设计标准

```c
//初始化和销毁条件变量
#include <pthread.h>
pthread_cond_t cond = PTHREAD_COND_INITIALIZER; //静态全局初始化

// 动态分配
int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); //局部
int pthread_cond_destroy(pthread_cond_t *cond);
```

条件变量的等待接口，注意：**条件变量必须要和mutex互斥锁一块使用**

```c
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
                           pthread_mutex_t *restrict mutex, //互斥锁必须要有有，即使没有用到
                           const struct timespec *restrict abstime); //等待时间
int pthread_cond_wait(pthread_cond_t *restrict cond,
                      pthread_mutex_t *restrict mutex);
```

唤醒进程

```c
#include <pthread.h>
int pthread_cond_broadcast(pthread_cond_t *cond); //唤醒在条件变量等待下的所有线程
int pthread_cond_signal(pthread_cond_t *cond); //唤醒在条件变量等待下的一个线程
```

### 条件变量demo

```cpp
void *waitCommand(void *args) {
    //pthread_detach(pthread_self());
    while (!quit) {
        //执行了下面的代码，就证明某一种条件不就绪，需要进行线程等待
        //三个线程，都会在条件变量下排队
        pthread_mutex_lock(&mutex);
        pthread_cond_wait(&cond, &mutex); //让对应的线程进行等待，等待被唤醒
        pthread_mutex_unlock(&mutex);
        cout << "thread id: " << pthread_self() << " run..." << endl;
        
    }
    cout << "thread id: " << pthread_self() << " end..." << endl;
    pthread_exit(nullptr);
    return nullptr;
}
```

具体代码可以看 ~/Linux/Linux7_thread/6_synchronization 的 mythread.cc

其中一个非常容易错的点是，当多个线程批量退出的时候，必须要在 `pthread_cond_wait` 之前和之后分别加锁和解锁，因为是多个线程broadcast同时被释放，但只有一个线程能竞争到锁，此时当这个线程退出时，它并没有释放锁，那么其他线程就必须要阻塞等待，也就无法退出了

## *线程安全*

# IPC

## *匿名管道*

### 管道原理

<img src="管道.drawio.png">

* 先看到同一份资源：父进程分别以读写方式打开同一个文件
  * `struct file` 是共享的，例子：printf都是向同一个显示器上打印！
  * 为什么父进程要以读写方式打开，而不是直接以写的方式打开？因为如果以只写方式打开，那么子进程继承的时候就会失去读功能

* `fork()` 创建子进程
* 管道系统设计来**专用于单向通信**的，所以双方进程各自关闭自己不需要的文件描述符。既可以选择父进程读子进程写，也可以选择父进程写子进程读，这是看个人需求的

注意：管道通信是一种**纯内存级别**的通信，不会将数据放到磁盘中

### 匿名管道demo

需要手动两次open文件才能得到文件描述符吗？不需要，使用 `int pipe(int pipefd[2]);` 系统级调用

* 输出型参数，通过调用它来得到被打开的文件fd
* 里面封装了两次open，一次以读打开管道文件，一次以写打开管道文件
* 匿名管道是特殊的文件，只存在于内存，不存于文件系统中（不过命名管道是一个实在的p文件）

```cpp
//头文件
#include <iostream>
#include <unistd.h>
#include <assert.h>
#include <cstdio>
#include <cstring>
#include <sys/types.h>
#include <sys/wait.h>
using namespace std;
```

代码主体：

```cpp
// 为什么不定义全局buffer来进行通信？因为有写时拷贝的存在，数据是父子进程各自私有的，无法更改通信
int main() {
    //1. 创建管道
    int pipefd[2] = {0}; // pipefd[0]：读端，pipefd[1]：写端
    int n = pipe(pipefd);
    assert(n != -1);
    (void)n; //在realease下assert无效，若此时n是-1，那么需要证明n被使用过，否则会有很多报警信息

#ifdef DEBUG //条件编译
    cout << "pipefd[0]: " << pipefd[0] << endl;
    cout << "pipefd[1]: " << pipefd[1] << endl;
#endif

    //2. 创建子进程
    pid_t id = fork();
    assert(id != -1);
    if (id==0) {
        //子进程
        //3. 构建单向通信的信道，父进程写入，子进程读取
        //3.1 关闭子进程不需要的写端fd，避免造成混乱
        close(pipefd[1]);
        char buffer[1024];
        while (true) {
            ssize_t s = read(pipefd[0], buffer, sizeof(buffer)-1);
            if (s > 0) {
                buffer[s] = '\0'; //约定读的是C字符串，因为read是系统调用不会自动添加\0，所以手动添加
                cout << "child get a message[" << getpid() << "] Father#" << buffer << endl;
            }
        }
        close(pipefd[0]); //可写可不写，退出了之后自动关闭
        exit(0);
    }
    //父进程
    //3. 构建单向通信的信道
    //3.1 关闭父进程不需要的读端fd
    close(pipefd[0]);
    string message = "我是父进程，正在发送信息";
    int count = 0; //计数器，记录发送信息的条数
    char send_buffer[1024];
    while (true) {
        //3.2 构建一个变化的字符串
        snprintf(send_buffer, sizeof(send_buffer), "%s[%d]: %d", message.c_str(), getpid(), count++);
        //3.3 写入
        write(pipefd[1], send_buffer, strlen(send_buffer));
        //3.4 故意sleep
        sleep(1);
    }
    pid_t ret = waitpid(id, nullptr, 0);
    assert(ret > 0);
    (void)ret;
    close(pipefd[1]);
    return 0;
}
```

### 进程池 Process Pool

一个主进程分配业务，通过每个管道为其对应的子进程分配业务

<img src="进程池.png" width="35%">

### 总结 Linux 管道 `|` 的特点

命令行 `|` 的底层就是兄弟进程之间的单向匿名管道通信

* 管道是用来进行**具有血缘关系**的进程间通信，常用于父子通信
* 管道是有访问控制的（同步和互斥机制），管道也是有容量大小的，若不进行控制，可能会丢失信息。`ulimit -a` 可以发现Linux中管道的默认大小为4096Byte
  * 写快，读满，写满了就不能再写了，writer必须阻塞等待
  * 写慢，读快，管道没有数据的时候，reader必须阻塞等待
  * 写关，读0，标识读到了文件结尾
  * 读关，写继续写，OS终止写进程。写段可以感应到读端关闭，这是通过struct file里的引用计数器知道的
* 管道提供的是面向字节流式的通信服务，需要通过协议来定制。表现为读和写的次数可能不同，比如可能会写10次，读1次
* 管道的本质就是一种特殊的**内存级文件**，文件的生命周期是随进程的，因此管道的生命周期也是随进程的
* 管道是单向通信的，这是由内核实现决定的，是半双工通信的一种特殊情况
  * 半双工 Half-duplex Communication ：通信方要么收要么发
  * 全双工 Duplex Communication：通信放可以同时收发

## *fifo 命名管道*

### 命名管道与匿名管道的区别

匿名管道只能是具有血缘关系的进程之间的通信，如果是完全不相干的进程之间想要通信该怎么实现呢？

进程间通信的本质就是让不同的进程看到同一份资源，匿名管道做到这点的方式是通过让子进程继承父进程，而命名管道则采取通过同一个fifo文件

### `mkfifo` 系统调用

```c
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```

创建一个fifo管道文件，这个管道文件用p来表示

* 参数
  * `const char *pathname`：创建位置
  * `mode_t mode`：fifo文件的权限
* 成功返回0，若出错就会返回-1，并自动设置errno



# System V IPC

System V通信是指一组在System V UNIX操作系统中用于进程间通信的机制和API。这些通信机制允许不同的进程在同一系统上进行数据交换和协作。System V通信包括以下几种主要的形式：

1. **消息队列（Message Queues）：** 消息队列允许进程通过在消息队列中发送和接收消息来进行通信。每个消息都有一个类型，进程可以选择接收特定类型的消息。消息队列通常用于进程之间的异步通信，其中一个进程将消息发送到队列，而另一个进程则可以在需要时从队列中读取消息。
2. **信号量（Semaphores）：** 信号量是一种计数器，它用于同步多个进程的操作。进程可以执行P（Wait）和V（Signal）操作来控制信号量的值。信号量通常用于解决竞争条件和进程同步问题。
3. **共享内存（Shared Memory）：** 共享内存允许多个进程访问同一块物理内存，这使得它们可以高效地共享数据。共享内存通常用于需要快速数据传输的应用程序，但也需要谨慎处理，以避免数据一致性问题。

这些System V通信机制都是底层的，需要开发人员自行管理进程间的同步和互斥。它们为不同的进程提供了一种可靠的方式来进行进程间通信，以便协作完成任务。这些通信机制通常用于复杂的多进程或多线程应用程序中，以确保数据的一致性和协调工作。

System V通信机制在Linux中也有支持和实现。Linux支持System V IPC，以便与传统的UNIX系统和应用程序兼容。因此，在Linux上，你可以使用System V消息队列、信号量和共享内存来进行进程间通信，就像在其他UNIX系统上一样。

# POSIX IPC

# 内存映射

## *Intro*

内存映射 Memory mapping 是指将一个文件或者其他设备的内容映射到进程的虚拟地址空间，使得这部分内容可以被当作内存一样在相应的内存区域中操作字节来访问文件内容。进程可以通过读写这个区域来实现对文件或设备的操作，而不需要使用传统的文件读写接口或设备访问接口，比如缓慢的 read、write 等

内存映射可以通过操作系统提供的系统调用，如 `mmap()` 来实现，它将文件或设备映射到进程的地址空间，并在内核中建立相应的映射关系。一旦内存映射建立，进程就可以直接读写映射区域的内容，而OS会负责将这些操作转换为实际的文件读写或设备访问操作

### 发生场景

一个进程的映射中的内存可以与其他进程中的映射共享，即各个进程的页表条目指向 RAM 中相同分页

* 当两个进程映射了一个文件的同一个区域时它们会共享物理内存的相同分页
* 通过 fork 创建的子进程会继承其父进程的映射的副本，并且这些映射所引用的物理内存分页与父进程中相应映射所引用的分页相同

当两个及以上的进程共享相同分页时，是否能看到其他进程对分页作出的变更取决于共享分页的类型

* 私有/写时复制映射 MAP_PRIVATE：在映射内容上发生的变更对其他进程不可见，当一个进程要修改分页时，该分页会被写时拷贝成一个新的分页
* 共享映射 MAP_SHARED：在映射内容上发生的变更对所有共享同一个映射的其他进程都可见。对于文件映射来讲，变更将会发生在底层的文件上

### 内存映射分类

* 文件映射 file mapping：将文件的一部分直接映射到调用进程的虚拟内存中，映射完成后进程可以通过读写这个区域来实现对文件或设备的操作，进程可以在内存区域中操作字节来访问文件内容
* 匿名映射 anonymous mapping：一个匿名映射没有对应的文件。相反，这种映射的分页会被初始化为 0

与上面的私有/共享映射相组合后可以得到4中内存映射类型

* 私有文件映射：主要用途是使用一个文件的内容来初始化一块内存区域
* 私有匿名映射：主要用途是为一个进程分配新（用 0 填充）的内存，比如在分配大块内存（大于128KB）时 malloc 会为此而使用 mmap 而不是 brk
* 共享文件映射：主要用于替代缓慢的read、write，以加快IO速度（零拷贝），以及用于无关进程之间的IPC
* 共享匿名映射：主要用于相关进程之间的IPC

### 安全性

以下是一些可能的安全问题：

1. 内存访问越界：如果进程在内存映射区域之外进行读写操作，可能会导致内存访问越界的问题，例如读取或修改未映射的内存内容，或者覆盖其他重要数据
2. 潜在的漏洞利用：内存映射可以使恶意用户或程序能够读取或修改敏感数据，例如密码、私钥等。如果对映射区域的权限控制不严格或存在安全漏洞，攻击者可能利用这些漏洞来获取敏感信息
3. 共享对象的安全性：内存映射允许多个进程共享同一个文件的内容。如果共享对象不受适当的保护或验证，可能会导致一个进程对共享对象的恶意修改影响其他进程的安全性

为了确保内存映射的安全性，应该采取以下措施：

1. 权限控制：确保只有授权的进程或用户可以访问映射区域，并且限制他们对映射区域的读写权限。适当的权限控制可以防止未经授权的访问和恶意操作
2. 内存保护：使用内存保护机制，如设置合适的访问权限和内存保护位，以防止越界访问和非法操作
3. 数据验证和加密：对于包含敏感数据的内存映射区域，可以采用数据验证和加密的方法来保护数据的完整性和机密性，以防止未经授权的读取或篡改
4. 共享对象的安全性：对于共享对象，应该实施适当的验证和完整性检查，确保在共享过程中不会被恶意篡改

## *API*

### 创建、销毁mapping

<img src="mmap.png">

```c
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
			// Returns starting address of mapping on success, Or MAP_FAILED on error
int munmap(void *addr, size_t length); 
			// Returns 0 on success, or -1 on error
```

* 参数
  * addr：用户进程中要映射的用户空间的起始地址，通常为NULL，表示由内核来指定一个合适的地址。addr 参数在指定了 MAP_FIXED 的情况下必须要与分页对齐
  * length：要映射的内存区域的大小。API没有强制要求length是一页大小的整数倍，但会被自动向上提升为页的最小整数倍
  * prot：期望的内存保护标志。若违反了保护位，内核会向该进程发送一个 SIGSEGV 信号
    * PROT_EXEC  Pages may be executed
    * PROT_READ  Pages may be read
    * PROT_WRITE Pages may be written
    * PROT_NONE  Pages may not be accessed
  * flags：指定映射对象的类型
    * MP_PRIVATE 创建一个私有映射
    * MP_SHARED 创建一个共享映射
  * fd：文件描述符（由open函数返回）
  * offset：设置映射在文件中的起点，例如文件的偏移量，大小必须为PAGE_SIZE的整数倍，用于对齐。要映射整个文件就需要将 offset 指定为 0 并且将 length 指定为文件大小
* 返回值
  * 成功时 `mmap()` 返回被映射区的指针，该指针就是需要映射的内核空间在用户空间的虚拟地址
  * 失败时根据SUSv3标准返回 `MAP_FAILED == ((void *)-1)` 常量

### msync

```c
int msync(void *addr, size_t length, int flags);
			// Returs O on success, or -1 on error
```

msync 系统调用可以让程序显式控制何时完成共享映射与映射文件之间的同步

* MS_SYNC 同步：调用后等到更新完成之后才返回
* MS_ASYNC 异步：调用后立即返回，不会等待更新的完成
* MS_INVALIDATE：使映射数据的缓存副本失效
* 成功返回0，失败返回-1

### mremap

Linux提供了不可移植的 `mremap()` 系统调用来执行映射区域变更（扩容或缩容）

```c
void *mremap(void *old_address, size_t old_size,
                    size_t new_size, int flags, ... /* void *new_address */);
			// Returns starting address of remapped region on success，or MAP_FAILED on error
```

* addr：上一次已映射到进程空间的地址
* old_size：旧空间的大小，地址必须是分页对齐的。通常是一个由之前的 mmap 调用返回的值
* new_size：重新映射指定的新空间大小
* flags
  * 0代表不允许内核移动映射区域，只能原地扩，如果原地扩失败了就报错
  * MREMAP_MAYMOVE：表示内核可以根据实际情况移动映射区域以找到一个符合new_size大小要求的内存区域

在 Linux 上，realloc 使用 mremap 来高效地为 malloc 之前使用 MAP_ANONYMOUS（私有匿名映射）分配的大内存块重新指定位置

## *匿名映射*

### 创建匿名映射的方式

* 在flags中指定 MAP_ANONYMOUS 并将 fd 指定为-1
* 打开/dev/zero设备文件并将得到的fd传递给mmap

## *其他的mmap flags*

* MAP_LOCKED：将映射分页锁进内存（自 Linux 2.6 起）
* MAP_HUGETLB：创建一个使用巨页的映射（自 Linux 2.6.32 起）
* MAP_POPULATE：填充一个映射的分页（自 Linux 2.6 起）
* MAP_UNINITIALIZED：不清除匿名映射（自 Linux 2.6.33 起）

### MMAP_FIXED

### MAP_NORESERVE

# 虚拟内存

## *虚拟内存操作*

# 线程

## *API*

### fork-join 模型

<img src="fork-join model.drawio.png" width="70%">

### pthread

因为Linux本质上是没有实现多线程（只是轻量化进程），所以Linux本身并不提供线程的系统调用接口。但是提供了创建轻量级进程的接口，即子进程与父进程共享一个地址空间的 `vfork` 和 `clone`，问题是这些接口用起来很麻烦，需要用户自定义线程保护等操作

为了实现多线程的控制，Linux社区提供了pthread这个用户层的第三方原生线程库，头文件是 `pthread.h`。虽然说是第三方的库，但它和Linux系统强相关，在每一个Linux OS都要被预置

其中最常用的是POSIX版线程库。当然语言层上，如C++、python等语言也提供了语言级别的线程库，但这些库基本上就是对用户层原生线程库的封装

### 线程创建

```c
#include <pthread.h>
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
//Compile and link with -pthread.
```

* 参数
  * `pthread_t *thread` 线程id
  * `attr` 线程的属性：设置栈大小、关于该线程调度优先级的信息等
  * `start_routine` 线程要执行的回调函数的函数指针
  * `arg` 是要喂给回调函数的参数
* 创建成功返回0，失败返回errno

### 线程终止

```c
#include <pthread.h>
void pthread_exit(void *retval); //pthread_exit比较常用
int pthread_cancel(pthread_t thread);
```

* 线程的控制流 `start_routine` 内
  * 正常退出 return
  * `pthread_exit`
* 主线程内 `pthread_cancel` 取消分支线程
* 进程分离后main thread不再关心被分离thread的状态，相当于是一种延后退出

### 线程等待

```c
#include <pthread.h>
int pthread_join(pthread_t thread, void **retval);
```

* `void** retval` 是进程退出时的退出码，比如返回 `(void*)10`，它是一个二级指针输出型参数

* 线程退出时没必要像进程退出时输出32位的退出码，因为线程就是进程，线程异常整个进程退出，因此直接交给进程退出码来处理

* ```cpp
  //输出型参数
  void* ret = nullptr;
  pthread_join(tid, &ret);
  cout << "main thread join success, *ret: " << (long long)(ret) << endl;
  ```

`pthread_join` 的作用类似于进程等待 `wait`。线程退出的时候，一般必须要进行join。若不进行join，就会造成类似于进程那样的内存泄漏问题，但没有“僵尸线程”这种说法

调用该函数的线程将挂起等待，直到id为thread的线程终止。thread以不同的方法终止，通过 `pthread_join` 得到的终止状态是不同的

### 线程分离

默认情况下，新创建的线程是joinable的，线程退出后，需要对其进行 `pthread_join` 操作，否则无法释放资源，因而造成系统泄漏

若不关心线程的返回值，join是一种负担，此时可以通过进程分离来告诉系统，当线程退出时，自动释放线程资源

```c
#include <pthread.h>
int pthread_detach(pthread_t thread);
pthread_detach(pthread_self()); //对自己进程分离
```

可以是对线程组内其他线程的其他目标线程进行线程分离，也可以对自己线程分离，只要用`pthread_self()` 来获取tid就行。joinable和分离是冲突的，一个线程不能既是joinable又是分离的，会报22号错误 Invalid argument

进程分离，对应的main thread一般是不退出的，在死循环中常驻内存

## *Pthread实现*

### LinuxThread

### NLT