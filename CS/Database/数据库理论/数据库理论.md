# 数据库核心概念

数据库管理系统 DataBase-Management System DBMS 由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。DBMS的主要目标就是提供一种可以方便、高效地存取数据库信息的途径。**DBMS设计的目的是允许定义、创建、查询、更新和管理符合某种数据模型的数据库**

数据库 Database 就是DMBS中互相关联的数据的集合

<img src="数据库总体架构.drawio.png">

## *数据视图*

### 数据抽象

<img src="数据抽象的三个层次.png">

* 物理层 physical level：最底抽象层，描述数据实际上是怎样存储的，即描述复杂的底层数据结构
* 逻辑层 logical level：中间的抽象层
  * 描述数据库中存储什么数据及这些数据间存在的关系，这样逻辑层就可以通过少量相对简单的结构来描述整个数据库
  * 管理员会接触这一层，因为他必须确定数据库中必须保存哪些信息
* 视图层 view level：最高抽象层
  * 只描述数据库的某个部分，系统可以为同一个数据库提供多个视图
  * 一般的用户在这一层。用户一般不会关心数据库中的所有信息，视图层的定义方便了用户与系统的交互

### 实例 & 模式

数据库中的内容随着增删查改必然会发生变化，把**特定时刻**存储在数据库中的信息的集合称为数据库的**一个实例 instance**（不是MySQL中的服务器实例）

**数据库模式 schema 指的是采用某种数据模型的数据库总体设计**，数据库模式即使会发生变化，也不会频繁

### 数据类型

* 结构化数据

  * 结构化数据是按照预定义模型或模式进行组织的数据，通常以表格形式存储在关系型数据库中

  * 具有明确定义的数据模型，可以使用行和列的结构表示。每个数据元素都有特定的数据类型，例如整数、字符串等

    ```
    +----+----------+--------+--------+
    | ID | Name     | Salary | Dept   |
    +----+----------+--------+--------+
    | 1  | Alice    | 50000  | HR     |
    | 2  | Bob      | 60000  | IT     |
    | 3  | Charlie  | 55000  | Sales  |
    +----+----------+--------+--------+
    ```

* 半结构化数据

  * 半结构化数据没有固定的表格结构，但包含一些标记或标签，使得数据元素之间的关系更为灵活

  * 不符合关系数据库的表格形式，但具有某种结构，通常以层次结构（如XML、JSON）存在，允许嵌套和重复元素

    ```xml
    <config>
      <server>
        <name>WebServer</name>
        <port>80</port>
      </server>
      <database>
        <name>MyDatabase</name>
        <username>admin</username>
        <password>secure123</password>
      </database>
    </config>
    ```

* 非结构化数据

  * 非结构化数据没有明确定义的数据模型，没有固定的格式或结构，难以以表格形式组织和存储

  * 没有预定义的数据模式，通常包含自由文本、图像、音频、视频等形式的数据

    ```
    John Doe
    123 Main Street
    City: Anytown
    Phone: 555-1234
    
    Additional Notes:
    This is a sample document with unstructured text.
    It may contain varying information.
    ```

  * 随着储存成本的下降，以及新兴技术的发展，行业对非结构化数据的重视程度得到提高。比如物联网、工业4.0、视频直播产生了更多的非结构化数据，而人工智能、机器学习、语义分析、图像识别等技术方向则更需要大量的非结构化数据来开展工作

### 数据模型

数据库的基础是数据模型 data model，数据模型是一个描述数据、数据联系、数据语义以及一执行约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式

数据模型可以被划分为以下几类

* 早期的网状数据模型 network data model 和层次数据模型 hierarchical data model 是早期随着硬盘实现了随机存储访问而先于关系数据模型出现的。这两个模型**和物理底层的实现方式密切相连**，复杂化了数据建模，现在已经基本不被使用了
* 关系模型 relational model
* 实体-联系模型 entity-relationship model/E-R model
* [基于对象的数据模型](#基于对象的数据库) object-based data model
* 文档数据模型 document data model / 半结构化数据模型 semistructured data model：JSON 和 可扩展标记语言 eXtensible Markup Language [XML](#XML) 被广泛地用来表示半结构化数据

## *数据库语言*

数据库系统会提供DDL Data Definition Language 数据定义语言来定义数据库模式以及DML Data Manipulation Language 数据操纵语言来表达数据库的查询更新

DDL和DML并不是两种分离的语言，它们共同构成了单一的数据库语言（比如被广泛使用的SQL）的不同部分

### DDL

数据库模式需要通过一系列的定义来实现，这些定义是由DDL, Data Definition Language 数据定义语言 来表达的，DDL也可用于定义数据的其他特征。用来维护存储数据的结构，即对数据库和表结构的属性操作。比如 `create, drop, alter`

### DML

DML, Data Manipulation Language 数据操纵语言 使得用户可以访问或操作那些按照某些事当的数据模型组织起来的数据，即增删查改数据。通常有两种类型的DML。用来对数据进行操作，即对数据库和表结构的内容操作。比如 `insert, delete, update`

* 过程式 DML procedural DML 要求用户指定需要什么数据以及如何获得这些数据 -- Relational Algebra
* 声明式 DML declarative DML（也称为非过程化DML）只要求用户指定需要什么数据，**而不指明如何获得这些数据** -- SQL、Relational Calculus，**一般都是用这个**

**查询 query**是要求对信息进行检索的语句。DML中涉及信息检索的部分称作查询语言 query language。实践中常常会把查询语言和DML作为同义词使用，当然这是不准确的，因为query是DML的一部分

# 关系模型 & 形式化关系查询语言

## *关系模型*

使用早期的数据模型时，人们每次改变物理层都要重新写数据管理系统。因此 1969 年美国 IBM 公司的研究员 Edgar Frank "*Ted*" Codd 首次提出了数据库系统的关系模型。他发表了*A Relation Model of Data for Large Shared Data Banks* 论文。该论文中解释了某些关系代数运算，研究了数据的函数相关性并定义了关系的第三范式，从而开创了数据库的关系方法和数据规范化理论的研究

关系模型的核心思想是：**用简单的数据结构保存，用高级语言来访问，并让DBMS来执行最优策略以及处理物理层存储**

### 表 & 关系

关系数据库由表 table的集合构成。表中的每一行代表了一组值之间的一种联系，一个表就是这种联系的一个集合，表这个概念和[关系的形式化定义](#关系 & 关系代数的形式化定义)是密切相关的，这也是为什么把这种用表来表示数据的数据模型称为关系模型

下面是一些关系模型的术语

* **用关系 relation 来指代表**。关系是一个无序集合 unordered_set，包含代表的实体的属性关系。因为是无序的，所以DBMS可以用它想要的任何方式存储它们，并允许优化
* 元组 tuple 则是一组值的序列，用来指定行，tuple, row, record三者是可以互换的
  * 空值 NULL 是一个特殊的值，表示值未知或不存在。NULL 会给数据库访问和更新带来很多麻烦，所以尽量避免使用 NULL
  * 起初值必须是原子的或者标量，但现在值也可以是一个 NULL，表示未定义
* 属性 attribute 指代的是表中的列（属性的取值范围称为域 domain）。有n个属性的关系，叫做：n-ary relation，也就是 table with n elements

关系实例 relation instance 表示一个关系的特定实例，也就是一张表的一个实例，即具体某一行

**一个关系可以用 `RelationName(Attributes)` 来表示**，比如下面的学生表可以表示为 `Student(ID, Name, Age)`

```
ID | Name | Age
1  | Jim  | 18
2  | Alex | 19
3  | Emma | 20
```

### 键/码 key

DB Book中文翻译为码，但笔者习惯翻译成键

* 超键 superkey 是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一的表示一个元组

* 候选键 candidate key：候选键是一种最小超码，即它们的任意真子集都不能称为超键

* 主键 primary key：被选中主要用来在一个关系中区分不同元组的候选键

  * 主键应该选择那些值从不或者极少变化的属性，一旦选定并建表之后就不能被更改，否则会引发很多错误
  * 习惯上把一个关系模式的主键属性排列在其他属性前面
  * **一个关系的主键唯一的定义了单个元组**。很多DBMSs都支持autogenerated keys，比如说标准SQL语言的 IDENTIDY、MySQL中的 AUTO_INCREMENT，所以程序就不需要手动增加了，但主键在某些DBMSs中还是需要的

* 外键 foreign key：指定一个关系中的属性必须映射到另一个关系中的元组

  若一个关系模式 $r_1$ 可能在它的属性中包括另外一个关系模式 $r_2$ 的主键（$r_2$ 中作主键的属性的命名可能和 $r_1$ 中的属性不同），那么将这个属性在 $r_1$ 上称作参照 $r_2$ 的外键。关系 $r_1$ 也被称为外键依赖的参照关系 referencing relaiton，$r_2$ 叫做外键的被参照关系 referenced relation

  外键常用来建立表与表之间的映射关系，比如有两个表格 student 和 course

  ```
  Student ID | Name | Age
  1          | Jim  | 18
  2          | Alex | 19
  3          | Emma | 20
  ```

  ```
  Course ID | Course name
  11        | Math
  22        | English
  ```

  这两个表之间存在一个关系，即学生选修课程的关系。我们可以使用外键来建立这种关联

  ```
  Student ID | Name | Age | Course (foreign key)
  1          | Jim  | 18  | 11
  2          | Alex | 19  | 11
  3          | Emma | 20  | 22
  ```

## *关系代数*

关系代数符号的LaTeX表示：<https://billc.io/2020/04/latex-relational-algebra/>

关系代数 Relational Algebra 是一种抽象的过程式查询语言，它包括一个运算的集合，由关系运算来表达查询

关系代数同时也是一种数学形式化方法。它提供了一组操作符和规则，用于执行各种数据操作。关系代数是是一阶逻辑的分支，是闭合于运算下的关系的集合。运算作用于一个或多个关系上来生成一个关系

### 关系代数的基本运算及其运算符

以一个关系 `R(a_id, b_id)` 为例，关系代数的基本运算有

* 一元运算：对一个关系进行运算

  * 选择 select $\sigma_{predicate}(R)$

    选择运算选出满足给定关系谓词的元组，运算符为 $\sigma$，将谓词写为下标，关系写在后面的括号中

    <img src="关系代数select.png" width="40%">

    注意：SQL中的select与关系代数中的select是不同的，关系代数中的select对应与SQL中的where

  * 投影 project $\Pi$

    投影运算返回作为参数的关系，而把某些属性排除在外，运算符为 $\Pi$

    <img src="关系代数projection.png" width="40%">

  * 更名 rename $\rho$ 

    更名运算有两种形式：$\rho_x(E)$ 表示返回给定关系代数表达式E的结果，并把名字x赋给它；$\rho_{x(A_1,A_2,\cdots,A_n)}(E)$ 则表示返回给定关系代数表达式E的结果，并把名字x赋给它，同时把其各属性更名为 $A_1,A_2,\cdots,A_n$

* 二元运算：对两个关系进行运算

  * 并 union $\cup$：和逻辑代数中的并操作一样

    <img src="关系代数union.png" width="40%">

    ```mysql
    (SELECT * FROM R) UNION (SELECT * FROM S);
    ```

  * 集合差 set-difference $-$

    找出一个在一个关系中二不再另一个关系中的那些元组，比如 $r-s$ 的结果是返回所有包含在r中的但不在s中的关系

    <img src="关系代数difference.png" width="40%">
  
    ```mysql
    (SELECT * FROM R) EXCEPT (SELECT * FROM S);
    ```
  
  * 笛卡尔积 Cartesian-product $\times$
  
    将任意两个关系的信息组合在一起，比如说有两个表 `instructor(ID, name, dept_name, salary)` 和 `teach(ID course_id, sec_id, semester, year)`
  
    对二者做笛卡尔积运算，会得到一个新表，它的属性为 `(inst.ID, name, dept_name, salary, teach.ID, course_id, sec_id, semester, year)`。我们注意到其中有重复的属性ID，这个问题会在之后的自然连接中解决
  
    <img src="笛卡尔积.drawio.png">

### 关系 & 关系代数的形式化定义

关系代数：关系代数中基本的表达式是数据库中的一个关系或者一个常数关系。关系代数中一般表达式是由基本运算构成的，即
$$
E_1\cup E_2,\ E_1-E_2,\ E_1\times E_2,\ \sigma_P(E_1),\ \Pi_S(E_1),\ \rho_x(E_1)
$$
关系：在关系模型中，关系是描达现实世界的实体及其之间各种联系的单一的数据结构。由关系的名称和一组具有共同属性的无序的多元组构成。**关系可以看做是一个笛卡尔积的有限子集**，笛卡尔积中的元组并不是全都有意义，只有有意义的那些才能成为关系

### 附加的关系代数

六个基本的关系运算已经足以描述所有的关系代数查询，但是为了简化一些常用的查询，可以再定义一些附加的关系代数运算

* 集合交运算 intersection $\cap$

  $r\cap s=r-(r-s)$ 和逻辑代数中的交的使用方法一样

  <img src="关系代数intersection.png" width="40%">

  ```mysql
  (SELECT * FROM R) INTERSECT (SELECT * FROM S);
  ```

* 自然连接运算 natural join $\bowtie$

  通常情况下，涉及笛卡尔积的查询中会包含一个对笛卡尔积结果进行选择的运算。该选择运算大多数情况下会要求进行笛卡尔积的两个关系在所有相同属性上的值相一致

  自然连接首先形成它的两个参数的笛卡尔积，然后保留两个关系中都出现的属性，最后还要去除重复属性

  自然连接是可结合的 associative

* $\theta$ 连接 $\bowtie_{\theta}$ 是自然连接的扩展，它把选择运算和笛卡尔积合并成单独的一个运算
  $$
  r\bowtie_{\theta} s=\sigma_{\theta}(r\times s)
  $$

* 赋值运算 assignment $\leftarrow$：和编程语言中的赋值的效果一样

* 外连接运算 outer-join：外连接运算是连接运算的扩展，可以用来确实丢失的信息

  在自然连接时，有可能虽然两个表有同样的属性，但一个表中属性的某些实例在另外一个表中找不到，比如说instructor里不教课的老师的ID自然不会出现在teach中。此时可以用外连接来处理，外连接和自然连接相似，但是它会在结果中创建带空值的元组，以此来保留在连接中丢失的那些元组

  外连接分为三类

  * 左外连接 left outer join ⟕：取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，再把产生的元组加到自然连接的结果中
  * 右外连接 right outer join ⟖：与左外连接对称，取出右侧关系中所有与左侧关系的任一元组都不匹配的元组，用空值填充所有来自左侧关系的属性，再把产生的元组加到自然连接的结果中
  * 全外连接 full outer join ⟗：既做左外连接又做右外连接，既填充左侧关系中与右侧关系的任一元组都不匹配的元组，又填充右侧关系中与左侧关系的任一元组都不匹配的元组，并把结果都加到连接的结果中

### 扩展关系代数运算

扩展的关系代数运算 extended relational-algebra 可以实现一些不能用基本的关系代数运算来表达的查询

* 广义投影 generalized-projection
* 聚集 aggregation

# SQL

## *intro*

SQL, Structured query language 是声明式的高级语言，数据的具体操作交给底层引擎，SQL本身并不需要知道数据是具体如何操作的

### SQL标准

SQL的最早版本由IBM开发，最早被叫做 SEQUEL 结构化英语查询语⾔，在20世纪70年代早期作为System R项目的一部分。20世纪80年代改名为SQL，目前SQL已经称为关系型数据库的标准

它的标准版本历史如下，来自wiki，现代系统上至少都支持SQL-92标准

<img src="SQL标准.png">

### SQL语言组成

尽管说SQL Structured Query Language 是一种查询 query 语言，但SQL除了在数据库中query之外还可以做很多其他事情，比如定义数据结构、添加约束等等

SQL语言有如下几个部分

* DDL Data Definition Language 数据定义语言，用来维护存储数据的结构，即对数据库和表结构的属性操作。比如 `create, drop, alter`
* DML Data Manipulation Language 数据操纵语言，用来对数据进行操作，即对数据库和表结构的内容操作。比如 `insert, delete, update`
  * DQL Data Query Language 数据查询语言 `select`

* DCL Data Control Language 数据控制语言，主要负责权限管理和事务，比如 `grant, revoke, commit`
* 完整性 integrity：定义完整性约束
* 视图定义：DDL也包括了定义视图的命令
* 事务控制
* 嵌入式SQL和动态SQL embedded- & dynamic SQL：定义SQL语句如何嵌入到通用编程语言，如C、C++和Java中
* 授权 authorization：DDL包括定义关系和视图的访问权限的命令

SQL的各种具体实现（比如说MySQL、PostgreSQL、Oracle等）的各种实现在细节上都有所不同，或者只支持整个语言的一个子集

## *SQL数据类型*

SQL标准支持多种固有类型 built-in types

* 整数

  * int：整数类型（和机器相关的整数的有限子集），也可以使用全称integer
  * smallint：小整数类型（和机器相关的整数类型的子集）

* 小数

  * 浮点数
    * `float(n)`：精度至少为n位的浮点数
    * real, double precision：浮点数与双精度浮点数，精度与机器相关

  * `numeric(p, d)`：定点数，精度由用户指定，p是整数部分的位数，d是小数部分的位数

* 字符类型

  * `char(n)`：固定长度的字符串，由用户指定长度n，也可以使用全称character
  * `varchar(n)`：可变长度的字符串，由用户指定长度n，也可以使用全称character string
  * text：用于存储大量文本数据的字符类型

* BOOLEAN：表示真（TRUE）或假（FALSE）的布尔值

* 日期和时间类型

  * DATE：表示日期

  * TIME：表示时间

  * DATETIME 或 TIMESTAMP：表示日期和时间的组合

  * INTERVAL：表示时间间隔

* 二进制类型 binary types

  * BINARY：固定长度的二进制数据
  * VARBINARY：可变长度的二进制数据
  * BLOB：用于存储大量二进制数据的类型

* 其他类型

  * ARRAY：表示数组类型
  * JSON：用于存储 JSON 数据
  * XML：用于存储 XML 数据

### STRING

特别注意string

<img src="不同SQL数据库对string的处理.png">

## *SQL query*

下面的内容用到的例子都基于下面这三个关系

<img src="SQL用到的数据库例子.png">

### query

SQL查询的基本结构由3个子句构成：select、from和where

* select子句用于列出查询结果中所需要的属性
  * 强行删除重复可以在select后面加上distinct
  * 默认是保留重复的，也可以用all来显式指明不去重
  * 用 `*` 来表示选中所有属性 
* from子句是一个查询求值中需要访问的关系列表
* where子句是一个作用在from子句中关系的属性上的谓词

其基本结构为如下，其中每个 $A_i$ 代表一个属性，每个 $r_i$ 代表一个关系（某几张表 $r_i$ 的笛卡尔积中选择符合where谓词的属性 $A_i$ 列）

```sql
SELECT A1, A2, ..., An
FROM r1, r2, ..., rm
WHERE P;
```

上面 $r_i$ 的完整笛卡尔积是相当庞大的，需要通过一些方法来优化，使得只产生符合where的元组

### 自然连接

```sql
SELECT A1, A2, ..., An
FROM r1 NATURAL JOIN r2 NATURAL JOIN ... NATURAL JOIN rm # 也可以表示为：from E1, E2, ..., Em
WHERE P;
```

## *基本运算*

### as重命名

`AS` 关键字用于为查询结果中的列或表达式指定别名 alias。别名是一个临时的名称，它可以用于提高查询结果的可读性，简化复杂的列名或表达式，并且在应用程序中引用结果集时提供更有意义的名称

* 列别名

  ```sql
  SELECT first_name AS "First Name", last_name AS "Last Name"
  FROM employees;
  ```

  在这个例子中，查询从名为 `employees` 的表中选择 `first_name` 和 `last_name` 列，并将它们分别重命名为 "First Name" 和 "Last Name"

* 表别名

  ```sql
  SELECT e.first_name, e.last_name, d.department_name
  FROM employees AS e
  JOIN departments AS d ON e.department_id = d.department_id;
  ```

  在这个例子中，`employees` 表被重命名为 `e`，而 `departments` 表被重命名为 `d`。这使得查询更简洁，而且在连接条件中引用列时更清晰

* 表达式别名

  ```sql
  SELECT salary * 0.1 AS "Bonus"
  FROM employees;
  ```

​	在这个例子中，查询计算员工工资的10%作为奖金，并使用 `AS` 关键字为这个计算结果指定了别名 "Bonus"

### 字符串运算

SQL使用一对单引号来标识字符串，若单引号也是字符串的组成部分，那就用双引号来表示

用 `like` 来实现模式匹配，在 `like` 比较运算中使用 `escape` 来定义转移字符。用 `not like` 比较运算符搜索不匹配项 

* 百分号 % 匹配任意子串
* 下划线 _ 匹配任意一个字符

### 字符串函数

### 集合运算

SQL作用在关系上的 union、intersect和except运算对应与集合中并、交、补运算

## *聚集函数 Aggregates*

### 基本聚集

聚集函数 aggregate functions 是以值的一个集合（集或多重集）为输入，返回单个值的函数。聚合函数（⼏乎）只能在 SELECT 输出列表中使⽤，单个 SELECT 语句可以包含多个聚合

SQL提供了5个built-in的聚集函数：平均值 avg、最小值 min、最大值 max、总和 sum、计数 count

其中sum和avg的输入必须是数字集，其他运算符还可以作用在非数字数据类型的集合上，比如字符串

如果要在计算聚集函数前需要先删除重复元组，可以使用distinct。SQL不允许在用 `count(*)` 时同时使用distinct

### 分组聚集

有时候聚集的目标不是整个元组集合，而是对其进行分组，使用group by子句来分组聚集

在group by子句中的所有属性上取值相同的元组将被分在一组中

可以进一步使用having子句来对形成的分组进一步限定条件，即 HAVING 的⾏为类似于 GROUP BY 的 WHERE ⼦句

### 对空值和布尔值的聚集

聚集函数根据以下原则处理空值：除了 `count(*)` 外所有的聚集函数都忽略输入集合中的空值。由于空值被忽略，有可能造成参加函数运算的输人值集合为空集。规定空集的 count 运算值为0，其他所有聚集运算在输人为空集的情况下返回一个空值

在SQL-1999中引入了布尔值数据类型，它可以取true、false、unknown三个值，有两个聚集函数 some 和 every 可以用来处理布尔值的聚合

## *输出控制*

### 顺序

order by

### 重定向

可以指定 DBMS 将结果存储到另⼀个表中，⽽不是将查询结果返回到客⼾端（例如终端），然后可以在后续访问这些数据

* 新表：将查询的输出存储到新（永久）表中

  ```sql
  SELECT DISTINCT cid INTO CourseIds FROM enrolled;
  ```

* 现有表：将查询的输出结果存储到数据库中已存在的表中。输出结果和⽬标表必须具有相同数量和类型的列，但列名称不必相匹配

  ```sql
  INSERT INTO CourseIds (SELECT DISTINCT cid FROM enrolled);
  ```

## *窗口函数*

聚集只能对整个结果集进行计算，并返回单个值。聚合函数通常用于对一列的所有值进行统计操作，例如计算平均值、总和、最大值等

如果想要对查询结果的不同分分别操作的话，聚集就做不到。这时候要用到窗口函数 window function，也称为OLAP函数，Online Anallytical Processing，联机分析处理

```sql
SELECT ... FUNC-NAME(...) OVER (...)
FROM tablename
ORDER BY someattribute
```

SQL没有顺序，如果没有 window function 的话无法知道

## *一些特殊的查询方式*

### 嵌套查询/子查询

嵌套查询 nested query 也称为子查询 subquery 指的是在一个 SQL 查询语句中嵌套使用另一个查询语句。嵌套查询允许你在一个查询中使用另一个查询的结果作为条件，从而进行更复杂和灵活的数据库操作。嵌套查询可以出现在 SELECT、FROM、WHERE 子句等不同的部分

由于存在 correlation，嵌套查询通常很难优化

下面是一些嵌套查询用到的关键字

* ALL：只要满足内层查询语句返回的结果中的任何一个就可以通过该条件来执行外层查询语句
* ANY：至少满足内层查询语句返回的结果中的一项来执行外层查询语句
* IN 等价于 `ANY()`
* EXISTS：对嵌套查询进行运算以判断它是否返回行

举个例子

```sql
SELECT name FROM student WHERE
sid IN (SELECT sid FROM enrolled)
```

### Lateral Join

`LATERAL JOIN` 允许在连接的右侧的表达式中引用左侧表的列。这使得可以在连接的右侧使用左侧表的列值来动态计算、过滤或进行其他操作。`LATERAL` 关键字通常与 `JOIN` 或 `APPLY` 语法结合使用

### 函数 & 过程

### 触发器

### 递归查询

递归查询是指在 SQL 中进行自引用的查询，通常用于处理包含层次结构的数据，例如树形结构或组织结构。在 SQL 标准中，递归查询可以使用 `WITH RECURSIVE` 子句来实现

# 存储模型

### MMAP/IO的问题

* 事务安全：OS并不知道事务的顺序，它只知道有脏页了
* IO stall
* 异常处理
* 性能问题：OS需要在内存中维护自己的核心数据结构，这就会引起数据竞争

仍然需要依赖OS，直接从物理层，比如说磁盘或网卡拿数据会很痛苦。以网络通信为例，需要依赖OS提供的TCP协议，很少会直接用dpdk从网卡拿raw packet。当时要尽量减少对OS的依赖，因为上面所述的原因不利于对数据的控制



self-contained：所有的页元数据都被存储在页当中。如果DBMS本身发生了错误，不会影响元数据，不过现在的硬件已经比以前的磁盘稳定多了



failsafe writes, i.e. atomic writes



大的页，让数据顺序存储，减少IO次数

Linux只能双向prefetch连续的数据，无法prefetch不连续的



Tree: MySQL，不过现在不是很常用了

Heap: most common

# Buffer Pool

# Query Execution

# Query Optimization



