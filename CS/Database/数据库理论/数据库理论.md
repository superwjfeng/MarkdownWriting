# 数据库核心概念

数据库管理系统 DataBase-Management System DBMS 由一个互相关联的数据的集合和一组用以访问这些数据的程序组成。DBMS的主要目标就是提供一种可以方便、高效地存取数据库信息的途径

数据库 Database 就是DMBS中互相关联的数据的集合

## *数据视图*

### 数据抽象

<img src="数据抽象的三个层次.png">

* 物理层 physical level：最底抽象层，描述数据实际上是怎样存储的，即描述复杂的底层数据结构
* 逻辑层 logical level：中间的抽象层
  * 描述数据库中存储什么数据及这些数据间存在的关系，这样逻辑层就可以通过少量相对简单的结构来描述整个数据库
  * 管理员会接触这一层，因为他必须确定数据库中必须保存哪些信息
* 视图层 view level：最高抽象层
  * 只描述数据库的某个部分，系统可以为同一个数据库提供多个视图
  * 一般的用户在这一层。用户一般不会关心数据库中的所有信息，视图层的定义方便了用户与系统的交互

### 实例 & 模式

数据库中的内容随着增删查改必然会发生变化，把**特定时刻**存储在数据库中的信息的集合称为数据库的**一个实例 instance**

**数据库模式 schema 指的是采用某种数据模型的数据库总体设计**，数据库模式即使会发生变化，也不会频繁

### 数据模型

数据库的基础是数据模型 data model，数据模型是一个描述数据、数据联系、数据语义以及一执行约束的概念工具的集合。数据模型提供了一种描述物理层、逻辑层以及视图层数据库设计的方式

数据模型可以被划分为以下几类

* 早期的网状数据模型 network data model 和层次数据模型 hierarchical data model 是早期随着硬盘实现了随机存储访问而先于关系数据模型出现的。这两个模型和底层的实现方式密切相连，复杂化了数据建模，现在已经基本不被使用了
* 关系模型 relational model
* 实体-联系模型 entity-relationship model/E-R model
* [基于对象的数据模型](#基于对象的数据库) object-based data model
* 半结构化数据模型 semistructured data model：可扩展标记语言 eXtensible Markup Language [XML](#XML) 被广泛地用来表示半结构化数据

## *数据库语言*

数据库系统会提供DDL Data Definition Language 数据定义语言来定义数据库模式以及DML Data Manipulation Language 数据操纵语言来表达数据库的查询更新

DDL和DML并不是两种分离的语言，它们共同构成了单一的数据库语言（比如被广泛使用的SQL）的不同部分

### DDL

数据库模式需要通过一系列的定义来实现，这些定义是由DDL来表达的，DDL也可用于定义数据的其他特征

### DML

DML使得用户可以访问或操作那些按照某些事当的数据模型组织起来的数据，即增删查改数据。通常有两种类型的DML

* 过程式 DML procedural DML 要求用户指定需要什么数据以及如何获得这些数据 -- Relational Algebra
* 声明式 DML declarative DML（也称为非过程化DML）只要求用户指定需要什么数据，而不指明如何获得这些数据 -- SQL、Relational Calculus

**查询 query**是要求对信息进行检索的语句。DML中涉及信息检索的部分称作查询语言 query language。实践中常常会把查询语言和DML作为同义词使用，当然这是不准确的，因为query是DML的一部分

# 关系模型 & 形式化关系查询语言

## *关系模型*

1970 年美国 IBM 公司的研究员 E.F.Codd 首次提出了数据库系统的关系模型。他发表了*A Relation Model of Data for Large Shared Data Banks* 论文。该论文中解释了某些关系代数运算，研究了数据的函数相关性并定义了关系的第三范式，从而开创了数据库的关系方法和数据规范化理论的研究

### 表 & 关系

关系数据库由表 table的集合构成。表中的每一行代表了一组值之间的一种联系，一个表就是这种联系的一个集合，表这个概念和[关系的形式化定义](#关系的形式化定义)是密切相关的，这也是为什么把这种用表来表示数据的数据模型称为关系模型

在关系模型的术语中，**用关系 relation 来指代表**；元组 tuple 则是一组值的序列，用来指定行，tuple, row, record三者是可以互换的；属性 attribute 指代的是表中的列（属性的取值范围称为域 domain）

关系实例 relation instance 表示一个关系的特定实例，也就是一张表的一个实例，即具体某一行

空值 null 是一个特殊的值，表示值未知或不存在。null会给数据库访问和更新带来很多麻烦，所以尽量避免使用null

### 键/码 key

DB Book中文翻译为码，但笔者习惯翻译成键

* 超键 superkey 是一个或多个属性的集合，这些属性的组合可以使我们在一个关系中唯一的表示一个元组

* 候选键 candidate key：候选键是一种最小超码，即它们的任意真子集都不能称为超码

* 主键 primary key：被选中主要用来在一个关系中区分不同元组的候选键

  * 主键应该选择那些值从不或者极少变化的属性，一旦选定并建表之后就不能被更改，否则会引发很多错误
  * 习惯上把一个关系模式的主键属性排列在其他属性前面

* 外键 foreign key

  若一个关系模式 $r_1$ 可能在它的属性中包括另外一个关系模式 $r_2$ 的主键（$r_2$ 中作主键的属性的命名可能和 $r_1$ 中的属性不同），那么将这个属性在 $r_1$ 上称作参照 $r_2$ 的外键。关系 $r_1$ 也被称为外键依赖的参照关系 referencing relaiton，$r_2$ 叫做外键的被参照关系 referenced relation

  外键常用来建立表与表之间的映射关系，比如有两个表格 student 和 course

  ```
  Student ID | Name | Age
  1          | Jim  | 18
  2          | Alex | 19
  3          | Emma | 20
  ```

  ```
  Course ID | Course name
  11        | Math
  22        | English
  ```

  这两个表之间存在一个关系，即学生选修课程的关系。我们可以使用外键来建立这种关联

  ```
  Student ID | Name | Age | Course (foreign key)
  1          | Jim  | 18  | 11
  2          | Alex | 19  | 11
  3          | Emma | 20  | 22
  ```

## *关系代数*

关系代数符号的LaTeX表示：<https://billc.io/2020/04/latex-relational-algebra/>

关系代数 Relational Algebra 是一种抽象的过程式查询语言，它包括一个运算的集合，由关系运算来表达查询

关系代数同时也是一种数学形式化方法。它提供了一组操作符和规则，用于执行各种数据操作。关系代数是是一阶逻辑的分支，是闭合于运算下的关系的集合。运算作用于一个或多个关系上来生成一个关系

### 关系代数的基本运算及其运算符

关系代数的基本运算有

* 一元运算：对一个关系进行运算

  * 选择 select $\sigma$

    选择运算选出满足给定谓词的元组，运算符为 $\sigma$，将谓词写为下标，参数关系写在后面的括号中

    注意：SQL中的select与关系代数中的select是不同的，关系代数中的select对应与SQL中的where

  * 投影 project $\Pi$

    投影运算返回作为参数的关系，而把某些属性排除在外，运算符为 $\Pi$

  * 更名 rename $\rho$ 

    更名运算有两种形式：$\rho_x(E)$ 表示返回给定关系代数表达式E的结果，并把名字x赋给它；$\rho_{x(A_1,A_2,\cdots,A_n)}(E)$ 则表示返回给定关系代数表达式E的结果，并把名字x赋给它，同时把其各属性更名为 $A_1,A_2,\cdots,A_n$

* 二元运算：对两个关系进行运算

  * 并 union $\cup$：和逻辑代数中的并操作一样

  * 集合差 set-difference $-$

    找出一个在一个关系中二不再另一个关系中的那些元组，比如 $r-s$ 的结果是返回所有包含在r中的但不在s中的关系

  * 笛卡尔积 Cartesian-product $\times$

    将任意两个关系的信息组合在一起，比如说有两个表 `instructor(ID, name, dept_name, salary)` 和 `teach(ID course_id, sec_id, semester, year)`

    对二者做笛卡尔积运算，会得到一个新表，它的属性为 `(inst.ID, name, dept_name, salary, teach.ID, course_id, sec_id, semester, year)`。我们注意到其中有重复的属性ID，这个问题会在之后的自然连接中解决

    <img src="笛卡尔积.drawio.png">

### <span id="关系的形式化定义">关系 & 关系代数的形式化定义</span>

关系代数：关系代数中基本的表达式是数据库中的一个关系或者一个常数关系。关系代数中一般表达式是由基本运算构成的，即
$$
E_1\cup E_2,\ E_1-E_2,\ E_1\times E_2,\ \sigma_P(E_1),\ \Pi_S(E_1),\ \rho_x(E_1)
$$
关系：在关系模型中，关系是描达现实世界的实体及其之间各种联系的单一的数据结构。由关系的名称和一组具有共同属性的无序的多元组构成。**关系可以看做是一个笛卡尔积的有限子集**，笛卡尔积中的元组并不是全都有意义，只有有意义的那些才能成为关系

### 附加的关系代数

六个基本的关系运算已经足以描述所有的关系代数查询，但是为了简化一些常用的查询，可以再定义一些附加的关系代数运算

* 集合交运算 intersection $\cap$

  $r\cap s=r-(r-s)$ 和逻辑代数中的交的使用方法一样

* 自然连接运算 natural join $\bowtie$

  通常情况下，涉及笛卡尔积的查询中会包含一个对笛卡尔积结果进行选择的运算。该选择运算大多数情况下会要求进行笛卡尔积的两个关系在所有相同属性上的值相一致

  自然连接首先形成它的两个参数的笛卡尔积，然后基于两个关系模式中都出现的属性上的相等性进行选择，最后还要去除重复属性

  自然连接是可结合的 associative

* $\theta$ 连接 $\bowtie_{\theta}$ 是自然连接的扩展，它把选择运算和笛卡尔积合并成单独的一个运算
  $$
  r\bowtie_{\theta} s=\sigma_{\theta}(r\times s)
  $$

* 赋值运算 assignment $\leftarrow$：和编程语言中的赋值的效果一样

* 外连接运算 outer-join：外连接运算是连接运算的扩展，可以用来确实丢失的信息

  在自然连接时，有可能虽然两个表有同样的属性，但一个表中属性的某些实例在另外一个表中找不到，比如说instructor里不教课的老师的ID自然不会出现在teach中。此时可以用外连接来处理，外连接和自然连接相似，但是它会在结果中创建带空值的元组，以此来保留在连接中丢失的那些元组

  外连接分为三类

  * 左外连接 left outer join ⟕：取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，再把产生的元组加到自然连接的结果中
  * 右外连接 right outer join ⟖：与左外连接对称，取出右侧关系中所有与左侧关系的任一元组都不匹配的元组，用空值填充所有来自左侧关系的属性，再把产生的元组加到自然连接的结果中
  * 全外连接 full outer join ⟗：既做左外连接又做右外连接，既填充左侧关系中与右侧关系的任一元组都不匹配的元组，又填充右侧关系中与左侧关系的任一元组都不匹配的元组，并把结果都加到连接的结果中

### 扩展关系代数运算

扩展的关系代数运算 extended relational-algebra 可以实现一些不能用基本的关系代数运算来表达的查询

* 广义投影 generalized-projection
* 聚集 aggregation

## *元组关系演算*

## *域关系演算*

# SQL基础

## *intro*

### SQL标准

SQL的最早版本由IBM开发，最早被叫做Sequel，在20世纪70年代早期作为System R项目的一部分。目前SQL已经称为关系型数据库的标准

它的标准版本历史如下，来自wiki

<img src="SQL标准.png">

### SQL语言组成

尽管说SQL Structured Query Language 是一种查询 query 语言，但SQL除了在数据库中query之外还可以做很多其他事情，比如定义数据结构、添加约束等等

SQL语言有如下几个部分

* DDL：定义关系模式、删除关系以及修改关系模式
* DML：增删查改
* 完整性 integrity：定义完整性约束
* 视图定义：DDL也包括了定义视图的命令
* 事务控制
* 嵌入式SQL和动态SQL embedded- & dynamic SQL：定义SQL语句如何嵌入到通用编程语言，如C、C++和Java中
* 授权 authorization：DDL包括定义关系和视图的访问权限的命令

SQL的各种具体实现（比如说MySQL、PostgreSQL、Oracle等）的各种实现在细节上都有所不同，或者只支持整个语言的一个子集

## *SQL数据定义*

### 基本固有类型

SQL标准支持多种固有类型 built-in types

* `char(n)`：固定长度的字符串，由用户指定长度n，也可以使用全称character
* `varchar(n)`：可变长度的字符串，由用户指定长度n，也可以使用全称character string
* int：整数类型（和机器相关的整数的有限子集），也可以使用全称integer
* smallint：小整数类型（和机器相关的整数类型的子集）
* `numeric(p, d)`：定点数，精度由用户指定，p是整数部分的位数，d是小数部分的位数
* real, double precision：浮点数与双精度浮点数，精度与机器相关
* `float(n)`：精度至少为n位的浮点数

### 空值问题

### 基本模式 schema 定义

`create table`

## *其他的数据类型 & 模式*

### 日和时间类型

### 索引

### 大对象

### 独特类型

## *SQL query的基本结构*

### query

SQL查询的基本结构由3个子句构成：select、from和where

* select子句用于列出查询结果中所需要的属性
  * 强行删除重复可以在select后面加上distinct
  * 默认是保留重复的，也可以用all来显式指明不去重
  * 用 `*` 来表示选中所有属性 
* from子句是一个查询求值中需要访问的关系列表
* where子句是一个作用在from子句中关系的属性上的谓词

其基本结构为如下，其中每个 $A_i$ 代表一个属性，每个 $r_i$ 代表一个关系（某几张表 $r_i$ 的笛卡尔积中选择符合where谓词的属性 $A_i$ 列）

```sql
select A1, A2, ..., An
from r1, r2, ..., rm
where P;
```

上面 $r_i$ 的完整笛卡尔积是相当庞大的，需要通过一些方法来优化，使得只产生符合where的元组

### 自然连接

```sql
select A1, A2, ..., An
from r1 natural join r2 natural join ... natural join rm # 也可以表示为：from E1, E2, ..., Em
where P;
```

## *运算*

### as重命名

### 字符串运算

SQL使用一对单引号来标识字符串，若单引号也是字符串的组成部分，那就用双引号来表示

用 `like` 来实现模式匹配，在 `like` 比较运算中使用 `escape` 来定义转移字符。用 `not like` 比较运算符搜索不匹配项 

* 百分号 % 匹配任意子串
* 下划线 _ 匹配任意一个字符

### 集合运算

SQL作用在关系上的 union、intersect和except运算对应与集合中并、交、补运算

## *聚集函数*

基本聚集

聚集函数 aggregate functions 是以值的一个集合（集或多重集）为输入，返回单个值的函数，SQL提供了5个built-in的聚集函数：平均值 avg、最小值 min、最大值 max、总和 sum、计数 count

其中sum和avg的输入必须是数字集，其他运算符还可以作用在非数字数据类型的集合上，比如字符串

如果要在计算聚集函数前需要先删除重复元组，可以使用distinct。SQL不允许在用 `count(*)` 时同时使用distinct

### 分组聚集

有时候聚集的目标不是整个元组集合，而是对其进行分组，使用group by子句来分组聚集

在group by子句中的所有属性上取值相同的元组将被分在一组中

可以进一步使用having子句来对形成的分组进一步限定条件

### 对空值和布尔值的聚集

聚集函数根据以下原则处理空值：除了 `count(*)` 外所有的聚集函数都忽略输入集合中的空值。由于空值被忽略，有可能造成参加函数运算的输人值集合为空集。规定空集的 count 运算值为0，其他所有聚集运算在输人为空集的情况下返回一个空值

在SQL-1999中引入了布尔值数据类型，它可以取true、false、unknown三个值，有两个聚集函数 some 和 every 可以用来处理布尔值的聚合

## *嵌套子查询*

## *增删改*

上面所有的内容都是关于查的，下面介绍增删改DML

### 删除

### 插入

### 更新

## *连接表达式*

## *视图*

## *完整性约束*

## *授权*

# SQL进阶

## *函数和过程*

## *触发器*

## *递归查询*

## *OLAP*

# Query处理

# Query优化

# <span id="基于对象的数据库">基于对象的数据库</span>

# <span id="XML">XML</span>



