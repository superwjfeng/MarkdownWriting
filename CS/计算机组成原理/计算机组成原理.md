# 计算机发展概述

## *计算机系统层次结构*

1.1.1.   计算机硬件的基本组成

1.1.1.1.  早期冯诺依曼机 Von Neumann architecture：首次提出了“存储程序”概念，计算机实现了自动化执行代码                               

1.1.1.1.1. 由五大部件组成

1.1.1.1.2. 指令和数据以同等地位存于存储器，可按地址寻访

1.1.1.1.3. 指令和数据用二进制表示

1.1.1.1.4. 指令由操作码和地址码组成

1.1.1.1.5. 存储程序

1.1.1.1.6. 以运算器为中心，输入/输出设备与存储器之间的数据传送通过运算器完成

1.1.1.2.  现代计算机的组织架构   

1.1.1.2.1. 主存储器 

1.1.1.2.1.1. 基本组成

1.1.1.2.1.1.1. 存储体

1.1.1.2.1.1.2. MAD: Memory Address Register 存储地址寄存器：2^位数为存储体的容量

1.1.1.2.1.1.3. MDR: Memory Data Register 存储数据寄存器：MDR每个存储单元的位数=存储字长

1.1.1.2.1.2. 参数

1.1.1.2.1.2.1. 存储单元：每个存储单元存放一串二进制代码

1.1.1.2.1.2.2. 存储字 Word：存储单元中二进制代码的组合

1.1.1.2.1.2.3. 存储字长：存储单元中二进制代码的位数

1.1.1.2.1.2.4. 存储元：即存储二进制的电子元件（电容）。每个存储元可存1bit

1.1.1.2.2. 运算器：用来实现算数运算和逻辑运算 

1.1.1.2.2.1. ACC Acumulator：累加器，用来存放操作数或运算结果

1.1.1.2.2.2. MQ Multiple-Quotient Register：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果

1.1.1.2.2.3. X Arithmatic and Logic Unit：通用的操作数寄存器，用于存放操作数，可以有多个

1.1.1.2.2.4. ALU：算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算，最重要

1.1.1.2.3. 控制器 

1.1.1.2.3.1. CU Control Unit：控制单元，分析指令，给出控制信号

1.1.1.2.3.2. IR Instruction Register：指令寄存器，存放当前执行的指令

1.1.1.2.3.3. PC Program Counter：程序计数器，存放下一条指令地址，有自动加1功能

1.1.2.   计算机软件分类

1.1.2.1.  系统软件和应用软件

1.1.2.2.  计算机语言

1.1.2.2.1. 机器语言：二进制代码

1.1.2.2.2. 汇编语言：助记符

1.1.2.2.3. 高级语言

1.1.2.2.3.1. 编译器 Complier

1.1.2.2.3.2. 解释器 Interpretor 

1.1.3.   计算机系统的多级层次结构

1.2.  计算机的性能指标

1.2.1.   机器字长

1.2.2.   数据通路带宽

1.2.3.   主存容量

1.2.4.   运算速度

1.2.4.1.  吞吐量和响应时间

1.2.4.2.  主频和CPU时钟周期

1.2.4.2.1. CPU时钟周期

1.2.4.2.2. 主频

1.2.4.2.3. CPI Clock cycple Per Instruction

1.2.4.2.4. MIPS, MFLOPS, GFLOPS, TFLOPS

1.2.4.2.4.1. MIPS

1.2.4.2.4.2. MFLOPS

# 数据的表示和运算

2.1.  数制与编码

2.1.1.   进位计数制及其相互转换

2.1.1.1.  进位计数法

2.1.1.1.1. 二进制 Binary

2.1.1.1.2. 十进制 Decimal

2.1.1.1.3. 八进制 Octal

2.1.1.1.4. 十六进制 Hexdecimal 0x…

2.1.1.2.  不同数位之间的相互转换 

2.1.1.2.1. 二进制转其他进制

2.1.1.2.1.1. 二进制转十进制：按位加权

2.1.1.2.1.2. 二进制转八进制：3位一组加权

2.1.1.2.1.3. 二进制转十六：4位一组加权

2.1.1.2.2. 其他进制转二进制

2.1.1.2.2.1. 八进制转二进制：拆分为三位二进制后分别长除法取逆序

2.1.1.2.2.2. 十六进制转二进制：拆分为四位二进制后分别长除法取逆序

2.1.1.2.3. 八进制与十六进制之间转换：间接通过二进制或十六进制转换

2.1.1.2.4. 任意进制转十进制：每位数字按权展开

2.1.1.2.5. 十进制转任意进制   ：用除数为r的长除法后取逆序

2.1.2.   真值和机器数

2.1.3.   BCD码 Binary-Coded Decimal：用4位二进制表示一位十进制

2.1.3.1.  8421码：有权码 

2.1.3.2.  余3码：无权码，8421码基础上每个二进制+3

2.1.3.3.  2421码：有权码  

2.1.4.   字符与字符串

2.1.4.1.  字符编码ASCII码：7位二进制编码 

2.1.4.1.1. 32-126：可印刷字符

2.1.4.1.1.1. 48-59：后4位对应8421码

2.1.4.1.2. 其余为控制和通信字符

2.1.4.2.  汉字的表示和编码：区位码编号+20H（20H防止和ASCII码通信符冲突） 

2.1.4.2.1. 输入：输入编码

2.1.4.2.2. 输出：汉字字形码

2.1.4.3.  字符串

2.1.4.3.1. 从低地址到高地址逐个字符存储，常采用’\0’作为结尾标志

2.1.4.3.2. 对于多字节的数据（如汉字），可采取大/小端存储模式

2.1.4.3.2.1. 大端模式：将数据的最高有效字节存放在低地址单元中

2.1.4.3.2.2. 小端模式：将数据的最高有效字节存放在高地址单元中

2.1.5.   校验码 Check digit

2.1.5.1.  检验原理：由若干位代码组成的一个字叫码字 Code Word，将两个码字逐位进行对比，具有不同的位的个数称为两个码字间的距离。一种编码方案可能由若干个合法码字，各合法码字之间的最小距离称为码距 Code Distance

2.1.5.2.  常用检验码

2.1.5.2.1. 奇偶校验码 Parity Check

2.1.5.2.2. 汉明码（多重奇偶校验码） Hamming Code 

2.1.5.2.3. 循环冗余校验码 Cyclic Redunancy Check CRC：在K位信息码后再拼接R位的校验码，整个编码的长度位N位，因此也称为(N, K)码

2.1.5.2.3.1. 生成多项式

2.1.5.2.3.2. 编码和检测过程

2.1.5.2.3.2.1. 将原信息码左移R位，低位补0

2.1.5.2.3.2.2. 对移位后的用生成多项式进行模2除

2.1.5.2.3.2.3. 检错和纠错

2.1.5.2.3.3. 余数和出错位确实有循环关系，但并不是简单的二进制转换为十进制的关系。因此要选择合适的信息码和生成多项式的位数来匹配循环关系，即K个信息位，R个校验位，当选择  时，CRC码可纠错1位。但实际中CRC码一般用于计算机网络数据传输，通常为上千位信息位+几位校验位，因此基本只用来检错

2.2.  定点数的表示与运算

2.2.1. 定点数的表示：真值为X，  

2.2.1.1.  无符号数和有符号数的表示

2.2.1.1.1. 无符号数的整个机器字长的全部二进制位均为数值位，没有符号位，相当于数的绝对值。表示范围： 

2.2.1.1.2. 有符号数的最高位为符号位，0为正，1为负

2.2.1.2.  机器数的定点表示：定点表示即约定机器数中的小数点位置是固定不变的。计算机中约定将小数点的位置固定在数据的最高位之前，或固定在最低位之后。

2.2.1.2.1. 定点小数 ：表示范围：  ，其数值部分也称为尾数 

2.2.1.2.2. 定点整数 ：表示范围   

2.2.1.3.  原码、补码、反码、移码

2.2.1.3.1. 原码 Sign Magnitude 表示法：表示范围为  ，其中真值0有+0和-0两种形式

2.2.1.3.2. 反码 One’s complement 表示法：若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反，表示范围和真值0的情况和原码相同。只是用来计算补码的一种过渡表示形式，实际中没有太大运用

2.2.1.3.3. 补码 Two’s complement 表示法：使用补码可将减法操作转变为等价的加法，ALU中无需集成减法器，执行加法操作时，符号位一起参与运算

2.2.1.3.3.1. 计算：正数的补码=原码；负数的补码=整数的反码末位+1（考虑进位）；将负数补码转换为原码的方式相同，其反码末位+1（加一个模）。模-a的绝对值=a的补数。或者负数补码转原码，最右边的1及其右边同原码，最右边的1的左边同反码。

2.2.1.3.3.2. 表示范围：补码的真值0只有一种表示形式

2.2.1.3.3.2.1. [X]补=1,0000000多余，规定定点整数补码[X]补=1,0000000表示X=-2n，表示范围 

2.2.1.3.3.2.2. 规定定点小数补码[X]补=1,0000000表示X=-1，表示范围 

2.2.1.3.3.3. 不同机器数之间的转换 

2.2.1.3.4. 移码 Offset binary表示法：移码的基础上将符号位取反，移码只能用于表示整数。移码表示的整数很方便计算机硬件对比大小。移码=真值+偏置值，偏置值一般取  ，此时移码=补码符号位取反。

2.2.2.   定点数的运算

2.2.2.1.  定点数的移位运算

2.2.2.1.1. 算术移位 Arithmatic shift：通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。由于位数有限，因此有时候无法用算术移位精确地等效乘除法 

2.2.2.1.1.1. 右移：高位补0，低位舍弃。若舍弃的位=0，则相当于/2；若舍弃的位≠0，则会丢失精度

2.2.2.1.1.2. 左移：低位补0，高位舍弃。若舍弃的位=0，则相当于*2；若舍弃的位≠0，则会出现严重误差

2.2.2.1.1.3. 负数反码的算数移位是补1

2.2.2.1.1.4. 负数补码中，最右边的1及其右边同原码。最右边的1的左边同反码，因为右移同反码，左移同原码

2.2.2.1.2. 逻辑移位 Logical shift：不管左移右移都添0

2.2.2.1.2.1. C语言的左移是逻辑移位；右移正数是算数移位，负数是逻辑移位

2.2.2.1.3. 循环移位 Cyclic shift：循环移位操作特别适合将数据的低字节数据和高字节数据互换 

2.2.2.2.  源码定点数的加减法运算

2.2.2.3.  补码定点数加减法运算

2.2.2.4.  符号扩展

2.2.2.4.1. 正整数的原、反、补码的扩展都是直接在符号位0和原数值位之间添0，正小数则在尾部添加0

2.2.2.4.2. 负整数原码直接在符号位1和原数值位之间添0，反码和补码则添加1，负小数原码和补码在尾部添0，负小数在尾部添1 

2.2.2.5.  溢出概念和判别方法 Overflow

2.2.2.5.1. 溢出概念：运算结果超出了数的表示范围。只有“正数+正数”才会上溢—正+正=负；只有“负数+负数”才会下溢—负+负=正 

2.2.2.5.2. 判别方法

2.2.2.5.2.1. 采用一位符号位：设  为运算结果符号，设溢出逻辑表达式为   ，若V=0，表示无溢出，若V=1，表示有溢出

2.2.2.5.2.2. 采用一位符号位根据数据位的进位情况判断溢出：设  为符号位的进位，  为最高数位的进位，则溢出逻辑判断式为  。若V=0，表示无溢出；若V=1，表示有溢出。

2.2.2.5.2.3. 采用双符号位：正数符号为00，负数符号为11，若运算结果两个符号位不同则溢出，溢出逻辑判断式为 

2.2.2.6.  定点数的乘法运算  

2.2.2.6.1. 原码乘法（一位乘法）Booth Algorithm   

2.2.2.6.2. 补码乘法

2.2.2.7.  定点数的除法运算

2.2.2.7.1. 原码除法

2.2.2.7.1.1. 恢复余数法 Restoring division algorithm

2.2.2.7.1.2. 加减交替法（不恢复余数法）Non-resotring division algortihm

2.2.2.7.2. 补码除法：加减交替法

2.2.3.   C语言中的整数类型及类型转换：C语言中定点整数使用补码存储的

2.2.3.1.  有符号数和无符号数的转换：不改变数据内容，改变解释方式

2.2.3.2.  不同字长整数之间的转换

2.2.3.2.1. 长整数变短整数：高位截断，保留地位

2.2.3.2.2. 短整数变长整数：符号扩展

2.2.4.   数据的存储和排列

2.2.4.1.  数据的“大端方式”和“小端方式”存储：LSB Least Significant Bit 最低有效字节/MSB Mosts Significant Bit 最高有效字节

2.2.4.1.1. 大端方式 Big endian：便于人类阅读

2.2.4.1.2. 小端方式 Little endian：便于机器处理

2.2.4.2.  数据按“边界对齐”方式存储：现代计算机通常是按字节编址，即每个字节对应1个地址。通常也支持按字、按半字、按字节寻址。假设存储字长为32为，则1个字=32bit，半字=16bit。每次访存只能读/写一个字

2.3.  浮点数的表示与运算

2.3.1.   浮点数的表示

2.3.1.1.  浮点数的作用和基本原理

2.3.1.1.1. 作用：定点数可表示的数字范围有限，不可能无限制地增加数据长度。

2.3.1.1.2. 表示方法   ：阶码E反应浮点数的表示范围及小数点的实际位置，阶码的底通常为2，阶码是常用补码或移码表示的整数；尾数M的数值部分的位数n反应浮点数的精度，尾数是常用原码或补码表示的小数  

2.3.1.2.  浮点数规格化：规定尾数的最高数值位必须是一个有效值

2.3.1.2.1. 左规：当浮点数运算的结果为非规格化时要进行规格化处理，将尾数算数左移一位，阶码减1

2.3.1.2.2. 右规：当浮点数运算的结果尾数出现溢出（双符号位为01或10）时，将尾数算数右移一位，阶码加1。采用双符号位，当溢出发生时，可以挽救，更高的符号位是正确的符号位

2.3.1.2.3. 规格化浮点数的特点

2.3.1.2.3.1. 用原码表示：最高位数值位必须是有效值

2.3.1.2.3.1.1. 正数为0.1XXX的形式，其最大值为0.11…1，最小值为 0.10…0。尾数的表示范围是 

2.3.1.2.3.1.2. 负数为1.1XXX的形式，其最大值为1.10…0，最小值为 1.11…1。尾数的表示范围是 

2.3.1.2.3.2. 用补码表示：规格化的补码尾数，符号位与最高数值位一定相反

2.3.1.2.3.2.1. 正数与原码一样

2.3.1.2.3.2.2. 负数为0.1XXX的形式，符号位和最高数值为要相反，通过这个规定可以使计算机硬件很快地判断浮点数是否已规格化。其最大值为1.01…1，最小值为1.00…0，尾数的表示范围为 

2.3.1.3.  浮点数的表示范围

2.3.1.4.  IEEE 754 标准  

2.3.2.   浮点数的加减运算

2.3.2.1.  对阶

2.3.2.2.  尾数求和

2.3.2.3.  规格化

2.3.2.4.  舍入

2.3.2.4.1. 0舍1入法：类似于十进制数运算中的四舍五入法，即在尾数右移时，被移去的最高数值位为0，则舍去；为1则在尾数的末尾加1.这样做可能会使尾数又溢出，此时需再做一次右规

2.3.2.4.2. 恒置1法：尾数右移时，不论丢掉的最高数值位是1还是0，都使右移后的尾数末尾横置1。这种方法同样有使尾数变大和变小的两种可能

2.3.2.5.  溢出判断

2.3.2.6.  C语言中的浮点数类型及类型转换

2.4.  算术逻辑单元 ALU

2.4.1.   串行加法器和并行加法器

2.4.1.1.  一位全加器 One bit full adder

2.4.1.1.1. 和表达式： 

2.4.1.1.2. 进位表达式：  

2.4.1.2.  串行全加器 Serial adder

2.4.1.3.  并行全加器Parallel adder

2.4.1.3.1. 串行进位：进位信号逐级形成

2.4.1.3.2. 并行进位

# 存储系统

3.1.  存储器概述

3.1.1.   存储器的分类

3.1.1.1.  按在计算机中的作用/层次分类

3.1.1.1.1. 主存储器

3.1.1.1.2. 辅助存储器

3.1.1.1.3. 高速缓冲存储器 Cache

3.1.1.2.  按存储介质分

3.1.1.2.1. 磁表面存储器

3.1.1.2.2. 磁心存储器半导体存储器

3.1.1.2.3. 光存储器

3.1.1.3.  按存取方式分类

3.1.1.3.1. 半导体随机存储

3.1.1.3.1.1. 随机存储器 RAM

3.1.1.3.1.2. 只读存储器 ROM

3.1.1.3.2. 串行访问存储器

3.1.1.3.2.1. 顺序存取：磁带

3.1.1.3.2.2. 直接存取：磁盘

3.1.1.4.  按信息的可保存性分类

3.1.2.   存储器的性能指标 

3.1.2.1.  存储容量=存储字数*字长

3.1.2.2.  单位成本：每位价格=总成本/总容量

3.1.2.3.  存储速度：数据传输率=数据的宽度/存储周期

3.1.2.3.1. 存储时间   ：存取时间是指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间

3.1.2.3.2. 存取周期   ：存取周期又称读写周期或访问周期。它是指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（读或写操作）之间所需的最小时间间隔

3.1.2.3.3. 主存带宽   ：主存带宽又称数据传输率，表示每秒从主存进出信息的最大数量

3.1.3.   主存简单模型 

3.1.3.1.  存储矩阵：由大量相同的位存储单元阵列构成

3.1.3.2.  译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，将信号在读写电路的配合下完成对选中单元的读/写操作。因为两个存储单元不能同时写入数据，因此直接使用n位选片信号来表示地址会产生大量冗余，因此用译码器进行过渡。同时因为一个选片信号要控制n个存储元的开或关们需要使用驱动来提高译码器端口的信号。

3.1.3.3.  读写电路：包括读出放大器和写入电路，用来完成读/写操作

3.1.3.4.  读/写控制线 Read/Write control line：决定芯片进行读/写操作

3.1.3.4.1. 读写共用一根线

3.1.3.4.2. 读写用分开的两根线

3.1.3.5.  片选线 Chip select line：作为存储器的开关。可用于容量扩充

3.1.3.6.  地址线 Address line：单向输入， 其位数与存储字的个数有关

3.1.3.7.  数据线 Data line：双向，其位数与读出或写入数据位数有关

3.1.4.   寻址 

3.2.  存储器的层次化结构   

3.3.  半导体存储器

3.3.1.   随机存储器Random-Access Memory SRAM和DRAM

3.3.1.1.  SRAM Static Random Access Memory

3.3.1.1.1. 工作原理

3.3.1.1.2. 读写操作

3.3.1.2.  DRAM Dynamic Random Access Memory

3.3.1.2.1. 工作原理

3.3.1.2.2. 刷新 Refresh：假设DRAM内部结构排列成128*128的形式，读/写周期0.5us。2ms刷新一次，因此需要2ms/0.5us=4000周期。刷新是存储器内部过程，不需要CPU控制。

3.3.1.2.2.1. 以行为单位，每次刷新一行存储单元（使用行列式存储方式是为了节省选通线）。有硬件支持，读出一行额信息后重新写入，占用1个读/写周期。

3.3.1.2.2.2. 刷新方式

3.3.1.2.2.2.1. 分散刷新 Scatter refresh：每次读写玩都刷新一行，系统的存取周期变为1us，前0.5us时间用于正常读写，后0.5us用于刷新某行 

3.3.1.2.2.2.2. 集中刷新 Focus-on refresh：2ms内集中安排时间全部刷新，系统的存取周期还是0.5us，有一段时间专门用于刷新，无法访问存储器，称为方寸“死区” 

3.3.1.2.2.2.3. 异步刷新 Asynchronous refresh：2ms内每行刷新一次即可，2ms内需要产生128此刷新请求，每隔2ms/128=15.6us一次，每15.6us内有0.5us的死区 

3.3.1.3.  比较 

3.3.2.   只读存储器Read-only Memory ROM

3.4.  主存储器与CPU的连接

3.4.1.   主存容量的扩展

3.4.1.1.  位扩展法 

3.4.1.2.  字扩展法  

3.4.1.2.1. 线选法：n条地址线产生n个选片信号，电路简单，但地址空间不连续，不能充分利用系统的存储器空间，造成地址资源的浪费

3.4.1.2.2. 译码片选法：n条线产生  个选片信号，电路复杂，但地址空间可连续，可以增加逻辑设计

3.4.1.3.  字位同时扩展法

3.4.2.   存储器与CPU的连接

3.5.  双端口RAM和多模块存储器

3.5.1.   双端口RAM：置“忙”信号为0，由判断逻辑决定暂时关闭一个端口（即被延时），未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问 

3.5.2.   多模块存储器

3.5.2.1.  单体多字存储器：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显

3.5.2.2.  多体并行存储器：每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器

3.5.2.2.1. 高位交叉编址：总是现在一个模块内访问，等到该模块访问完才转到下一个模块访问，存储模块内不能被并行访问，因而不能提高存储器的吞吐率

3.5.2.2.2. 低位交叉编址：流水线工作，连续存取n个字耗时=  ，条件是  

3.5.2.2.2.1.    

3.5.2.2.2.2.    

3.5.2.2.2.3.    

3.6.  高速缓冲存储器 

3.6.1.   程序访问的局部性原理

3.6.1.1.  空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是邻近的

3.6.1.2.  时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息

3.6.2.   Cache的基本工作原理

3.6.2.1.  工作原理

3.6.2.1.1. 局部性原理

3.6.2.1.1.1. 空间局部性：在最近的未来要用到的信息（指令和数据），很可能与现在正在使用的信息在存储空间上是临近的

3.6.2.1.1.2. 时间局部性：在最近的未来要用到的信息，很可能是现在正在使用的信息

3.6.2.2.  性能分析

3.6.2.2.1. 命中率与失效率：命中率H：CPU欲访问的信息已在Cache中的比率，设一个程序执行期间，Cache的总命中次数为  ，访问主存的总次数为  ，则  ；失效率为 

3.6.2.2.2. Cache-主存体系的平均访问时间  ：设  为命中时的Cache访问时间，  为未命中时的访问时间； 

3.6.3.   Cache和主存的映射方式 Mapping

3.6.3.1.  Fully associative mapping 全相联映射：空位随意放。 

3.6.3.2.  Direct mapping 直接映射：对号入座。 

3.6.3.3.  Set associative mapping 组相联映射：按号分组，组内随意放。 

3.6.4.   Cache中主存块的替换算法

3.6.4.1.  RAND随意算法：随机地确定替换的Cache块，它的实现比较简单，但没有依据程序访问的局部性原理，故可能命中率较低

3.6.4.2.  FIFO先进先出算法：选择最早调入的行进行替换。它比较容易实现，但也没有依据程序访问的局部性原理，可能会把一些需要经常使用的程序块（如循环程序）也作为最早进入Cache的块替换掉

3.6.4.3.  LRU近期最少使用算法：依据程序访问的局部性原理选择近期内长久未访问过的存储行作为替换的行，平均命中率要比FIFO高，是堆栈类算法。LRU算法对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计数器加1，需要替换时比较各特定行的计数值，将计数值最大的行换出

3.6.4.4.  LUF最不经常使用算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换时比较各特定行的计数值，将计数值最小的行换出

3.6.5.   Cache写策略

3.6.5.1.  命中

3.6.5.1.1. Write-through 全写法/写直通法：当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲write buffer 

3.6.5.1.2. Write-back 写回法：把主存中的块调入Cache，在Cache中修改，添加一个数据脏位 

3.6.5.2.  不命中

3.6.5.2.1. Write-allocate 写分配法：把主存中的块调入Cache，在Cache中修改。搭配写回法使用

3.6.5.2.2. Not-wirte-allocate 非写分配法：只写入主存，不调入Cache。搭配全写法使用

3.7.  虚拟存储器：一个逻辑模型

3.7.1.   虚拟存储器的基本概念

3.7.1.1.  功能：用户给出一个地址，叫做虚地址或逻辑基地，虚拟存储器要给出该地址对应的数据

3.7.1.2.  实现：由辅助硬件将虚地址映射到主存当中的某个单元，主存单元地址称为实地址或物理地址

3.7.2.   页式虚拟存储器：虚拟空间与主存空间都被划分成同样大小的页，主存的页称为实页，虚存的页称为虚页

3.7.3.   快表TLB：加快地址转换；页表、段表存放在主存中，收到虚拟地址后要先访问主存，查询页表、段表，进行虚实地址转换，放在主存中的页表称为慢表 Page

3.7.4.   段式虚拟存储器

3.7.5.   段页式虚拟存储器  

# 指令系统

4.1.  指令格式

4.1.1.   指定定义：指令又称机器指令，是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。一台计算机的所有指令的集合构成该机的指令系统，也称为指令集。一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令

4.1.2.   指令的基本格式

4.1.2.1.  零地址指令

4.1.2.2.  一地址指令

4.1.2.3.  二地址指令

4.1.2.4.  三地址指令

4.1.2.5.  四地址指令

4.1.3.   定长操作码指令格式

4.1.4.   不定长操作码/扩展操作码指令格式

4.1.4.1.  不允许短码是长码的前缀，即短操作码不能与长操作码的前面部分的代码相同

4.1.4.2.  各指令的操作码一定不能重复

4.2.  指令的寻址方式

4.2.1.   任务

4.2.1.1.  给出下一条指令的地址

4.2.1.2.  给出要操作的对象的地址

4.2.2.   指令寻址和数据寻址

4.2.2.1.  指令寻址

4.2.2.1.1. 顺序寻址方式

4.2.2.1.2. 跳跃寻址方式

4.2.2.2.  数据寻址

4.2.3.   常见的数据导址方式

4.2.3.1.  隐含寻址

4.2.3.2.  立即（数）寻址

4.2.3.3.  直接寻址

4.2.3.4.  间接寻址

4.2.3.5.  寄存器寻址

4.2.3.6.  寄存器间接寻址

4.2.3.7.  相对寻址

4.2.3.8.  基址寻址

4.2.3.9.  变址寻址

4.2.3.10.偏移寻址

4.2.3.11.堆栈寻址

4.3.  CISC和RISC

4.3.1.   Complex Instruction Set Compter CISC 复杂指令系统计算机：一条指令完成一个复杂的基本功能。代表为X86架构，主要用于笔记本、台式机等

4.3.2.   Reduced Instruction Set Computer RISC 精简指令系统计算机：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能。代表为ARM架构，主要用于手机、平板等

4.3.3.   比较 

# 中央处理器

5.1.  CPU的功能和基本结构

5.1.1.   功能

5.1.1.1.  指令控制：完成取指令、分析指令和执行指令的操作，即顺序的顺序控制

5.1.1.2.  操作控制：一条指令的功能往往是由若干操作信号的组合来实现的。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作

5.1.1.3.  时间控制：对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号

5.1.1.4.  数据加工：对数据进行算数和逻辑运算

5.1.1.5.  中断处理：对计算机运行过程中出现的异常情况和特殊请求进行处理

5.1.2.   基本结构

5.2.  指令执行过程

5.3.  数据通路的功能和基本结构

5.3.1.   CPU内部单总线方式

5.3.2.   专用数据通路

5.4.  控制器的功能和工作原理

5.4.1.   控制器的结构和功能

5.4.2.   硬布线控制器

5.4.3.   微程序控制器

5.5.  指令流水线

# Bus 总线 

6.1.  总线概述

6.1.1.   总线的概念与分类

6.1.1.1.  概念：总线是一组能为多个部件分时共享的公共信息传送线路。早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备，为了更好地解决IO设备和主机之间连接地灵活性问题，计算机的结构从分散连接发展为总线连接。

6.1.1.1.1. 共享是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路分时共享

6.1.1.1.2. 分时是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息

6.1.1.2.  分类

6.1.1.2.1. 按数据传输格式

6.1.1.2.1.1. 串行总线

6.1.1.2.1.1.1. 优点：只需要一条传输线，成本低廉，广泛应用于长距离传输，应用于计算机内部时，可以节省布线空间

6.1.1.2.1.1.2. 缺点：在数据发送和接收的时候要进行拆卸和装配，要考虑串行并行转换的问题

6.1.1.2.1.2. 并行总线

6.1.1.2.1.2.1. 优点：总线的逻辑时序比较简单，电路实现起来比较容易

6.1.1.2.1.2.2. 缺点：信号线数量多，占用更高的布线空间，远距离传输成本高昂。由于工作频率较高时，并行的信号线之间会产生严重干扰，对每条线等长的要求也越高，所以无法持续提升工作频率。总线带宽受工作频率影响，因此并行传输速度不一定比串行高。

6.1.1.2.2. 按总线功能（连接的部件）

6.1.1.2.2.1. 片内总线：芯片内部的总线，它是CPU芯片内部寄存器与寄存器之间、寄存器与ALU之间的公共连接线

6.1.1.2.2.2. 系统总线：是计算机系统内各功能部件（CPU、主存、IO接口）之间相互连接的总线。

6.1.1.2.2.2.1. 数据总线：传输各功能部件之间的数据信息，包括指令和操作数，位数（根数）与机器字长、存储字长有关，是双向的

6.1.1.2.2.2.2. 地址总线：传输地址信息，包括主存单元或IO端口的地址，位数（根数）与主存地址空间大小及设备数量有关，是单向的

6.1.1.2.2.2.3. 控制总线：一根控制线传输一个信号，输出CPU送出的控制信号，输入主存或外设返回CPU的反馈信号

6.1.1.2.2.3. 通信总线：是用于计算机系统之间或计算机系统与其他系统（如远程通信设备、测试设备）之间信息传送的总线，通信总线也称为外部总线

6.1.1.2.3. 按时序控制方式

6.1.1.2.3.1. 同步总线

6.1.1.2.3.2. 异步总线

6.1.2.   系统总线的结构

6.1.2.1.  单总线结构

6.1.2.2.  双总线结构

6.1.2.3.  三总线结构

6.1.2.4.  四总线结构

6.1.3.   总线的性能指标

6.1.3.1.  总线的传输周期：一次总线操作（包括申请阶段、寻址阶段、传输阶段和结束阶段），通常由若干个总线时钟周期构成

6.1.3.2.  总线的时钟周期：即机器的时钟周期，计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制。时钟周期是标准单位。

6.1.3.3.  总线的工作频率：总线上各种操作的频率，为总线周期的倒数。实际上指一秒内传送几次数据

6.1.3.4.  总线的时钟频率：时钟周期的倒数

6.1.3.5.  Bus width 总线宽度：总线上能够同时传输的数据位数，通常指数据总线的根数

6.1.3.6.  Bandwidth 总线带宽：可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节/秒B/s表示。总线带宽=总线工作频率*总线宽度(bit/s)。总线带宽是指总线本身所能达到的最高传输速率，在计算实际的**有效数据传输率**时，要用实际传输的数据量除以耗时

6.1.3.7.  总线复用：一种信号线在不同的时间传输更多的信息，从而节省了空间和成本

6.1.3.8.  信号线数：地址总线、数据总线和控制总线3种总线数的综合称为信号线数

6.2.  Bus arbitration 总线仲裁：解决多个设别争用总线的问题

6.2.1.   定义：多个主设备同时竞争主线控制权时，以某种方式选择一个主设备优先获得总线控制权称为总线仲裁

6.2.2.   分类

6.2.2.1.  集中仲裁方式

6.2.2.1.1. 链式查询方式

6.2.2.1.2. 计数器查询方式

6.2.2.1.3. 独立请求方式

6.2.2.2.  分布仲裁方式：不需要中央仲裁器，每个潜在的主模块都有自己的仲裁器和仲裁号，多个仲裁器竞争使用总线

6.3.  总线操作和定时

6.3.1.   总线传输的四个阶段

6.3.1.1.  申请分配阶段：由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构决定将下一传输周期的总线使用权授予某一申请者。

6.3.1.2.  寻址阶段：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块

6.3.1.3.  传输阶段：主模块和从模块进行数据交换，可单向或双向进行数据传送

6.3.1.4.  结束阶段：主模块的有关信息均从系统总线上撤除，让出总线使用权

6.3.2.   定时方式

6.3.2.1.  Synchronizing Timer同步定时/同步通信：系统采用一个统一的时钟信号来协调发送和接受双方的传送定时关系。时钟产生相等的时间间隔，每个间隔构成一个总线周期。发送方用系统时钟前沿发信号，接受方用系统时钟后沿判断、识别

6.3.2.1.1. 优点：传送速度快，具有较高的传输速率，总线控制逻辑简单

6.3.2.1.2. 缺点：主从设备属于强制性同步，不能及时进行数据通信的有效性检验，可靠性较差

6.3.2.1.3. 适用于总线长度较短及总线所接部件的存取时间比较接近的系统

6.3.2.2.  Asynchronizing Timer 异步定时/异步通信：没有统一的时钟，也没有固定的时间间隔，完全依靠传送双方相互制约的“握手”信号来实现定时控制，允许不同速度的模块和谐工作

6.3.2.2.1. 应答方式

6.3.2.2.1.1. 不互锁方式（根据“请求”和“回答”信号的撤销是否互锁）：经过一段时间后，自动撤销请求和回答信号。速度最快，可靠性最差。

6.3.2.2.1.2. 半互锁方式：请求信号需要等到回答信号的应答后才会撤销，而回答信号则无需等待自动撤销

6.3.2.2.1.3. 全互锁方式：请求和回答信号均需要得到应答后才会撤销。最可靠但速度最慢

6.3.2.2.2. 特点

6.3.2.2.2.1. 优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间地配合

6.3.2.2.2.2. 缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢

6.3.2.3.  半同步通信：统一时钟的基础上，增加一个“等待”相应信号WAIT

6.3.2.4.  分离式通信：各模块均有权申请占用总线

6.4.  总线标准：易于实现系统的模块化设计 

6.4.1.   局部总线：ISA，EISA，PCI，AGP（显卡专用的局部总线），PCI-E, VESA

6.4.2.   设备总线：USB，RS-232C，IDE，SATA，SCSI

6.4.3.   补充视频线标准：VGA，DVI，HDMI，

# 输入/输出系统

7.1.  IO系统基本概念

7.2.  外部设备

7.2.1.   输入设备

7.2.2.   输出设备

7.2.3.   外存储器

7.3.  IO接口

7.4.  IO方式

7.4.1.   程序查询方式

7.4.2.   中断系统

7.4.3.   程序中断方式

7.4.4.   DMA方式