<https://course.ece.cmu.edu/~ece447/s15/doku.php?id=start>

<https://www.elsevier.com/books-and-journals/book-companion/9780128122754>

关于的关系：国外的计算机专业 是如何教《计算机组成原理》这门课的？ - Zack的回答 - 知乎 <https://www.zhihu.com/question/38838088/answer/78368713>

《微机原理与接口技术》和《计算机组成原理》、《计算机体系结构》三门课程有什么区别？先后修的顺序应该是怎么样的？研究操作系统需要学习哪门课程？ - 知乎用户的回答 - 知乎 <https://www.zhihu.com/question/19954019/answer/427424135>

学习顺序：模拟电路 `->` 数字电路 `->` 计算机组成原理 `->` 计算机体系结构 or 微机原理与接口技术

CSAPP是计算机组成原理、计算机结构体系 Computer Architecture、编译原理、操作系统的导论课

计算机组成原理：组成原理关键在cpu和计算机是怎么设计的，cpu中的控制器和机器指令Q怎么设计的。不考虑性能，只考虑原理，硬件如何设计，机器指令如何设计，不具体特指某一个CPU，同时也涉及存储器的层次结构原理

计算机结构体系：系统分析如何设计CPU会提高性能、如何设计指令集能提高性能、如何设计计算机的整体性能来提高性能

微机原理与接口技术

* 微机原理关键是使用和学习某个已经设计好的cpu（x86、ARM、MIPS、POWERPC等架构），如何设计具体的应用系统，包括汇编语言的学习
* 接口技术，学习各种接口的原理，与某个cpu组成具体的应用，设计接口硬件并编程对接口操作，并了解当前微机的体系结构

# 量化设计与分析基础

## *intro*

### 什么是Computer Architecture？

**Computer Architecture 计算机体系结构**是指计算机系统中各个组件的结构、功能和互联方式，以及它们如何共同协作以实现数据处理和运算任务的方法和规范。计算机体系结构涉及到硬件和软件之间的接口 Interface between SW and HW，以及如何有效地组织硬件资源来实现高性能、高效率的计算

计算机体系结构包括以下几个关键方面：

1. **指令集架构（Instruction Set Architecture，ISA）**：指令集架构定义了处理器能够理解和执行的指令集合，包括操作码、寄存器、地址模式等。ISA 是硬件和软件之间的重要接口，不同的计算机体系结构有不同的指令集架构
2. **内存层次结构**：计算机的内存层次结构包括多级缓存和主存，这些层次的设计影响了数据访问速度和性能。高速缓存被用来存储最常用的数据，以减少处理器访问主存的延迟
3. **处理器结构**：处理器结构涉及到处理器的核心数、流水线设计、并行处理能力等。现代处理器常常具备多核心、超线程等功能，以实现更高的并行处理能力
4. **总线结构**：总线是连接计算机内部各个组件的通信通道，包括数据总线、地址总线和控制总线。总线的设计影响了各个组件之间数据传输的速度和效率
5. **输入输出（I/O）系统**：I/O 系统包括与计算机外部设备进行通信的方式和接口，如网络接口、磁盘控制器等
6. **中断和异常处理机制**：这些机制允许计算机在运行过程中响应外部事件，如硬件错误、输入输出请求等，以保持系统的稳定性和可靠性

计算机体系结构的设计旨在平衡性能、功耗、成本和可扩展性等方面的需求。不同的计算机体系结构在不同的应用场景下可能表现出更适合的特点，例如高性能计算、嵌入式系统、移动设备等

### Computer Architecture的8个伟大思想

1. 面向摩尔定律的设计

2. 使用抽象简化设计 abstraction

3. 加速经常性事件 make the common case fast

   通过试验来确定系统中哪些是经常性事件，哪些是罕见事件。经常性事件往往比罕见事件简单，因此通过优化经常性事件可以有效地改善系统性能

4. 通过并行提高性能 parallellism

5. 通过流水线提高性能 pipelining

6. 通过预测提高性能 prediction

7. 存储层次

8. 通过冗余提高可靠性

## *计算机性能*

指令平均时钟周期数 clock cycle per instruction CPI 表示执行每条指令所需的时钟周期平均数

## *单核向多核的跨越*

### 功耗墙 Power wall

$$
功耗\propto\frac{1}{2}\times负载电压\times电压^2\times开关频率
$$

### 多核时代

为了避免处理器 Processor 和微处理器 Microprocessor的混淆，又将处理器称之为一个核 core。例：在一个微处理器中有4个处理器/核心，那么将这个微处理器称为4核芯片/4核微处理器（其中一个处理器是一个数据通路/运算器+一个控制器）

# 信息的表示和处理

## *信息存储*

### 进制间转换方式

速记：$x$ 是2的非负整数 $n$ 次幂时，即 $x=2^n$ 时，$x$ 对应的二进制表示就是1后面跟 $n$ 个0；对于16进制数，$n=i+4j,\ 0\leq i\leq3$，$x$ 开头的数字为 $1(i=0),\ 2(i=1),\ 4(i=2),\ 8(i=3)$，后面跟着 $j$ 个十六进制的0

<img src="进制转换关系.jpg" width="60%">

十进制 $x$ 转十六进制：可以反复地用16除 $x$，得到一个商 $q$ 和一个余数 $r$，即 $x=q\cdot16+r$，不断对 $q$ 重复这个过程，最先得到的 $r$ 是低位，最后得到的 $r$ 是高位，将 $r$ 从高到低排列出来就得到转换的十六进制数。十进制转二进制同理，只是反复地用2除 $x$

### 字节顺序（大小端）

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/大小端.png" width="45%">

* 什么是大端和小端

  * 大端 Big endian：**低地址高字节**，即**数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中**，比较符合阅读习惯
  * 小端 Little endian：**低地址低字节**

* 判断内存是以大端存储还是小端存储

  * 利用指针

    ```c
    int i = 1; // 01 00 00 00
    if (1 == *(char*)&i) // 将int*强制转换成char*后对该指针解引用，char*只能得到1字节的内存
        printf("Little endian\n");
    else
        printf("Big endian\n");
    ```

  * 利用联合体

    ```c
    int CheckSys()
    {
        union Un
        {
            char c;
            int i;
        }u;
    
        u.i = 1;
        return u.c; // 两者共用地址，若是小端则返回1，否则返回0
    }
    ```

## *整数表示*

### 整型数据类型

C语言标准定义了每种数据类型必须能够表示的**最小的取值范围**

### 无符号数的编码

设一个有 $w$ 位的整数数据类型，有位向量 $\vec{x}=\left[x_{w-1},x_{w-2},\cdots,x_{0}\right]$，其中每个位 $x_i$ 的取值为0或1。用一个函数 $B2U_w$ Binary to Unsigned 来表示从二进制到无符号数
$$
B2U_w\left(\vec{x}\right)\triangleq\sum\limits_{i=0}^{w-1}{x_i2^i}
$$
一个 $w$ 为的二进制位向量 $\vec{x}$ 可以表示的最大无符号数为 $UMax_w$，它的二进制为 $\left[11\cdots1\right]_w$
$$
UMax_w\triangleq\sum\limits_{i=0}^{w-1}{2^i}=2^w-1
$$
无符号数编码具有唯一性，因为 $B2U_w$ 是一个双射 bijection，即可以进行反向操作从无符号数唯一映射到二进制，用函数 $U2B_w$ 来表示。关于溢出 overflow 的问题写在下面整数加法的小段里

### 补码 two's-complement

C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的

这里要理清一个概念：用补码还是原码来表示一个数是**语言层次的概念**（高级语言和机器语言），对于计算机而言是无所谓的，都是二进制串。数据的类型通常是通过程序中的变量类型来指定的。变量类型告诉计算机如何对二进制串进行解释，以及如何对其进行运算。CPU的硬件通过指令中的操作码、操作数和前缀等信息来识别有符号数和无符号数，并根据不同的类型选择适当的运算方法和指令

为了表示负数，引入了原码 Sign and Magnitude（用最高位表示符号位，其他位表示大小）、反码 Ones' complemen（整数和原码相同，其他位取反）t 和补码表示。因为原码和反码对0的表示有两种和其他原因，补码是最好的选择

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/机器码转换关系.jpg" width="50%">

用补码来表示有符号数时，可以直接使用和无符号数一样的加法电路，所以不用额外设计电路，简化了硬件。如果使用原码进行两个正数之间的减法运算，还需要使用单独设计减法电路并且使用比较电路来决定谁大谁小，这非常低效。**设计补码的初衷是为了便利减法运算**，这是因为**减去一个数的原码等于加上它的补码**。考虑下面两个例子

* 钟表上是10点，要回到5点，既可以回拨/减去5小时，也可以前拨/加上7小时，这是因为在12小时进制中，7是-5对模12的补数
* 对于4位2进制数

$$
B_{comp}=\left\{\begin{array}{cl}B&,B\geq0\\2^n-B&,B<0\end{array}\right.
$$

补码的最高有效位 $x_{w-1}$ 称为符号位 sign bit，被解释为负权 negative weight，它的权重为 $-2^{w-1}$。用函数 $B2T_w$ Binary to Two's-complement 定义
$$
B2T_w\left(\vec{x}\right)\triangleq-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}{x_i2^i}
$$
补码能表示的最小值是位向量 $\left[10\cdots0\right]_w$，最小整数值是 $TMin_w=-2^{w-1}$；最大值的位向量是 $\left[01\cdots1\right]_w$，最大整数值为 $TMax_w=\sum\limits_{i=0}^{w-2}{2^i}=2^{w-1}-1$ 

* $B2T_w$ 是一个双射，是从 $TMin_w$ 到 $TMax_w$ 之间的映射，即 $B2T_w:\left\{0,1\right\}^w\rightarrow\left\{TMin_w,\cdots,TMax_w\right\}$。它的反函数为 $T2B_w$
* 不对称性：$\lvert TMin\rvert=\lvert TMax\rvert+1$，因为一半的位模式用来表示负数，而另一半则用来表示0和正数
* $UMax_w=2TMax_w+1$

### 有符号数和无符号数之间的转换

强制类型转换的结果保持**位值不变，只是改变了解释这些位的方式**。C语言中有符号数和无符号数运算的时候，有符号数会被隐式转换为无符号数
$$
T2U_w(x)\triangleq B2U_w\left(T2B_w(x)\right),\ x\in\left[TMin_w,TMax_w\right]\\U2T_w(x)\triangleq B2T_w\left(U2B_w(x)\right),\ x\in\left[0,UMax_w\right]
$$
<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/补码与无符号数之间的转换.png" width="50%">

上图给出了补码与无符号数相互转换以及各自溢出回绕的情况。特别注意对应关系：-1和 $UMax$，它们的位模式都为全1

给定位模式的补码与无符号数之间的关系可以表示为函数 $T2U_w$ 和函数 $U2T_w$
$$
T2U_w(x)=\left\{\begin{array}{cc}x+2^w,&x<0\\x,&x\geq0\end{array}\right.\\U2T_w(x)=\left\{\begin{array}{cc}u,&u\leq TMax_w\\u-2^w,&u>TMax_w\end{array}\right.
$$

### 扩展位

* 无符号数的0扩展 zero extension 高位添0
* 补码数的符号扩展：高位添符号位

$$
B2T_{w+k}\left(\left[\underbrace{x_{w-1},\cdots,x_{w-1}}_{k\ times},x_{w-1},x_{w-2},\cdots,x_0\right]\right)=B2T_w\left(\left[x_{w-1},x_{w-2},\cdots,x_0\right]\right)
$$

### 截断 truncating

* 截断无符号数
  $$
  B2U_w\left(\left[x_{w-1},x_{w-2},\cdots,x_0\right]\right)\mod{2^k}=B2U_w\left(\left[x_{k-1},x_{k-2},\cdots,x_0\right]\right)
  $$

* 截断补码数：和截断无符号数一样，但要将最高位转换为符号位
  $$
  B2T_k\left(\left[x_{k-1},x_{k-2},\cdots,x_0\right]\right)=U2T_k\left(B2U_w\left(\left[x_{w-1},x_{w-2},\cdots,x_0\right]\right)\mod{2^k}\right)
  $$

## *整数运算*

### 无符号加法

无符号数原码的算数运算溢出 overflow/Überlauf：**完整的整数结果不能放到数据类型的字长限制中去**

对于两个无符号数 $x$ 和 $y$，因为它们能表示的无符号最大值为 $UMax_w=2^w-1$，所以 $\geq2^w$ 的值会被截断，相当于是 $\mod{2^w}$。定义无符号数加法 $+_w^u$
$$
x+_w^uy=\left\{\begin{array}{cc}x+y,&x+y<2^w\\x+y-2^w,&2^w\leq x+y\leq2^{w+1}\end{array}\right.
$$
上式中的溢出也可以表示为 $\left(x+y\right)\mod{2^w}$

### 补码加法

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/补码加法.png">

有符号数补码的算数运算溢出是**两个操作数的符号位同时发生改变**，有两种溢出情况

* 正溢出 positive overflow：正+正->负
* 负溢出 negative overflow：负+负->正

$$
x+_w^ty=\left\{\begin{array}{ccc}x+y-2^w,&2^{w-1}\leq x+y&positive\ overflow\\x+y,&-2^{w-1}\leq x+y<2^{w-1}&normal\\x+y+2^w,&x+y<-2^{w-1}&negative\ overflow\end{array}\right.=U2T_w\left[\left(x+y\right)\mod{2^w}\right]
$$

### 补码非

对 $TMin_w$ 的非操作要做出特殊规定，因为 $-TMin_w=TMax_w+1$，这会发生补码正溢。规定 $TMin$ 的非就是自身，因为 $TMin_w+TMin_w=2*-2^{w-1}=-2^w=0$ 。所以有
$$
-_w^tx=\left\{\begin{array}{ll}TMin_w,&x=TMin_w\\-x,&x>TMin_w\end{array}\right.
$$
<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/TMinDef.png">

求反的操作就是符号位不变，数值位取反，然后+1（对正数来说是原码求补码，求负数来说是补码求源码）

C语言中 `int` 的 $TMin$ 的定义为什么要写成 `(-INT_MAX - 1)` 的形式呢？因为编译器在解析 `-X` 的数据类型时，不会将其看作是一个整体，而是先翻译正数 `X`，再通过符号位不变，数值位取反，然后+1的方式求其补码。因为补码的非对称性，$\lvert TMin\rvert=\lvert TMax\rvert+1$，若直接写成 `-INT_MIN` 的形式，直接就溢出了

### 乘法

* 无符号乘法
  $$
  x\times\ ^u_wy=\left(x\times y\right)\mod{2^w}
  $$

* 补码乘法

* 乘常数

### 除法

## *浮点数*

### 二进制小数

$$
b=\sum\limits_{i=-n}^{m}{2^i\times b_i}
$$

浮点 `.` 的左边是2的正幂，右边是2的负幂，比如
$$
101.11_2=1\times2^2+0\times2^1+1\times2^0+1\times2^{-1}+1\times2^{-2}=5\frac{3}{4}
$$
正如十进制无法精确表示 $1/3$ 这类数一样，小数的二进制表达法也只能表示可以被写成 $x\times2^y$ 这样的数，其他的值只能够近似表达，增加二进制的长度可以提高精度。形如 $0.11\dots1_2$ 的数表示的是刚好小于1的数，可以用 $1.0-\varepsilon$ 来表示

手算浮点数的二进制转十进制就是上面的加权展开，十进制转二进制则先拆分整数部分和浮点数部分，整数部分和之前一样，对小数部分采用**乘2取整**法。若某次相乘得到整数就结束，否则就可以一直乘下去

### IEEE浮点数

用定点方式来存储浮点数是非常不方便的：有很多小数不能精确表达且影响了能够存储的数字的最大值。对此制定了IEEE浮点数标准，用一个三元组 $V=\left(s,E,M\right)$ 来表示浮点数
$$
V=\left(-1\right)^s\times M\times 2^E
$$

* 公式成分
  * 符号位 sign $s$，$s=0,1$ 分别表示正数和负数，而对于数值0的符号则作为特殊情况处理
  * 尾数 significand $M$，首字母来源于mantissa。它是一个二进制小数，范围是 $1\sim2-\varepsilon$ 或者 $0\sim1-\varepsilon$
  * 阶码 exponent $E$。它的做作用是对浮点数加权。这个权重是2的 $E$ 次幂
* 对浮点数的编码，将浮点数的位划分为三个字段。这套编码制度被称为移码 offset binary
  * 一个单独的符号位 $s$ 
  * $k$ 位阶码字段 $\exp=e_{k-1}e_{k-2}\cdots e_1e_0$ 编码阶码 $E$。**阶码表示的是2为base的幂的次数**（IEEE754以2为base，IEEE854扩展到10为base）
  * $n$ 位小数字段 $frac=f_{n-1}f_{n-2}\cdots f_1f_0$ 编码尾数 $M$，但尾数的值还取决于阶码 $\exp$。**尾数表示的是小数部分**

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/浮点数标准.png" width="50%">

上图中给出了IEEE 754的两种浮点数编码

* 32位单精度浮点数 single precision：$s$ 为1位，$k=8,\ n=23$ 
* 64位双精度浮点数 double precision：$s$ 为1位，$k=11,\ n=52$ 
* 80 bits Extended precision only for intel

**为什么用移码来表示浮点数而不是使用补码？**首先我们可以确定的是我们需要能够分辨阶数的正负，所以解码必须能够提供类似与补码那种可以取分正负的机制。使用移码是为了比较阶码的时候可以直接比较无符号数 $e$。若使用补码表示浮点数的阶码时，需要进行符号位判断，并根据符号位的值来确定阶码的实际值。这个额外的处理增加了计算的复杂性和延迟

### 根据 $\exp$ 来分类尾数 $M$

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/浮点数IEEE标准.png">

* 规格化 normalized：当 $\exp$ 的位模式既不全为0也不为全1
  * 阶码的值是 $E=e-Bias$，其中 $e$ 是无符号数，而 $Bias=2^{k-1}-1$ 的偏置
    * 单精度的表示范围是 $\left[1,254\right]-\left(2^7-1\right)=\left[-126,+127\right]$
    * 双精度的表示范围是 $\left[1,2046\right]-\left(2^{10}-1\right)=\left[-1022,+1023\right]$
  * 隐含的以1开头的表示 implied leading 1：$M=1+f$ ，即 $M$ 可以看作是一个表达式为 $1.f_{n-1}f_{n-2}\cdots f_{0}$ 的数字。可以通过调整阶码来调整尾数 $M$ 在 $1\leq M<2$ 之间

* 非规格化 denormalized：当 $\exp$ 的位模式为全0，可以用来表示0
  * 特点
    * Exponent 是 $E=1-Bias$，而不是 $E=0-Bias$，这样设计的目的是为了让非规格化值**平滑过渡**到规格值，非常巧妙的设计。可以看书上8位浮点数的例子
    * 没有隐含的1开头，即 $M=f$
  * 非规格化数的作用
    * 提供了一种表示数值0的方法
    * 表示那些非常接近于0.0的数

* 特殊值 special value：当 $\exp$ 的位模式为全1
  * 当小数字段是全0的时候，得到的值是 $-\infty$ 或 $+\infty$，用来表示两个非常大的数相乘，或者除数为0时表示溢出的结果
  * 若小数段不是全0，则得到的值是 $NaN$（Not a Number），表示没有合适的答案，比如对-1开方，$\infty-\infty$ 等情况

### 舍入 rounding

IEEE浮点格式定义了四种不同的舍入方式

* Nearest even **default** 向偶数舍入/向最近值舍入：小于一半向下，大于一半向上，正好一半向偶数舍入（四舍六入五取偶）。通过向偶数舍入可以避免造成统计值偏差
* Towards zero 向零舍入：正数向下舍入，负数向上舍入
* Round down 向下舍入 $-\infty$
* Round up 向上舍入 $+\infty$

### 浮点计算

* 浮点数加法
  * 对阶 exponent alignment：将指数较小的浮点数进行尾数向右移位，指数同步增大，直到两个操作数的指数等
  * 求和：对尾数求和
  * 规格化
    * If M ≥ 2, shift M right, increment E
    * if M < 1, shift M left k positions, decrement E by k
    * Overflow if E out of range
    * Round M to fit frac precision
* 浮点数乘法，步骤也是对阶、求和和规格化

因为需要对阶和rounding，浮点数计算满足交换律，但不满足结合率。比如对于单精度浮点数的加法 `(3.14 + 1e10)-1e10 -> 0` 和 `3.14+(1e10-1e10) -> 3.14` 的结果是不同的，前者 `3.14+1e10` 时，3.14直接被rounding掉了

自然现象中的变化程度基本不会达到2的7次方，因而前一时刻的浮点数可以和后一时刻的相加并且结果在预期内。但如果是非自然情况下，比如说金融行业中，就可能会出现不连续的数据变化（Bill Gates的资产 + 我的资产 = Bill Gates的资产Lol）

# 指令集

*CSAPP*中使用的是Intel x86指令集架构，而*computer organization and design the hardware/software interface*有MIPS、RISC-V和ARM三个版本，我使用了RISC-V版本

## *RISC vs. CISC*

### RISC

RISC Reduced Instruction Set Computer 精简指令集计算机： RISC架构的主要思想是通过精简指令集，使每个指令执行的时间更短，从而提高处理器的执行效率。RISC处理器通常有较少的指令类型，每种指令都被设计成能够在一个时钟周期内完成，这有助于提高流水线 pipeline 的效率。RISC处理器通常鼓励程序员使用更多的寄存器来存储中间结果，减少对内存的访问次数，从而提高性能

RISC架构的概念在20世纪80年代初开始引起关注，旨在通过简化指令集和优化硬件流水线来提高处理器的性能。最早的RISC架构之一是由IBM的研究员设计的IBM 801，但RISC的真正推广始于1980年代中期。加州大学伯克利分校的David Patterson研究团队在1980年代早期发布了一系列的RISC论文，这些论文强调了简化指令集、流水线和高速缓存等概念，对后来的RISC处理器设计产生了深远影响

> 精简指令集的名称最早来自1980年[大卫·帕特森](https://zh.wikipedia.org/wiki/大衛·帕特森_(學者))在[加州大学柏克莱分校](https://zh.wikipedia.org/wiki/加州大學柏克萊分校)主持的[Berkeley RISC](https://zh.wikipedia.org/w/index.php?title=Berkeley_RISC&action=edit&redlink=1)计划。但在他之前，已经有人提出类似的设计理念。由[约翰·科克](https://zh.wikipedia.org/wiki/約翰·科克)主持，在1975年开始，1980年完成的[IBM 801](https://zh.wikipedia.org/wiki/IBM_801)计划，可能是第一个使用精简指令集理念来设计的系统。-- wikipedia

1981年，在David Patterson的带领下，加州大学伯克利分校的一个研究团队起草了RISC-1，这就是今天RISC架构的基础。RISC-1原型芯片有44500个晶体管，拥有31条指令。包含78个32位寄存器，分为6个窗口，每个窗口包含14个寄存器，另外还有18个全局变量，寄存器占用大部分面积，控制和指令只占用芯片面积的6%，而同时代的芯片设计里要占用约50%的面积

### CISC

CISC Complex Instruction Set Computer 复杂指令集计算机： CISC架构的特点是指令集非常丰富和复杂，每个指令可以执行多种操作，甚至包括高级操作。这使得单个指令的执行可能需要多个时钟周期，但它们可以一次性完成复杂的任务。CISC处理器通常拥有更多的寻址模式和寄存器，允许程序员在一条指令中执行多个操作，这在某些情况下可以简化编程

CISC架构最早出现在上世纪50年代末和60年代初，当时的计算机处理器设计注重硬件效率，试图通过支持多功能和复杂的指令来减少程序员的工作量。这些指令可以执行多个操作，包括内存访问、算术运算、逻辑运算等，以便于编写高级语言的编译器生成**更紧凑的**机器语言。Intel的x86系列处理器就是CISC架构的代表，从最早的8086到后来的80286、80386等，一直延续到今天的x86-64架构

## *MIPS*

### 简介

* MIPS（Microprocessor without Interlocked Pipeline Stages）是一种经典的 RISC架构。它注重简单指令集和高性能设计。MIPS的中文直译为无内部互锁流水级的微处理器，其机制是**尽量利用软件办法避免流水线中的数据相关问题**
* MIPS 的指令集具有固定的指令格式，包括加载、存储、算术、逻辑和分支等指令
* 该架构在处理器设计中强调性能优化和流水线执行。它在多媒体、网络设备和嵌入式系统领域得到广泛应用

### 实际应用

MIPS技术市场分析 - 吴建明wujianming的文章 - 知乎 <https://zhuanlan.zhihu.com/p/515475193>

1984年，斯坦福大学前校长John LeRoy Hennessy与团队一起创立了MIPS，将MIPS架构商业化

MIPS在90年代曾经一度辉煌过，Pacemips、IDT和东芝等半导体公司都采用MIPS的设计来制造芯片，其生产的芯片也被Sony和Nintendo的游戏机，Cisco的路由器和SGI超级计算机等终端设备采用，尤其是家用路由器市场，到现在每年生产的超过160亿微处理器中，99%是RISC处理器。过去也曾当作高效能计算架构使用到超算平台上

但是在智能手机时代中，因为在嵌入式、低能耗方面被ARM架构取代，并且因为授权和收费方式等原因。MIPS在中高端芯片中也逐渐失去优势

## *ARM*

### 简介

* ARM（Advanced RISC Machines）架构是一种流行的 RISC 架构，广泛应用于移动设备、嵌入式系统和服务器
* ARM 处理器具有高度的灵活性，可以根据应用需求进行定制。它有不同级别的性能和能效，从低功耗嵌入式设备到高性能服务器
* 由于其能耗效率和多样性，ARM 架构成为移动设备、物联网和云计算领域的主要选择

### 历史

ARM 指令集架构的历史与发展 - Salieri的文章 - 知乎 <https://zhuanlan.zhihu.com/p/350962975>

1. 1983年Acorn公司开启了基于UC Berkeley RISC项目的新处理器架构研发项目Acorn RISC Machine (ARM)。
2. 1985年4月，第一代基于ARMv1架构的ARM1处理器正式发布，它主要以工业用途作为BBC Micro平台上的协处理器，来加速下一代芯片开发软件的运行
3. 1990年，在Acorn和Apple的合作下，Acorn的先进研发部门被剥离出来，成立了单独的ARM公司

ARMv9是目前最新的ARM架构，Cortex-A、Cortex-R、Cortex-M都是著名的ARM架构，苹果的M系列芯片也是ARM架构的

### 实际应用

ARM架构的灵活性、低功耗和性能使其成为各种嵌入式系统和移动设备的理想选择，甚至可以说占据了以移动设备为代表的处理器IP的绝大部分市场。同时也在其他领域如物联网、网络设备、汽车电子等方面发挥着重要作用

1. **移动设备**：ARM架构在移动设备市场占有重要地位，如智能手机、平板电脑和可穿戴设备。ARM处理器因其低功耗、高效能和性能表现而受到欢迎，可以满足移动设备对电池寿命和性能的需求
2. **嵌入式系统**：ARM在嵌入式系统中得到广泛应用，包括家电、工业控制、汽车电子、医疗设备等。ARM架构适合于这些领域，因为它可以提供足够的性能，同时保持低功耗
3. **物联网（IoT）**：由于ARM的低功耗特性，它在连接设备到互联网的物联网应用中非常流行。无论是智能家居、智能传感器还是工业物联网，ARM处理器都能够提供所需的性能和能效
4. **嵌入式操作系统**：许多嵌入式操作系统，如Linux、Android和RTOS（实时操作系统），都支持ARM架构。这使得ARM成为嵌入式系统开发的首选平台
5. **网络设备**：ARM处理器也在网络设备中得到广泛应用，如路由器、交换机、网络防火墙等。它们能够提供足够的处理能力来管理和路由网络流量
6. **汽车电子**：现代汽车中使用了大量的电子设备，包括驾驶辅助系统、娱乐系统、安全系统等。ARM架构可以为这些应用提供适当的处理性能和能效
7. **媒体和娱乐**：ARM架构在媒体播放器、游戏控制台、数字电视等领域中也有应用。其处理器能够满足多媒体处理和图形渲染的要求

## *RISC-V*

### 简介

* RISC-V 是一种**开源**RISC架构，具有可伸缩性和可定制性
* RISC-V 的设计哲学强调简化指令集和开放性。它的设计遵循开放指令集的原则，允许任何人基于 RISC-V 架构开发自己的处理器
* 由于其开源性质和灵活性，RISC-V 在教育、研究和定制化硬件等领域受到关注。它正在逐步进入商业领域

### 历史

2010年，奠定了RISC基础的UC Berkeley教授DavidDavid Patterson的准备启动一个新项目，需要设计CPU，因而要选择一种指令集。他们调研了包括arm、MIPS、SPARC、X86等多个指令集，发现它们不仅设计越来越复杂，而且还存在知识产权问题

RISC-V（第五代精简指令集）是David Patterson教授基于其30多年在精简指令集RISC领域的深入积累，在2010年到2014年期间带领团队研发出的最新一代CPU芯片设计指令集。RISC-V是基于RISC原理建立的开放指令集架构，RISC-V是在指令集不断发展和成熟的基础上建立的全新指令。RISC-V指令集完全开源、设计简单、易于移植Linix系统，采用模块化设计，拥有完整工具链

### RISC-V与ARM的竞争

https://www.eet-china.com/mp/a120053.html

MIPS、RISC-V和ARM同根同源，都出自RISC架构

RISC-V一经推出，就得到了极大的关注，甚至已经形成了事实上的对ARM架构的冲击，其中ARM授权费，而RISC-V则完全开源是关键的因素

ARM是一种封闭的指令集架构，众多只用ARM架构的厂商，只能根据自身需求，调整产品频率和功耗，不得改变原有设计，经过几十年的发展演变，CPU架构变得极为复杂和冗繁，ARM架构文档长达数千页，指令数目复杂，版本众多，彼此之间既不兼容，也不支持模块化，并且存在着高昂的专利和架构授权问题

反观RISC-V，在设计之初，就定位为是一种完全开源的架构，规避了计算机体系几十年发展的弯路，架构文档只有二百多页，基本指令数目仅40多条，同时一套指令集支持所有架构，模块化使得用户可根据需求自由定制，配置不同的指令子集

ARM与RISC-V的竞争有些像OS市场上Win和Linux的竞争。几乎可以肯定的是，在ARM的传统优势领域，即手机领域，RISC-V基本没有机会，因为手机经过十年迭代后不太会彻底改变处理器内核了，这也和目前Windows经过二十多年风雨仍然是PC市场操作系统龙头老大一样。但是，在新兴的领域，RISC-V和ARM都处于同一起跑线上，而RISC-V凭着指令集开源等特性很有可能可以击败ARM，或者至少能够占据可观的市场份额。比如说IoT市场、新能源、嵌入式设备等

## *Intel x86*

### 简介

* Intel x86 是一种CISC架构的典型代表，由英特尔推出。它广泛应用于个人电脑领域，占领了市场上95%的份额
* x86 架构拥有大量的指令集和多种寻址模式，可以执行复杂的操作。它最初用于桌面和服务器计算，现在也适用于移动设备和嵌入式系统
* 在个人计算机领域，x86 架构的代表性产品包括 Intel 的 Core 和 Xeon 系列处理器，以及 AMD 的类似架构

### Intel x86的演化

1. **86的起源（上世纪70年代末）**：

   1978年：Intel推出了8086处理器，这是x86架构的最早版本，为16位处理器，由8位的8080扩展而来。8086开创了x86架构的先河

2. **16位时代（1980年代）**：

   1982年：Intel推出了80286（或称286），这是x86架构的第二代处理器，引入了16位保护模式，并且具有更强的性能和内存管理能力

3. **32位时代（1990年代）**：

   * 1985年：Intel发布了80386（或称386），第三代x86处理器，引入了32位操作模式和虚拟内存支持，大大提升了性能和多任务能力
   * 1993年：Intel推出了80486（或称486），这是386的改进版本，提升了性能和缓存

4. **Pentium时代（1990年代后半）**：

   * 1993年：Intel推出了Pentium处理器（第一代Pentium，也称P5），继续在32位基础上提升了性能
   * 后续几年，Intel推出了多个Pentium处理器的改进版本，包括Pentium Pro、Pentium MMX等

5. **Pentium II、III、4时代（1990年代末至2000年代）**：

   * 1997年：Intel发布了Pentium II处理器，引入了Slot 1插槽设计，以及L2缓存放在芯片外部的设计
   * 1999年：Pentium III发布，进一步改进了性能
   * 2000年：Intel推出了Pentium 4，引入了NetBurst微架构，但其设计在初期受到了一些争议

6. **Intel与AMD的竞争与合作（2000年代至2000年代末）**

   * 2003年由AMD率先基于Intel的32位架构将32位地址空间扩展为64位，推出了AMD64，趁着互联网高速发展的东风，抢占了不少市场份额
   * AMD公司和Intel都是从仙童半导体公司中分出来的。AMD一直都是和Intel一样生产x86架构的芯片。在共同对抗RISC架构，维护CISC架构在市场上的地位这方面AMD和Intel有共同利益。因为AMD的研发水平、市值和资金方面远远达不到Intel的水平，Intel也出于对抗反垄断法等原因，和AMD公司一直都是合作大于对抗，所以不久便也接受了AMD64架构，而后Intel也开始支持AMD64的指令集，称为x86-64，即x86架构的64位版本，不过二者基本上是同一个东西

7. **核心架构时代（2000年代末至2010年代）**：

   * 2006年：Intel发布了Core微架构，首次应用于Core 2 Duo处理器，这标志着x86架构的一个重要转折点，带来了更好的性能和能效
   * 随后的几年，Intel发布了多个基于Core架构的处理器，包括i3、i5和i7系列，不断提升性能和多核能力

8. **现代时代（2010年代至今）**：

   * 2011年：Sandy Bridge架构发布，进一步优化性能和能效
   * 之后的年份，Intel陆续发布了多个新架构，如Ivy Bridge、Haswell、Broadwell、Skylake、Kaby Lake、Coffee Lake等，不断提升性能、能效和集成图形处理能力

# 程序的机器级表示（x86）

## *程序编码*

### 机器级代码 Machine-level code

机器级代码是连接高级语言与CPU的中间状态，它有两个含义，一是最终经过编译、汇编和链接的目标代码 object code（二进制指令），二是汇编代码则是机器代码的文本比哦啊是，给出程序中的每一条指令。每条指令会继续根据不同的CPU指令集 Instruction-Set 继续翻译成CPU可以理解的二进制代码

编译器较高的优化登记会导致汇编代码产生严重变形，可读性严重下降。`-Og` 是减少GCC的优化程度，提高汇编程序的可读性，其中-g是 gdb debugging。较高的优化等级可以通过 `-O1`、`-O2` 等选项指定

### CPU简单的历史与概念

x86架构泛指所有的intel系列芯片，因为第一个系列芯片叫做8086。386是真正开创了PC的一款CPU，开始运行Unix系统了。intel提出的IA64（Itanium处理器）没有在市场上获得成功，反而是AMD将32位CPU扩展到了64位

从2003年开始，CPU的设计与制造由于功耗等限制不再只追求cpu的频率，而是通过多核来实现多任务处理速度和能耗之间的平衡

指令集：提供一系列指令，指示CPU该确切的做什么。指令集是一种抽象，不同的指令实现的目标可能是一样的，但底层的硬件操作不同，这也就给了优化的机会

历史上出现过很多知名的指令集架构，比如Alpha， SPARC，PowerPC，MIPS等，但是今天最流行的指令集架构是**x86(-64)，ARM，RISC-V**

ARM Acorn RISC Machine 架构，比x86更简单，功耗更低。RISC是精简指令集，之前用的都是CISC 复杂指令集

## *代码实例*

### 得到汇编代码

CSAPP书上的代码例子为

```c
// mstore.c
long mult2(long, long);

void multstore(long x, long y, long *dest)
{
    long t = mult2(x, y);
    *dest = t;
}
```

可以通过 `gcc -Og -S mstore.c` 得到 `mstore.s` 汇编代码

```assembly
    .file   "mstore.c"
    .text
    .globl  multstore
    .type   multstore, @function
multstore:
.LFB0:
    .cfi_startproc
    pushq   %rbx
    .cfi_def_cfa_offset 16
    .cfi_offset 3, -16
    movq    %rdx, %rbx
    call    mult2
    movq    %rax, (%rbx)
    popq    %rbx
    .cfi_def_cfa_offset 8
    ret
    .cfi_endproc
.LFE0:
    .size   multstore, .-multstore
    .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
    .section    .note.GNU-stack,"",@progbits
```

所有以 `.` 开头的文件是要喂给debugger、linker的，用来指导它们的工作。通常可以忽略它们

### 查看目标代码文件

`gcc -Og -c mstore.c` 可以得到目标代码文件 `mstore.o`

目标代码文件是二进制的，无法直接查看，可以通过GDB工具来查看它的十六进制序列版本。即 `gdb mstore.o`，然后在 `(gdb) `  prompt后面输入命令 `x/14xb multstore`

```assembly
(gdb) x/14xb multstore
0x0 <multstore>:	0x53	0x48	0x89	0xd3	0xe8	0x00	0x00	0x00
0x8 <multstore+8>:	0x00	0x48	0x89	0x03	0x5b	0xc3
```

### 反汇编器 disassembler

反汇编器可以将目标代码文件的二进制序列中复原出汇编代码，Linux中为GNU软件objdump。`objdump -d mstore.o`

```assembly
0000000000000000 <multstore>:
//Offset    Bytes                   Equivalent assembly language
       0:	53                   	push   %rbx
       1:	48 89 d3             	mov    %rdx,%rbx
       4:	e8 00 00 00 00       	callq  9 <multstore+0x9>
       9:	48 89 03             	mov    %rax,(%rbx)
       c:	5b                   	pop    %rbx
       d:	c3                   	retq
```

### 数据格式

因为是从16位扩展到32位的，所以intel用术语 **字 word** 来表示16位数据类型，32位为双字 double words，64位为四字 quad words

`char*` 代表的是指针类型，也用 `q` 来表示。双精度浮点数用的也是 `l` 来表示，但不会产生歧义，因为浮点数专用一套指令和寄存器

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/汇编指令操作数类型标识.png" width="50%">

### ATT与intel汇编代码格式

GCC、Objdump等GNU工具的默认格式是ATT格式（Bell lab from AT&T）。Microsoft、intel文档等工具则采用intel格式。用 `gcc -Og -S -masm=intel mstore.c` 来生成intel格式的汇编代码

```assembly
    .file   "mstore.c"
    .intel_syntax noprefix
    .text
    .globl  multstore
    .type   multstore, @function
multstore:
.LFB0:
    .cfi_startproc
    push    rbx
    .cfi_def_cfa_offset 16
    .cfi_offset 3, -16
    mov rbx, rdx
    call    mult2
    mov QWORD PTR [rbx], rax
    pop rbx
    .cfi_def_cfa_offset 8
    ret
    .cfi_endproc
.LFE0:
    .size   multstore, .-multstore
    .ident  "GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)"
    .section    .note.GNU-stack,"",@progbits
```

可以看到，intel格式的汇编代码和之前的ATT格式的汇编代码有很大的区别

* intel格式忽略了指示大小的后缀，比如是 `push` 而不是 `pushq`
* intel格式忽略了寄存器名字前面的 `%` 符号
* intel格式用不同的方式来描述内存中的位置，比如 `mov QWORD PTR [rbx], rax`，而不是 `movq    %rax, (%rbx)`
* 当带有多个操作数的指定情况下，列出操作数的顺序相反

## *访问信息*

### 寄存器的演进

寄存器是位于CPU中的，用来适配CPU高速数据取用需要的高速存储器

1. 8086：8个16位寄存器。即从 `%ax` 到 `%sp`
2. IA32架构：寄存器扩展为32位，标号为 `%eax` 到 `%esp`，%e.. 表示extended
3. x86-64：16个存储64位值的通用目的寄存器 general-purpose registers。以 `%r` 开头，%r.. 表示register

从IA32到x86-64：生成1字节和2字节数字的指令会保持剩下的字节不变；生成4字节数字的指令会把高位4个字节置0

### 操作数指示符

大多数指令有一个或多个操作数 operand，指示出执行一个操作中要使用的源数据值，以及防止结果的目的的位置

* 立即数 immediate 用来表示常数值，以 `$` 开头 + 标准C语言表示，注意默认是十进制，十六进制一定要用 `0x` 标识
* 寄存器 register：表示16个寄存器中的一个，比如 `%rax`。用符号 $r_a$ 来表示任意寄存器 $a$，用引用 $R[r_a]$ 来表示**寄存器内存的值**，相当于是把寄存器集合看成是一个数组 $R$，用寄存器标识符作为下标索引
* 内存引用 memory reference/寻址：**根据计算出来的有效地址访问某个内存位置**，用 `()` 括起来

通俗的解释一下三个操作数：立即数是一个普通的数，寄存器里面存了一个数，可以直接用来加减乘除等，但是**一旦立即数和内存引用被`()`了，那么它们里面存的数就是一个地址了，会被用来去寻找内存对应地址存的数据**

操作数格式与寻址模式 Addressing modes

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/OperandForms.png" width="60%">

最后一个内存引用方式 $Imm(r_b,r_i,s)$ 是最常用的。$r_b$ 是基址寄存器 base register，$r_i$ 是变址寄存器 index register，$s$ 是比例因子 scale factor，只能取1、2、4或8，用来适应不同的数据类型，比如int和long。举例：`9(%rax, %rdx, 4) == M[9 + R[%rax] + 4R[%rdx]]`

C数组可以进行算数运算来寻址就是借助了底层 $Imm(r_b,r_i,s)$ 这种寻址模式。这里也可以看出来C的设计很大一部分是参考了底层的汇编语言的，既形成了机器语言所没有的高级语言特性，又保留了一部分机器语言的灵活性

### 数据传送指令 `MOV`

`MOV` 指令用于将数据从源位置复制到目的位置，不做任何变化

* 数据类型匹配，传送不同字长的数据都是以32位补码数字作为源数据的，除了 `movabsq` 扩展到64位
* 小到大需要填充高位：`MOVZ` 零扩展和 `MOVS` 符号扩展

理论中应该有9种MOV的搭配方式。immediate不能作为dest，因为它是常数，去掉了3种。另外出于硬件设计的便利性，**不能直接将一个内存位置复制到另一个内存位置**，而是会采用DMA来协调完成（**内存->寄存器，寄存器->内存两步走**），去掉了1种。因此一共有5种source和destination的组合

为什么是两个临时变量：因为不能从内存直接传值给内存，还是要写成两句，中间用个寄存器。比如下面这个例子，c语言可以只用一个临时变量，但需要有一句 `*xp = *yp;`，编译后就是两个寄存器

```cpp
void swap(int* xp, int* yp)
{
    int tmp = *xp; //临时变量tmp放在了寄存器里
    *xp = *yp; //不能是内存到内存的直接操作，要放到一个寄存器里
    *yp = tmp;
}
```

```assembly
    movl    (%rdi), %eax
    movl    (%rsi), %edx
    movl    %edx, (%rdi)
    movl    %eax, (%rsi)
    ret
```

### `lea`

`lea () r_a` 加载有效地址，load effective address 的形式是从内存读数据到寄存器，但实际上 `()` 根本没有进行内存引用（也就是说对括号里的数字（当然此时代表了地址）进行寻址），而是直接将 `()` 里的数字（地址）写入目标寄存器，**相当于 `()` 此时是无效的！**

因为可以直接取到数字/地址，所以用 `lea` 来实现C语言里的 `&` 操作符。注意：指针是C语言给的一种抽象，机器代码里指针就是地址·

GCC特别喜欢用它来描述间接的算数运算，下面给出一个例子

```c
long scale(long x, long y, long z)
{
    long t = x + 4 * y + 12 * z;
    return t;
}
```

当开启高优化等级的时候（`-O1` 或 `-O2`），可以得到下面的汇编代码

```assembly
# x in %rdi, y in %rsi, z in %rdx 实参没有保存在内存中，而是临时放在寄存器中
leaq    (%rdi,%rsi,4), %rax # x + 4y 放入新的寄存器rax中
leaq    (%rdx,%rdx,2), %rdx # 3z = z + 2z
leaq    (%rax,%rdx,4), %rax # x + 4y + 12z
ret
```

`lea` 容易与 `mov` 混淆，区别在于，`mov` 的作用是移动数据，如果操作数是 `()` ，它会对其寻址（即内存引用），但 `lea` 则不会对 `()` 内存引用，而是直接将 `()` 括号内的地址写入目标寄存器

lea功能等于一个线性方程，因为有独立的电路来实现，所以比常规的用add和mul的方法计算速度更快

### 算数运算

下面的所有运算都会设置条件码

* 一元操作符：`INC` ++（ZF+OF）、`DEC` --（ZF+OF）、`NEG` 取负、`NOT` 取补
* 二元操作符
  * `ADD`、`SUB`、`IMUL`、`XOR`（CF+OF）、`OR`、`AND`
  * 汇编没有除法，因为它的效率非常低 https://cjting.me/2021/03/16/the-missing-div-instruction-part1/
* 移位（CF）：`SHL` Shift Logical Left 左移、`SAL` 算数左移、`SAR` 算数右移、`SHR` 逻辑右移

### 特殊的算数操作：为什么要区分有符号数和无符号数？

https://www.cnblogs.com/walkerlala/p/5686014.html

为什么对于`ADD`、`SUB` 不需要区分有符号数还是无符号数，而乘除法却要区分操作数是有符号数还是无符号数来分别使用 `IMUL` 和 `MUL` 呢？

首先要明确，对于机器而言，其实没有什么补码、原码或者有符号数、无符号数之分，**有符号数和无符号数的加法对于CPU而言是完全等价的**，CPU只是对二进制串进行简单的加法运算（加减乘除都是以加法器为基础扩展开来的）。有符号数和无符号数是语言层次的概念，是用户定义了如何看待某个二进制串计算结果

那么是如何做到可以识别语言层级的 `signed` 和 `unsigned` 呢？需要借助条件码的帮助。The CARRY flag and OVERFLOW flag in binary arithmetic: http://teaching.idallen.com/dat2343/10f/notes/040_overflow.txt。在这篇文章中清楚的说明了不论是无符号数还是有符号数都要设置 Carry Flag 和 Overflow Flag 的条件码寄存器，但是对于无符号数来说只有CF是有作用的，而对于有符号数只有OF有效

```assembly
0000-0001 = 1111 # CF and OV will be set simultanesouly
```

从上面的例子中可以看出，加法是有可能会同时设置CF和OF两个条件码寄存器的，而我们只要去检查CF和OF就可以得到相应的结果了，所以`ADD`、`SUB` 不需要区分有符号数还是无符号数

但是对于乘除法就不同了，不同于加减法设置CF和OF与用户看待操作数的视角无关，乘除法的结果是否要设置OF，要看操作数是有符号数还是无符号数。比如 `-1*-2=2`，比如有符号数，它没有溢出，但是如果是无符号数，显然就溢出了，所以要区分两条机器指令

注意：`imulq` 和 `idivq` 既有单操作数形式，也有双操作数形式，注意区分

## *控制流 Control*

**`%rip` instruction pointer：存储当前正在执行的指令的地址**

### 条件码

除了整数寄存器，CPU还维护了一组条件码寄存器 condition codes，用来描述最近的算数或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。它们不是直接设置的，而是根据其他指令操作后的结果设置的

* CF Carry Flag (for unsigned)：进位标志，最近的操作使最高位产生了进位，**可以用来检查无符号操作的溢出**
* SF Sign Flag (for signed)：符号标志，最近的操作得到的结果为负数
* ZF Zero Flag：零标志，最近的操作的出的结果为0
* OF Overflow Flag (for signed)：溢出标志，最近的操作导致一个**补码溢出**（正溢出或负溢出）

所有算数和逻辑运算都会设置条件码，`leq` 不会设置，因为它是针对地址的运算

`CMP` 和 `TEST` 只会设置条件码而不会改变任何其他寄存器

* `CMP` 根据两个操作数之差来设置条件码，相当于是只设置条件码的 `SUB`。注意ATT格式中 `CMP` 的两个操作数顺序是反的（即右操作数减去左操作数）

  ```assembly
  comq %rsi, %rdi # a in %rdi, b in %rsi -> 根据 t = a - b 的结果来设置条件码
  ```

* `TEST` 是不设置条件码的 `AND`，不会影响到OF和ZF。常用 `testq %rax, %rax` 来检查 `%rax` 是负数、零还是正数

  ```assembly
  # 多位测试：测试al寄存器的位 0 和位 3 是否置 1
  test al, 00001001b #测试位 0 和位 3，其中00001001b是掩码
  # 只有当&结果为0时ZF才置1，表明位 0 和位 3已经被清除
  ```

### 条件码的使用

最近的一次指令会设置条件码，比如算数指令、`SET`、`TEST`、`CMP`，然后可以利用新置的条件码进行以下操作

* 根据条件码的某种组合将**一个字节**设置为0或者为1：`SET` 指令族
  * `SET` 指令的操作数是低位单字节寄存器，比如 `%al`，然后用 `movzbl` 将寄存器的高位清零（虽然是四字l，但会自动把更高位的其他4位也清零）
  * `SET` 指令族里有很多同义名 synonym，比如 `setq` 当大于时设置 和 `setnle` 当不小于等于时设置 效果是一样的。底层到底用哪一条机器指令取决于编译器和汇编器
  * 区分有符号数和无符号数的算数运算
    * 有符号数：利用SF^OF（异或）和ZF的组合
    * 无符号数：利用CF和ZF标志的组合
* 可以条件跳转到程序的某个其他的部分：`jump` 指令可以改变一组机器代码指令的执行顺序
* 借助条件码，用 `CMOV` 来实现条件分支

### General translation of conditional branch with `jX`

`jX` 指令族

* 无条件跳转，相当于条件码一直为1
  * 直接跳转：跳转目标是作为指令的一部分编码的，比如 `jmp .L1` 跳转到 `.L1` 标号 label处
  * 间接跳转：跳转目标是从寄存器或内存位置中读出来的，比如 `jmp *(%rax)`，从 `%rax` 寄存器内存引用得到里面存放的地址后跳转到该地址
* 有条件跳转：利用条件码的组合条件进行跳转，比如 `je` 是当条件码ZF置1时（相等/零）进行跳转

用 `jX` 指令族实现 `if-else` 条件分支：**`jX` 类似于 `goto` 跳转**

```c
long lt_cnt = 0;
long ge_cnt = 0;
long absdiff_se(long x, long y)
{
    long result;
    if (x < y) {
        lt_cnt++;
        result = y - x;
    }
    else {
        ge_cnt++;
        result = x - y;
    }
    return result;
}
```

可以得到汇编代码

```assembly
# long absdiff_se(long x, long y)
# x in %rdi, y in %rsi 
1 absdiff_se:
2 	cmpq %rsi, %rdi               # Compare x:y
3 	jge .L2 If >=                 # goto x_ge_y
4 	addq $1, lt_cnt(%rip)         # lt_cnt++ 
5 	movq %rsi, %rax 
6 	subq %rdi, %rax               # result = y - x 
7 	ret Return 
8 .L2: #x_ge_y: label标志 类似于goto跳转到这里
9 	addq $1, ge_cnt(%rip)         # ge_cnt++
10 	movq %rdi, %rax 
11 	subq %rsi, %rax               # result = x - y 
12 	ret Return
```

### Conditional Move `CMOV` 来实现条件分支

现代CPU的分支预测逻辑 brach prediction logic 整体上是高效的，但预测错误的时候要走回头路就会造成严重的效率浪费。因此在一些情况下可以通过 Conditonal Move 来进行优化。条件传送指令族 `CMOV`（即根据条件码做出反应的 `MOV`）无需预测测试的结果就可以执行条件传送，效率高

考虑 `jX` 用过的例子，注意不同之处在于取消了自加命令，这是因为 `CMOV` 不能在会造成分支side-effect的时候使用

```c
long absdiff_se(long x, long y)
{
    long result;
    if (x < y) 
        result = y - x; //分支取消了自加
    else
        result = x - y;
    return result;
}
```

它的汇编代码为

```assembly
# long absdiff(long x, long y)
# x in %rdi, y in %rsi
1 absdiff: 
2 	movq %rsi, %rax 
3 	subq %rdi, %rax                 # rval = y-x 
4 	movq %rdi, %rdx 
5 	subq %rsi, %rdx                 # eval = x-y 
6 	cmpq %rsi, %rdi                 # Compare x:y 
7 	cmovge %rdx, %rax               # If >=, rval = eval 
8 	ret Return tval
```

因此类似于 `v = test-expr ? then-expr : else-expr` 这种有简单分支的三目运算符一般会使用 `CMOV`

为什么不一直使用 `CMOV` 来提高效率？

* 计算两个分支的效率比较低（特别是当一个分支的计算负载很大，比如说算密码）
* 有些时候有可能某个分支甚至是违法的，比如对空指针解引用等
* 有些时候则是会有副作用 side-effect ，比如一个分支是 `x+=3` 这种会改变变量

### 循环

汇编没有专门的一条指令来实现循环，而是要条件测试和跳转组合起来实现循环的效果

* do while循环：至少执行一次
* while循环：可能判断完条件不满足，直接退出了，一次也不执行
  * jump-to-middle
  * guarded-do，GCC较高的优化等级 `-O1` 会采用这种方式

* for循环
  * jump-to-middle
  * guarded-do


### `switch`

## *过程 Procedure*

Procedure遵守一套被普遍承认的约定（不是强制化的协议），称为应用二进制接口 Application Binary Interface ABI。ABI是机器代码级别的规范，比如如何使用寄存器、调用过程中的细节等等，它与可执行代码的二进制兼容性有关

AMD64的ABI：https://web.archive.org/web/20080528070803/http://www.x86-64.org/documentation.html

### Mechanisms in Procedures

* 传递控制 Passing control
  * To beginning of procedure code
  * Back to return point
* 传递数据 Passing data
  * Procedure arguments
  * Return value
* 分配和释放内存 Allocating and deallocating memory
  * Allocate during procedure execution
  * Deallocate upon return

### 运行时栈 Run-time stack

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/运行时栈.png" width="30%">

C语言过程调用机制的一个关键特性（大多数其他语言也类似）在于**使用了虚拟内存的栈数据段提供的后进先出的内存管理原则**。程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息

不论代码里总共有多少函数，在单一时候只有一个函数被调用。调用函数的信息总是处于栈底，而被调用函数的信息则被放到栈顶，当结束调用后，可以LIFO的被释放掉

**栈帧 stack frame 是为一个过程开辟的特定栈内存空间**。栈是从高地址向低地址增长，假设过程P caller 调用Q callee，栈空间其依次为：P可能压入的6-n号参数 -> P的返回指令地址 -> 最多6个用于传参的寄存器 -> Q的局部变量

栈帧为什么要设计成从高地址向低地址增长呢？个人理解是为了方便寻址，比如说 `long a = 1234` 这么一个初始化语句，和它相关的汇编代码是如下。如果栈帧设计成从低地址向高地址增长，那么寻址就要写成 `movq $1234, -8(%rsp)` 了，这样不自然

```assembly
subq $8 %rsp # 新分配8字节的栈帧
movq $1234, 8(%rsp) # 寻址分配
```

### 压栈和弹出栈

压栈和弹出栈的意思是**往栈里写入或弹出数据**

x86-64的16个寄存器中具有特殊用途的是 `%rsp` 寄存器，它专用于存储栈指针；`%rbp` 寄存器存的是栈底指针（即调用函数的栈顶），固定不变的 `%rbp` 可以用来定位函数活动记录中的各个数据

* `pushq Src`

  通过递减栈指针进行压栈。将一个四字值压入栈中，首先要将栈指针减8字节（之所以是8字节是因为x86-64的最大数据类型是8字节的，对齐到8字节），然后将值写到新的栈顶地址，等价于下面的指令

  ```assembly
  subq $8, %rsp       # Decrement stack pointer
  movq %rbp, (%rsp)   # 将%rbp里存的地址写到栈顶
  ```

  当然这两条指令是无法替代 `pushq`，因为 `pushq` 一共就1字节，上面两条指针加起来要8字节

* `popq Dest`：弹出数据/释放数据，不需要去抹去原来的数据，仅仅是移动一下栈指针就可以了

  ```assembly
  moveq (%rsp), %rax  # Read %rax from stack
  addq $8, %rsp
  ```

### 转移控制 Control transfer

* 利用5字节的 `callq Q` 指令将控制权从函数P转移到函数Q（指令的后缀q只是为了表明这是x86-64中的指令）
  * 更改PC中的指令地址：只需要简单地将往PC寄存器 `%rip` 里放Q代码指令的起始地址就可以了，CPU会自动执行PC里放的指令。**没有指令能够直接显式更改 `%rip`，`callq` 指令会隐式地来修改 `%rip`**
  * 保存返回地址：同时为了顺利地从Q返回时还能接上原来P的执行流，要保存好P函数里 `call Q` 指令后紧跟着的那条指令A，方便Q执行完后返回到这里，所以要将A也压入栈顶。同样的，这个功能也是 `callq` 隐式完成的压栈，从汇编代码上看不出来
  * `callq` 的效果相当于是 `jup` + `pushq`
* `retq` 指令
  * 从栈中弹出返回处的指令地址A
  * 把PC设置为A
  * 把返回数据存到 `%rax` 中

### 数据传送

整数和指针（scaler data 标量数据）

* 被调用过程最多可用6个寄存器来传参：以4字节寄存器为例，使用寄存器传参的顺序是 `%edi`、`%esi`、`%edx`、`%ecx`、`%r8d`、`%r9d`
* 6个以上的其余参数需要通过保存在调用函数P的栈帧空间来传递，即上图运行时栈中的参数构造区 Argument build area
* ``%rax` 用来返回数据，要注意的时若返回的数据太大，比如说一个返回一个结构题就需要两次中转，即返回的时候要再压栈保存一个temp（自我修养300）。因此Cpp中才会鼓励传引用传参

高级语言如果被设计成可返回多个值时，编译器/解释器在实现时会把多个返回值放在栈里

x86-64定长栈帧的大小一般为32到128个字节之间，取决于不同的编译器。因为是定长的，所以不需要使用 `%ebp` 来限定栈帧空间，此时 `%rbp` 可用作一个普通寄存器。但对于可变参数，是无法知道将分配多少空间的，所以要用 `%rbp` 来限定

递归：超过最大递归深度称为stack overflow `ulimit -s` 可以看到一个进程的栈的**最大值**为 8192 KB = 8MB。mac可以用 `limit` 命令查看

### 栈上的局部存储

对于以下这些情况，需要将数据放在栈上

* 寄存器的数量不足够存放所有的本地数据
* 查看参数的地址（&运算），因为无法创建寄存器的地址，所以会将参数存到栈帧里，然后返回它的栈地址

### 寄存器内容的局部存储

寄存器是所有caller和callee共享的，需要设法保存每一个函数的寄存器数据。ABI有两种convention

* Caller saved 调用者保存：caller将要调用其他函数的时候，寄存器放的数据要放到caller的栈里。**这种convention比较常用**。`%r10` 和 `%r11` 用来保存临时数据
* Callee saved 被调用者保存，使用寄存器 `%rbx`、`%rbp`（特殊）、`%r12`～ `%r15` 来保存临时数据
  * 在callee使用寄存器之前，callee把caller的寄存器数据放到callee的栈帧里
  * 在callee return之前，把保存在栈帧里的数据重新装载回相应的寄存器里

## *函数调用时的栈帧开辟过程*

### 一个具体的例子

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/函数栈帧.png">

1. 局部变量是怎么创建的？
   通过寄存器拷贝传入的参数创建一份临时拷贝，然后push到自己的栈上

2. 为什么局部变量的值是随机值
   在建立函数栈帧空间的时候编译器为其中的部分空间赋了随机值。赋多少空间，赋什么值取决于编译器，VS2019编译器赋的是 `CCCCCCCCh`

3. 函数是怎么传参的？传参的顺序是怎样的？
   从右向左建立栈帧传擦

4. 形参和实参是什么关系？
   从上图中可以看到，OOA179C和000A179F两条指令表示从 `%ebp`上面的两个压入的参数取值，然后放置在寄存器中，所以形参是实参的一份临时拷贝

5. 函数调用时怎么做的？
   通过call指令，调用函数，函数的地址就是其第一条指令的地址。将传入的参数置于原栈帧空间的栈顶。

6. 函数调用结束后时怎么返回的？
   将 `%esp` 和 `%ebp` pop，清空其栈帧空间，通过存储的ebp-main和call的下一条指令回到上一步调用函数的栈帧中

   当Add的栈帧被销毁时，z也会被销毁，因此不能直接返回Add中的临时变量z。做法是将return的值装载到一个寄存器中，并将寄存器中保存的值给原函数中的接收变量。如果是将临时变量z设置为静态变量z，即 `static int z`。那么z会被保存到静态区中，并不会被销毁。但编译器仍然会选择将z的值加入到寄存器中生成临时拷贝后返回给上层

7. 为什么子函数可以使用上级变量或者全局变量，但反过来不行，或者为什么同级函数不能互相调用变量？
   全局变量保存在静态区中不会被销毁，需要使用时随时可以调用

8. C语言不允许函数里定义函数，只能是一个函数call一个外面定义好的函数应该也是在调用栈链上调用者的变量不能传递的关系，只能通过寄存器传参

### 静态变量栈帧开辟的对比

```cpp
#include <iostream>
using std::cout;
using std::endl;

class A
{
public:
    A(int a = 0)
    {
        _a = a;
        cout << "A(int a = 0)->" <<_a<< endl;
    }

    ~A()
    {
        cout << "~A()->" <<_a<<endl;
    }
private:
    int _a;
};

A aa3(3); // 静态变量

void f()
{
    static int i = 0; // 具有块作用域的静态变量
    static A aa0(0);
    A aa1(1);
    A aa2(2);
    static A aa4(4);
}
int main()
{
    f();
    cout << endl << endl;
    f();

    return 0;
}
```

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/静态变量栈帧开辟比较.png">

虽然内存上的栈和静态区和数据结构中的栈在概念上是不一样的，但它们也有着先进后出的特点。静态区和常态区的变量是最先开辟和最后销毁的构造顺序：3 0 1 2 4 1 2

* 析构顺序：~2 ~1 ~2 ~1 ~4 ~0 ~3

## *内存安全*

### Memory-safety error

Memory-safety error 是指非法进入不被允许的内存区域

* Spatial errors: unintended address: buffer overflow, stack overflow (out-of-bounds)
* Temporal errors: unintended time: double free, dangling pointers (use-after-free, use-after-return)

通过对程序的静态分析和动态分析来提高安全性可以看*EIST软件工程.md*

### Binary Exploitation

Binary Exploitation（二进制漏洞利用）是一种计算机安全领域的技术，旨在利用软件程序中的漏洞来获取非授权访问、控制系统或执行恶意操作。它通常涉及对二进制可执行文件（如应用程序、操作系统或设备固件）进行分析和利用

二进制漏洞利用通常包括以下步骤：

1. 漏洞分析：对目标二进制程序进行静态或动态分析，以发现可能存在的漏洞。常见的漏洞类型包括缓冲区溢出、格式字符串漏洞、整数溢出、空指针解引用等
2. 漏洞利用：一旦发现漏洞，攻击者会利用漏洞来修改程序的正常执行流程，实现攻击目标。这可能涉及修改内存内容、覆盖函数指针、劫持程序控制流等
3. Shellcode injection 注入攻击：为了实现更复杂的攻击，攻击者通常会注入一段称为Shellcode的恶意代码。Shellcode被注入到目标程序的内存中，并在漏洞被利用时执行，以获取系统访问权限或执行其他恶意操作
4. 提权和权限提升：一旦攻击者获得对目标系统的控制，他们可能会利用其他漏洞或特权提升技术来提升自己的权限，以获取更高的访问权限或绕过安全措施

## *缓冲区溢出攻击*

C对于数组引用不进行任何边界检查，而栈中又有很多重要的信息，因此对越界数组元素的写操作会破坏存储在栈中的状态信息，若程序利用被破坏的状态重新加载寄存器或执行ret来跳转到其他程序，这就会是一个巨大的安全隐患

### [`gets()`](#gets) 的安全隐患

```c
char *gets(char *s)
{
    int c;
    char *dest = s;
    while ((c = getchar()) != '\n' && c != EOF)
        *dest++ = c; //++的优先级高于*
    if (c == EOF && dest == s)
    	return NULL;
    *dest++ = '\0';
    return s;
}

void echo()
{
    char buff[8];
    gest(buff); //读缓冲区
    puts(buff); //写缓冲区
}
```

查看汇编

```assembly
# void echo() 
1 echo: 
2 	subq $24, %rsp  # Allocate 24 bytes on stack 
3 	movq %rsp, %rdi # Compute buf as %rsp 
4 	call gets       # Call gets 
5 	movq %rsp, %rdi # Compute buf as %rsp
6 	call puts       # Call puts 
7 	addq $24, %rsp  # Deallocate stack space 
8 	ret             # Return
```

<img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/echo的栈.png">

上图是echo call puts的时候的栈帧，puts可以写到buff里

* 当写0-7字节的时候，没有破坏
* 写8-23字节的时候，echo中的栈信息被破坏
* 写24-31的时候，puts的栈里保存的echo的返回地址被破坏

### 缓冲区溢出攻击的形式

缓冲区溢出的攻击方式就是输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为攻击编码 exploit code，另外还有一些字节码会覆盖ret地址，它会指向攻击编码。比如1988年11月的Internet蠕虫病毒

* 攻击代码会使用系统调用启动一个shell程序，从而给攻击者部分系统调用权限
* 攻击代码会试图修复栈破坏，让它看起来是调用正常返回了

### 对抗措施

* 栈随机化 stack randomization

  * 内存地址空间预留一段0-n字节的合适的空间来进行随机化，栈随机化是地址空间布局随机化 Address-Space Layout Randomization ASLR 技术的一部分
  * 可以通过空操作雪橇 nop sled 来暴力破解，对于一个32位操作系统，随机化范围为 $2^{23}$，破解起来还是相对轻松的
  * 栈随机化增加了破解系统难度，但没有提供很强的安全保障

* 栈破坏检测 stack corruption detection

  GCC的栈报护者机制 stack protector：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的金丝雀值 canary 或者哨兵值 guard value，检查这个值是否被修改过，若是调用一个错误处理例程

  > 金丝雀值这个名字源于历史上用这种鸟在煤矿中察觉有毒气体

  <img src="/Users/wjfeng/Desktop/Notes/CS/ComputerArchitecture/Canary.png">

* 限制可执行代码区域 limiting executable code regions：扩展页表中的标记位，单独设置可执行权限

# 程序的机器级表示（RISC-V）

RISC-V中一个字 word的长度是32 bit/位或4字节，一个双字 doubleword 的长度是64 bit/位或8字节

寄存器长度为32位的变体称为RV32

## *机器指令表示*

### 设计权衡

设计机器指令的字段格式时需要在另所有指令保持相同长度和保持单一的指令格式之间权衡，RISC-V做出的选择是保持统一的32位指令长度，但为不同的指令设计不同的指令格式。具体的有R型、I型和S型字段

保持尽可能相似的指令格式降低了硬件的复杂性

### R型指令字段

R型（Register）指令字段用于寄存器

<img src="R型指令字段.png">

上面的指令中每一段称为一个字段 field，具体的指令格式为

* opcode 操作码：指令的基本操作
* rd：目的操作数寄存器，用来存放操作结果
* funct3：一个另外的操作码字段
* rs1：第一个源操作数寄存器
* rs2：第二个源操作数寄存器
* funct7：一个另外的操作码字段

RISC-V架构之所以设计了32个寄存器，也与这里的rs1和rs2字段设计长度有关，`2^5=32`。若要设计64个寄存器，则rs1和rs2都要增加一位，这就势必要缩减其他的字段长度

以 `add x9, x20, x21` 为例，它要将x20寄存器和x21寄存器中的值加起来后放到x9寄存器

对应的十进制表示为

```
0 | 21 | 20 | 0 | 9 | 51
```



### I型指令字段

<img src="I型指令字段.png">

I型指令字段用于带常数的算数指令，比如 `addi` 以及加载指令`ld`

当I型指令用于加载指令 `ld` 时，immediate 表示的是偏移量

### S型指令字段

<img src="S型指令字段.png">

## *运算*

### 加减乘除

### 移位

## *控制流*

## *过程*

## *RISC-V指令系统的剩余部分*

### 扩展体系结构

# 程序的机器级表示（ARM）

# 计算机的算数运算

# 处理器 Processor

# 层次化存储

# 并行处理器 Parallel Processors